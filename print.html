<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Flint Wiki</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="user_guide.html"><strong aria-hidden="true">2.</strong> User Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="user_guide/installation.html"><strong aria-hidden="true">2.1.</strong> Installation</a></li></ol></li><li class="chapter-item expanded "><a href="syntax_cheatsheet.html"><strong aria-hidden="true">3.</strong> Syntax Cheatsheet</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="syntax_cheatsheet/basics.html"><strong aria-hidden="true">3.1.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="syntax_cheatsheet/basics/comments.html"><strong aria-hidden="true">3.1.1.</strong> Comments</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="beginners_guide.html"><strong aria-hidden="true">4.</strong> From Beginner to Expert</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="beginners_guide/1_hello_world.html"><strong aria-hidden="true">4.1.</strong> Hello World</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="beginners_guide/1_hello_world/1_program.html"><strong aria-hidden="true">4.1.1.</strong> The Hello Wprld Program</a></li><li class="chapter-item expanded "><a href="beginners_guide/1_hello_world/2_compiling.html"><strong aria-hidden="true">4.1.2.</strong> Compiling the Program</a></li></ol></li><li class="chapter-item expanded "><a href="beginners_guide/2_flint_basics.html"><strong aria-hidden="true">4.2.</strong> Flint Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="beginners_guide/2_flint_basics/1_comments.html"><strong aria-hidden="true">4.2.1.</strong> Comments in Flint</a></li><li class="chapter-item expanded "><a href="beginners_guide/2_flint_basics/2_indentation.html"><strong aria-hidden="true">4.2.2.</strong> Indentation in Flint</a></li></ol></li><li class="chapter-item expanded "><a href="beginners_guide/3_variables_and_types.html"><strong aria-hidden="true">4.3.</strong> Variables and Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="beginners_guide/3_variables_and_types/1_primitive_types.html"><strong aria-hidden="true">4.3.1.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="beginners_guide/3_variables_and_types/2_implicit_typing.html"><strong aria-hidden="true">4.3.2.</strong> Implicit Typing</a></li><li class="chapter-item expanded "><a href="beginners_guide/3_variables_and_types/3_string_interpolation.html"><strong aria-hidden="true">4.3.3.</strong> String Interpolation</a></li></ol></li><li class="chapter-item expanded "><a href="beginners_guide/4_control_flow.html"><strong aria-hidden="true">4.4.</strong> Control Flow: Making Decisions and Repeating Actions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="beginners_guide/4_control_flow/1_the_bool_type.html"><strong aria-hidden="true">4.4.1.</strong> The bool Type and Conditional Statements</a></li><li class="chapter-item expanded "><a href="beginners_guide/4_control_flow/2_boolean_operations.html"><strong aria-hidden="true">4.4.2.</strong> Boolean Operations</a></li><li class="chapter-item expanded "><a href="beginners_guide/4_control_flow/3_loops.html"><strong aria-hidden="true">4.4.3.</strong> Loops: Why Repetition Matters</a></li><li class="chapter-item expanded "><a href="beginners_guide/4_control_flow/4_enhanced_for_loop.html"><strong aria-hidden="true">4.4.4.</strong> Enhanced for Loop</a></li><li class="chapter-item expanded "><a href="beginners_guide/4_control_flow/5_the_range_type.html"><strong aria-hidden="true">4.4.5.</strong> The range Type</a></li></ol></li><li class="chapter-item expanded "><a href="beginners_guide/5_functions.html"><strong aria-hidden="true">4.5.</strong> Functions: Reusing Code and Organizing Logic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="beginners_guide/5_functions/1_what_is_a_function.html"><strong aria-hidden="true">4.5.1.</strong> What is a Function?</a></li><li class="chapter-item expanded "><a href="beginners_guide/5_functions/2_adding_arguments.html"><strong aria-hidden="true">4.5.2.</strong> Adding Arguments</a></li><li class="chapter-item expanded "><a href="beginners_guide/5_functions/3_returning_values.html"><strong aria-hidden="true">4.5.3.</strong> Returning Values</a></li><li class="chapter-item expanded "><a href="beginners_guide/5_functions/4_returning_multiple_values.html"><strong aria-hidden="true">4.5.4.</strong> Returning Multiple Values</a></li></ol></li><li class="chapter-item expanded "><a href="beginners_guide/6_data.html"><strong aria-hidden="true">4.6.</strong> Data: The Core of Flint</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="beginners_guide/6_data/1_why_data.html"><strong aria-hidden="true">4.6.1.</strong> Why Data?</a></li><li class="chapter-item expanded "><a href="beginners_guide/6_data/2_declaring_data_modules.html"><strong aria-hidden="true">4.6.2.</strong> Declaring Data Modules</a></li><li class="chapter-item expanded "><a href="beginners_guide/6_data/3_default_values.html"><strong aria-hidden="true">4.6.3.</strong> Default Values</a></li><li class="chapter-item expanded "><a href="beginners_guide/6_data/4_nested_data.html"><strong aria-hidden="true">4.6.4.</strong> Nested Data</a></li><li class="chapter-item expanded "><a href="beginners_guide/6_data/5_using_data_in_functions.html"><strong aria-hidden="true">4.6.5.</strong> Using Data in Functions</a></li></ol></li><li class="chapter-item expanded "><a href="beginners_guide/7_arrays.html"><strong aria-hidden="true">4.7.</strong> Arrays: Organizing Data Sequentially</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="beginners_guide/7_arrays/1_introduction.html"><strong aria-hidden="true">4.7.1.</strong> Introduction to Arrays</a></li><li class="chapter-item expanded "><a href="beginners_guide/7_arrays/2_iterating_over_arrays.html"><strong aria-hidden="true">4.7.2.</strong> Iterating Over Arrays</a></li><li class="chapter-item expanded "><a href="beginners_guide/7_arrays/3_multidimensional_arrays.html"><strong aria-hidden="true">4.7.3.</strong> Multidimensional Arrays</a></li><li class="chapter-item expanded "><a href="beginners_guide/7_arrays/4_access_patterns.html"><strong aria-hidden="true">4.7.4.</strong> Access Patterns with Ranges</a></li><li class="chapter-item expanded "><a href="beginners_guide/7_arrays/5_multidimensional_access_patterns.html"><strong aria-hidden="true">4.7.5.</strong> Multidimensional Access Patterns</a></li></ol></li><li class="chapter-item expanded "><a href="beginners_guide/8_entities.html"><strong aria-hidden="true">4.8.</strong> Entities: Organizing Behavior and Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="beginners_guide/8_entities/1_monolithic_entities.html"><strong aria-hidden="true">4.8.1.</strong> Monolithic Entities: The Basics</a></li><li class="chapter-item expanded "><a href="beginners_guide/8_entities/2_func_modules.html"><strong aria-hidden="true">4.8.2.</strong> Func Modules: Modularizing Behavior</a></li><li class="chapter-item expanded "><a href="beginners_guide/8_entities/3_from_monolithic_to_modular.html"><strong aria-hidden="true">4.8.3.</strong> From Monolithic to Modular Entities</a></li><li class="chapter-item expanded "><a href="beginners_guide/8_entities/4_using_multiple_data_and_func.html"><strong aria-hidden="true">4.8.4.</strong> Using Multiple Data and Func Modules</a></li><li class="chapter-item expanded "><a href="beginners_guide/8_entities/5_introducing_links.html"><strong aria-hidden="true">4.8.5.</strong> Introducing Links</a></li><li class="chapter-item expanded "><a href="beginners_guide/8_entities/6_extending_entities.html"><strong aria-hidden="true">4.8.6.</strong> Extending Entities</a></li></ol></li><li class="chapter-item expanded "><a href="beginners_guide/9_concurrency.html"><strong aria-hidden="true">4.9.</strong> Concurrency: Unlocking the Power of Parallelism</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="beginners_guide/9_concurrency/1_understanding_concurrency.html"><strong aria-hidden="true">4.9.1.</strong> Understanding Concurrency</a></li><li class="chapter-item expanded "><a href="beginners_guide/9_concurrency/2_flints_concurrency_features.html"><strong aria-hidden="true">4.9.2.</strong> Flint's Concurrency Features</a></li><li class="chapter-item expanded "><a href="beginners_guide/9_concurrency/3_shared_data.html"><strong aria-hidden="true">4.9.3.</strong> Shared Data</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Flint Wiki</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This is the Flint Wiki. You will have the whole Wiki, examples, beginners guide, syntax cheatsheet, and more in this book!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-user-guide"><a class="header" href="#the-user-guide">The User Guide</a></h1>
<p>In the user guide is all the guidance for the user.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>Just DO IT.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preamble"><a class="header" href="#preamble">Preamble</a></h1>
<p>Inside this chapter, all things about the syntax are written down, everything that can be done within the syntax' bounds can be found here.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-basics"><a class="header" href="#the-basics">The Basics</a></h1>
<p>In the basics, there are...well...the basics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="single-line-comment"><a class="header" href="#single-line-comment">Single-line comment</a></h1>
<p>A single line comment can easily be made with the <code>//</code> operator.</p>
<pre><code class="language-rs">// This is a comment
</code></pre>
<h1 id="multi-line-comment"><a class="header" href="#multi-line-comment">Multi-line comment</a></h1>
<p>A multi-line comment can easily be started with the <code>/*</code> operator and ended with the <code>*/</code> operator.</p>
<pre><code class="language-rs">/* Multi-line
comment

*/
</code></pre>
<h1 id="flintdoc-comments"><a class="header" href="#flintdoc-comments">FlintDoc comments</a></h1>
<p>To document you code, e.g. what a method is doing, you can use a YAML inspired structure to do so.</p>
<pre><code class="language-rs">/**
Adds two numbers together

Params:
- x: The first number to add
- y: The second number to add

Returns:
- int: The sum of `a` and `b`

Author:
- Julius Grünberg
*/
def add(int x, y) -&gt; int:
    return x + y;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-beginner-to-expert"><a class="header" href="#from-beginner-to-expert">From Beginner to Expert</a></h1>
<p>This is the beginners guide. A guide for beginners.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<pre><code class="language-rs">def main():
    print("Hello, World");
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-hello-world-program"><a class="header" href="#the-hello-world-program">The Hello World Program</a></h1>
<p>Lets create a simple <code>Hello World!</code> program! The entry point of every Flint program is the <code>main</code> function. It returns an integer exit code. This function is reserved for the programs entry point, so no other function is allowed to be called <code>main</code>.</p>
<p>To define a function, we introduce the <code>def</code> keyword. Like Python, Flint does not use curly braces (<code>{</code>, <code>}</code>) to determine what is inside a function, but hard tabs (<code>Tab</code>, <code>\t</code>)!</p>
<p>The end of every line has to be maked by writing a semicolon <code>;</code>.</p>
<p>With this out of the way, lets create a small simple Hello World program!</p>
<pre><code class="language-rs">def main():
    print("Hello, World!");
</code></pre>
<p>The text between the <code>"</code> symbols is called a <strong>string</strong> (<code>str</code>) but this will be learned later, in the <a href="beginners_guide/1_hello_world/1_program.html#types">next</a> chapter! For now, all we have to know is, that <code>print</code> is a function, which outputs whatever string it recieves to the console. The output of the above program would look like</p>
<blockquote>
<p>Hello, World!</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiling-the-program"><a class="header" href="#compiling-the-program">Compiling the Program</a></h1>
<p>Save the above code into a file named <code>hello.ft</code>. <code>ft</code> is the file extension for <code>Flint</code> source files. They only contain code in written form.</p>
<p>To compile the <code>.ft</code> file to an executable file, we call</p>
<pre><code class="language-sh">flint compile ./hello.ft -o ./hello
</code></pre>
<p>This will output the executable in the current working directory. It can be exexuted with the command</p>
<pre><code class="language-sh">./hello
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="comments-in-flint"><a class="header" href="#comments-in-flint">Comments in Flint</a></h1>
<p>In Flint, comments are used to explain code or temporarily disable parts of it during debugging. Flint supports two types of comments:</p>
<ol>
<li><strong>Single-line comments</strong>: Start with // and continue until the end of the line.</li>
<li><strong>Multi-line comments</strong>: Start with /* and end with */.</li>
</ol>
<p><strong>Here’s how you use comments:</strong></p>
<pre><code class="language-rs">def main():
    // This is a single-line comment explaining the print statement below
    print("Hello, Flint!");

    /*
     This is a multi-line comment.
     You can use it for detailed explanations
     or temporarily disabling multiple lines of code.
    */
    // print("This line is commented out and won't run.");
</code></pre>
<p>Comments are essential for writing clear, understandable, and maintainable code. Use them to explain your logic to others (or to yourself when revisiting code later).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indentation-in-flint"><a class="header" href="#indentation-in-flint">Indentation in Flint</a></h1>
<p>Flint enforces <strong>strict indentation rules</strong> to ensure clean and readable code. Only <strong>hard tabs</strong> (\t) are allowed for indentation. Each tab indicates a new level of nesting.</p>
<p>Let’s see why proper indentation is crucial:</p>
<pre><code class="language-rs">def main():
print("This is not indented correctly.");
</code></pre>
<p>When you run the above code, you’ll see an error:</p>
<blockquote>
<p>Error: Indentation expected for block inside main().</p>
</blockquote>
<p>This happens because Flint expects all code inside main to be indented. Here’s the correct way to write it:</p>
<pre><code class="language-rs">def main():
	print("This is correctly indented."); // Properly indented with a hard tab
</code></pre>
<p>Use comments to explain your code and highlight mistakes. For example:</p>
<pre><code class="language-rs">def main():
// The following line is not indented and will cause an error:
print("Oops, this won't work!");

// Uncomment the next line to fix the indentation:
	// print("Now it works!");
</code></pre>
<p>Proper indentation is not just a stylistic choice in Flint—it’s a fundamental part of the syntax. By using only hard tabs, Flint ensures consistency across projects.</p>
<hr />
<p>Now you’re ready to move on to variables and types, where we’ll dive deeper into how to store and manipulate data!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables-and-types"><a class="header" href="#variables-and-types">Variables and Types</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h1>
<p>Primitive types are Flint's fundamental building blocks for representing data. They are the simplest forms of values you can use in your programs. Flint has the following primitive types:</p>
<ol>
<li><code>int</code>
Represents whole numbers, both positive and negative. Use int for counting, indexing, or whenever you need discrete values.</li>
</ol>
<pre><code class="language-rs">int x = 42; // A positive integer
int y = -15; // A negative integer
int z = 0; // Zero is also an integer
</code></pre>
<ol start="2">
<li><code>flint</code>
Represents floating-point numbers (decimal numbers). Use flint for measurements, precise calculations, or any value that requires a fractional component.</li>
</ol>
<pre><code class="language-rs">flint pi = 3.14; // Approximation of π
flint temperature = -273.15; // Negative decimal values are valid
flint zero = 0.0; // Zero with a decimal
</code></pre>
<ol start="3">
<li><code>str</code>
Represents a sequence of characters or text. Use str for names, messages, or any textual data. Strings must be enclosed in double quotes (").</li>
</ol>
<pre><code class="language-rs">str name = "Flint"; // A simple string
str empty = ""; // An empty string
str greeting = "Hello, World!"; // A common example
</code></pre>
<p>These types are the foundation of Flint's data handling. As you write more complex programs, you'll combine them in creative ways to represent and manipulate information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implicit-typing"><a class="header" href="#implicit-typing">Implicit Typing</a></h1>
<p>Flint allows for implicit typing, meaning you don't always need to explicitly state the type of a variable. The compiler can infer the type based on the assigned value.</p>
<p><strong>Here’s how it works:</strong></p>
<pre><code class="language-rs">x := 42; // The compiler infers that x is an int
pi := 3.14; // The compiler infers that pi is a flint
greeting := "Hello, Flint!"; // The compiler infers that greeting is a str
</code></pre>
<p>While implicit typing is convenient and makes code concise, explicit typing can improve readability in more complex programs. You can always use explicit typing if you want clarity:</p>
<pre><code class="language-rs">int x = 42; // Explicitly declare x as an int
flint pi = 3.14; // Explicitly declare pi as a flint
str greeting = "Hello, Flint!"; // Explicitly declare greeting as a str
</code></pre>
<p>Use implicit typing for shorter, simpler programs and explicit typing when clarity is crucial.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-interpolation"><a class="header" href="#string-interpolation">String Interpolation</a></h1>
<p>In Flint, you can embed variables or expressions directly into strings using string interpolation. This makes constructing strings with dynamic content both easy and readable. To interpolate, use the $"{...}" syntax.</p>
<p><strong>Here’s an example:</strong></p>
<pre><code class="language-rs">str name = "Flint";
int age = 1;
print($"Hello, my name is {name} and I am {age} years old.");
</code></pre>
<p>Output:</p>
<blockquote>
<p>Hello, my name is Flint and I am 1 years old.</p>
</blockquote>
<p>You can interpolate any variable or expression into a string:</p>
<pre><code class="language-rw">flint pi = 3.14;
print($"The value of pi is approximately {pi}."); // Insert a flint value
print($"2 + 2 equals {2 + 2}."); // Insert an arithmetic expression
</code></pre>
<p><strong>Remember:</strong></p>
<p>The print function only takes a single argument of type str.</p>
<p>Use string interpolation whenever you need to build strings dynamically—it’s clean, concise, and avoids manual concatenation.</p>
<hr />
<p>Now that you understand Flint’s primitive types, implicit typing, and string interpolation, you’re ready to explore how to work with arrays and collections of data!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow-making-decisions-and-repeating-actions"><a class="header" href="#control-flow-making-decisions-and-repeating-actions">Control Flow: Making Decisions and Repeating Actions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-bool-type-and-conditional-statements"><a class="header" href="#the-bool-type-and-conditional-statements">The <code>bool</code> Type and Conditional Statements</a></h1>
<h2 id="introduction-to-bool"><a class="header" href="#introduction-to-bool">Introduction to bool</a></h2>
<p>In Flint, the bool type represents truth values: true or false. Boolean values are fundamental in programming, as they enable decision-making and control flow. For example:</p>
<pre><code class="language-rs">bool is_learning = true;
bool is_hungry = false;
</code></pre>
<p>Here, isLearning is set to true, meaning it’s "on," while isHungry is false, meaning it’s "off."</p>
<h2 id="the-if-statement"><a class="header" href="#the-if-statement">The if Statement</a></h2>
<p>The if statement lets your program execute code only when a condition evaluates to true. Here's how it works:</p>
<pre><code class="language-rs">int age = 18;

if (age &gt;= 18): // The condition evaluates to true
    print($"You are {age} years old, so you can vote!");
</code></pre>
<p>If the condition evaluates to false, the program skips the block of code inside the if.</p>
<p><strong>Indentation Reminder</strong>: Remember to use hard tabs for indentation! Without proper indentation, Flint won't understand which code belongs to the if block.</p>
<h2 id="the-else-keyword"><a class="header" href="#the-else-keyword">The else Keyword</a></h2>
<p>What if you want to handle both possibilities? That’s where else comes in:</p>
<pre><code class="language-rs">int age = 16;

if (age &gt;= 18): // If this is false...
    print($"You are {age} years old, so you can vote!");
else: // ...then this block executes
    print($"You are {age} years old, so you cannot vote.");
</code></pre>
<p>The else block runs only when the if condition is false.</p>
<h2 id="the-else-if-keyword"><a class="header" href="#the-else-if-keyword">The else if Keyword</a></h2>
<p>Sometimes, you need multiple conditions. Instead of stacking multiple if statements, you can use else if to create a chain:</p>
<pre><code class="language-rs">int age = 16;

if (age &gt;= 65):
    print("You qualify for senior discounts.");
else if (age &gt;= 18):
    print("You can vote but no senior discounts yet!");
else:
    print("You are too young to vote.");
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boolean-operations"><a class="header" href="#boolean-operations">Boolean Operations</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>Boolean operators, such as and, or, and not, combine or modify bool values. They’re useful for creating more complex conditions. Here’s how each works:</p>
<ol>
<li><code>and</code>
Combines two conditions and evaluates to true only if both conditions are true.</li>
</ol>
<pre><code class="language-rs">bool is_adult = true;
bool has_id = false;

if (is_adult and has_id): // Both must be true
    print("You can enter.");
else:
    print("Access denied."); // Output: Access denied.
</code></pre>
<ol start="2">
<li><code>or</code>
Combines two conditions and evaluates to true if at least one condition is true.</li>
</ol>
<pre><code class="language-rs">bool is_vip = true;
bool has_ticket = false;

if (is_vip or has_ticket): // Only one must be true
    print("You can enter."); // Output: You can enter.
</code></pre>
<ol start="3">
<li><code>not</code>
Reverses the value of a bool.</li>
</ol>
<pre><code class="language-rs">bool is_raining = false;

if (not is_raining): // Turns false into true
    print("You don’t need an umbrella!"); // Output: You don’t need an umbrella!
</code></pre>
<h2 id="operator-precedence"><a class="header" href="#operator-precedence">Operator Precedence</a></h2>
<p><code>and</code> has a higher precedence than <code>or</code>, similar to how * has a higher precedence than + in arithmetic. Use parentheses to clarify expressions:</p>
<pre><code class="language-rs">bool condition = true or false and false; // Evaluates to true (and happens first)
bool clarified = (true or false) and false; // Evaluates to false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loops-why-repetition-matters"><a class="header" href="#loops-why-repetition-matters">Loops: Why Repetition Matters</a></h1>
<h2 id="why-loops"><a class="header" href="#why-loops">Why Loops?</a></h2>
<p>Programming often involves repeating tasks. For example, imagine printing every number from 1 to 10—it’s tedious to write print 10 times! Loops automate such repetition.</p>
<h2 id="the-for-loop"><a class="header" href="#the-for-loop">The for Loop</a></h2>
<p>A for loop repeats a block of code for a specific number of iterations.
Here’s the syntax:</p>
<pre><code class="language-rs">for i := 0; i &lt; 10; i++:
    print($"Iteration {i}");
</code></pre>
<p>Here’s what happens:</p>
<ol>
<li><code>i := 0;</code> initializes i to 0.</li>
<li><code>i &lt; 10</code> checks if the condition is true. If not, the loop ends.</li>
<li><code>i++</code> increments i by 1 after each iteration.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enhanced-for-loops"><a class="header" href="#enhanced-for-loops">Enhanced for Loops</a></h1>
<h2 id="why-enhanced-loops"><a class="header" href="#why-enhanced-loops">Why Enhanced Loops?</a></h2>
<p>Enhanced loops are simpler when iterating over collections, like arrays or ranges. They’re especially useful for focusing on elements instead of indices.</p>
<h2 id="heres-the-syntax"><a class="header" href="#heres-the-syntax">Here’s the syntax:</a></h2>
<pre><code class="language-rs">for i, elem in 0..10:
    print($"Index {i}, Value {elem}");
</code></pre>
<p>i is the index (starts at -1).</p>
<p>elem is the current value.</p>
<p>Use enhanced loops when dealing with collections and ranges, but stick to normal loops for more complex conditions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-range-type"><a class="header" href="#the-range-type">The range Type</a></h1>
<h2 id="what-is-a-range"><a class="header" href="#what-is-a-range">What is a range?</a></h2>
<p>A range represents a sequence of numbers. Use it in loops to iterate over specific values.</p>
<pre><code class="language-rs">for i, elem in 5..10:
    print($"Index {i}, Value {elem}");
</code></pre>
<h2 id="output"><a class="header" href="#output">Output:</a></h2>
<blockquote>
<pre><code>Index 0, Value 5
Index 1, Value 6
Index 2, Value 7
Index 3, Value 8
Index 4, Value 9
Index 5, Value 10
</code></pre>
</blockquote>
<h2 id="the-unused-operator-_"><a class="header" href="#the-unused-operator-_">The Unused Operator <code>_</code></a></h2>
<p>Use <code>_</code> to ignore either the index or the element:</p>
<pre><code class="language-rs">for _, elem in 1..5:
    print($"Value {elem}"); // Ignores the index

for i, _ in 1..5:
    print($"Index {i}"); // Ignores the value
</code></pre>
<p>With these tools, you can now make decisions, repeat actions, and handle collections effectively in Flint!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-reusing-code-and-organizing-logic"><a class="header" href="#functions-reusing-code-and-organizing-logic">Functions: Reusing Code and Organizing Logic</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-a-function"><a class="header" href="#what-is-a-function">What is a Function?</a></h1>
<h2 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h2>
<p>A function is a reusable block of code designed to perform a specific task. Functions make programs easier to read, debug, and maintain by encapsulating logic into manageable pieces. Think of a function like a recipe—you can reuse it to "cook" something multiple times without rewriting the steps.</p>
<p>Here’s how you declare a simple function in Flint:</p>
<pre><code class="language-rs">def say_hello():
    print("Hello, world!");
</code></pre>
<p>The function above doesn’t take any arguments or return anything. You define it using the def keyword, followed by the function name and parentheses ().</p>
<h2 id="example-calling-a-function"><a class="header" href="#example-calling-a-function">Example: Calling a Function</a></h2>
<p>Once a function is declared, you can "call" it to execute its logic:</p>
<pre><code class="language-rs">def say_hello():
    print("Hello, world!");

def main():
    say_hello(); // Outputs: Hello, world!
</code></pre>
<h2 id="why-use-functions"><a class="header" href="#why-use-functions">Why Use Functions?</a></h2>
<p>Functions allow you to:</p>
<ul>
<li>Avoid repeating code.</li>
<li>Organize logic into clear, reusable blocks.</li>
<li>Make programs easier to read and debug.</li>
</ul>
<h2 id="hint-for-next-chapter"><a class="header" href="#hint-for-next-chapter">Hint for Next Chapter:</a></h2>
<p>While useful, functions are limited without the ability to take arguments. Imagine a function that prints a personalized greeting—how could you tell the function what name to use? We’ll explore that next.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-arguments"><a class="header" href="#adding-arguments">Adding Arguments</a></h1>
<h2 id="what-are-arguments"><a class="header" href="#what-are-arguments">What Are Arguments?</a></h2>
<p>Arguments are variables passed to a function when it is called. They allow functions to operate on different data, making them far more versatile.</p>
<h2 id="example-a-function-with-one-argument"><a class="header" href="#example-a-function-with-one-argument">Example: A Function with One Argument</a></h2>
<pre><code class="language-rs">def greet(str name):
    print($"Hello, {name}!");
</code></pre>
<p>When calling the function, provide a value for the argument:</p>
<pre><code class="language-rs">def main():
    greet("Alice"); // Outputs: Hello, Alice!
    greet("Bob");   // Outputs: Hello, Bob!
</code></pre>
<h2 id="multiple-arguments"><a class="header" href="#multiple-arguments">Multiple Arguments</a></h2>
<p>Functions can take multiple arguments. Declare the arguments inside the parentheses, separated by commas:</p>
<pre><code class="language-rs">def add_two_numbers(int a, int b):
    print($"The sum is {a + b}.");
</code></pre>
<p>Call the function by providing two values in the correct order:</p>
<pre><code class="language-rs">def main():
    add_two_numbers(5, 7); // Outputs: The sum is 12.
</code></pre>
<h2 id="important-notes"><a class="header" href="#important-notes">Important Notes:</a></h2>
<ol>
<li>The <strong>type</strong> of each argument matters. For example, if <code>a</code> and <code>b</code> are declared as <code>int</code>, you cannot pass <code>str</code> values.</li>
<li>The order of arguments also matters. Always pass values in the same order as declared in the function.</li>
</ol>
<h2 id="whats-next"><a class="header" href="#whats-next">What’s Next?</a></h2>
<p>Arguments let you pass data into functions, but sometimes you want a function to give something back. That’s where return types come in.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="returning-values"><a class="header" href="#returning-values">Returning Values</a></h1>
<h2 id="why-return-values"><a class="header" href="#why-return-values">Why Return Values?</a></h2>
<p>Imagine you want a function to calculate the area of a rectangle. It’s not enough to just print the result—you may need to use the value elsewhere in your program. This is where returning values is essential.</p>
<h2 id="basic-return-example"><a class="header" href="#basic-return-example">Basic Return Example</a></h2>
<p>Declare a return type after the -&gt; symbol in the function header:</p>
<pre><code class="language-rs">def get_greeting() -&gt; str:
    return "Hello, Flint!";
</code></pre>
<p>When the function is called, it <strong>returns</strong> the value to the caller:</p>
<pre><code class="language-rs">def main():
    str greeting = get_geeting();
    print(greeting); // Outputs: Hello, Flint!
</code></pre>
<h2 id="adding-arguments-and-returning-values"><a class="header" href="#adding-arguments-and-returning-values">Adding Arguments and Returning Values</a></h2>
<p>Now let’s combine arguments with a return value:</p>
<pre><code class="language-rs">def add_two_numbers(int a, int b) -&gt; int:
    return a + b;
</code></pre>
<p>You can use the returned value in various ways:</p>
<pre><code class="language-rs">def main():
    int result = add_two_numbers(10, 20);
    print($"The result is {result}."); // Outputs: The result is 30.
</code></pre>
<h2 id="whats-next-1"><a class="header" href="#whats-next-1">What’s Next?</a></h2>
<p>Returning a single value is great, but what if a function needs to return multiple pieces of data? Flint supports this, as we’ll see in the next section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="returning-multiple-values"><a class="header" href="#returning-multiple-values">Returning Multiple Values</a></h1>
<h2 id="why-multiple-return-values"><a class="header" href="#why-multiple-return-values">Why Multiple Return Values?</a></h2>
<p>Sometimes, a single return value isn’t enough. For instance, a function might need to calculate both the area and perimeter of a rectangle. Flint allows functions to return multiple values at once.</p>
<h2 id="how-to-return-multiple-values"><a class="header" href="#how-to-return-multiple-values">How to Return Multiple Values</a></h2>
<p>Use parentheses <code>()</code> to group multiple values in the return statement and also use parentheses for declaring the return types:</p>
<pre><code class="language-rs">def calculate_rectangle(int length, int width) -&gt; (int, int):
    int area = length * width;
    int perimeter = 2 * (length + width);
    return (area, perimeter);
</code></pre>
<h2 id="accessing-multiple-return-values"><a class="header" href="#accessing-multiple-return-values">Accessing Multiple Return Values</a></h2>
<p>When calling a function with multiple return values, use a group to store them:</p>
<pre><code class="language-rs">def main():
    (int area, int perimeter) = calculate_rectangle(5, 3);
    print($"Area: {area}, Perimeter: {perimeter}.");
</code></pre>
<h2 id="output-1"><a class="header" href="#output-1">Output:</a></h2>
<blockquote>
<p>Area: 15, Perimeter: 16.</p>
</blockquote>
<h2 id="important-notes-1"><a class="header" href="#important-notes-1">Important Notes:</a></h2>
<ol>
<li>The types and order of the group must match the function’s return type.</li>
<li>While the concept of "groups" is used here, it will be fully explained in a later chapter.</li>
</ol>
<h2 id="encouragement"><a class="header" href="#encouragement">Encouragement:</a></h2>
<p>You’ve now unlocked the full power of functions in Flint! From organizing logic to handling complex calculations, functions make your programs efficient and reusable. There’s still much to learn, but you’re already building the foundation for advanced concepts.</p>
<p>The journey has just begun—keep experimenting!</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="why-data"><a class="header" href="#why-data">Why Data?</a></h1>
<p>Flint is centered around data, making it the heart of its paradigm, <strong>Data-Object Convergence Paradigm (DOCP)</strong>. In most programming languages, code revolves around objects or functions, but Flint is different—it places data at the center of everything. This design choice influences every aspect of the language.</p>
<h2 id="why-focus-on-data"><a class="header" href="#why-focus-on-data">Why Focus on Data?</a></h2>
<ul>
<li><strong>Data is Everything:</strong> In real-world applications, data is what programs process, transform, and store. Focusing on data makes Flint naturally aligned with the goals of software development.</li>
<li><strong>Simplicity and Modularity:</strong> By emphasizing data structures, Flint avoids complex object hierarchies, instead favoring simple, modular components.
<strong>Best of All Worlds:</strong> Flint borrows strengths from other paradigms. From OOP, it takes the idea of encapsulated entities. From DOP, it inherits performance-centric, data-first design. Flint avoids the pitfalls of these paradigms by focusing on clear, maintainable, and efficient code.</li>
</ul>
<h2 id="why-is-this-a-good-thing"><a class="header" href="#why-is-this-a-good-thing">Why is This a Good Thing?</a></h2>
<p>Flint’s focus on data ensures programs are modular, cache-efficient, and easy to reason about. It reduces unnecessary abstractions while retaining flexibility, making it an ideal language for applications like game development, simulations, and more.</p>
<h2 id="enough-talk"><a class="header" href="#enough-talk">Enough Talk!</a></h2>
<p>Now that you understand why data is so important, let’s dive into creating data structures in Flint. Shall we?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="declaring-data-modules"><a class="header" href="#declaring-data-modules">Declaring Data Modules</a></h1>
<p>To define a new data module in Flint, use the data keyword. A data module consists of fields (the pieces of information it holds) and a constructor (which initializes those fields).</p>
<h2 id="basic-syntax"><a class="header" href="#basic-syntax">Basic Syntax:</a></h2>
<pre><code class="language-rs">data MyData:
    int x;
    int y;
    MyData(x, y);
</code></pre>
<h2 id="what-is-a-constructor"><a class="header" href="#what-is-a-constructor">What is a Constructor?</a></h2>
<p>The constructor is the part of the data declaration that defines how to instantiate the data module. It must include all the fields defined in the data module.</p>
<p><em>Key Points:</em></p>
<ol>
<li>The constructor’s <strong>order</strong> determines how fields are initialized:
<ul>
<li>In the example, x must be assigned first, then y.</li>
</ul>
</li>
<li>The <strong>order of fields</strong> inside the module does not matter but should align with the constructor for clarity.</li>
<li>Constructors are required for all data modules.</li>
</ol>
<h2 id="example-creating-an-instance"><a class="header" href="#example-creating-an-instance">Example: Creating an Instance</a></h2>
<pre><code class="language-rs">def main():
    MyData d = MyData(10, 20);
    print($"d.x: {d.x}, d.y: {d.y}");
    // Outputs: d.x: 10, d.y: 20
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default-values"><a class="header" href="#default-values">Default Values</a></h1>
<p>Sometimes, you may want a field to have a <strong>default value</strong>. In Flint, this is done by assigning a value to the field directly in its declaration.</p>
<h2 id="example-default-values"><a class="header" href="#example-default-values">Example: Default Values</a></h2>
<pre><code class="language-rs">data MyData:
    int x = 5;
    int y;
    MyData(x, y);
</code></pre>
<p>When instantiating this data module, you can use <code>_</code> to signify using the default value for a field:</p>
<pre><code class="language-rs">def main():
    MyData d = MyData(_, 20); // x uses the default value of 5
    print($"d.x: {d.x}, d.y: {d.y}");
    // Outputs: d.x: 5, d.y: 20
</code></pre>
<h2 id="key-notes"><a class="header" href="#key-notes">Key Notes:</a></h2>
<ol>
<li>Default values simplify initialization but are optional.</li>
<li>If a field doesn’t have a default value, using <code>_</code> will result in a <strong>compiler error</strong>:</li>
</ol>
<pre><code>MyData d = MyData(_, _); // Error: y has no default value
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nested-data"><a class="header" href="#nested-data">Nested Data</a></h1>
<p>Data modules can include other data modules as fields. This allows you to create nested structures, which are common in real-world programming.</p>
<h2 id="example-nested-data"><a class="header" href="#example-nested-data">Example: Nested Data</a></h2>
<pre><code class="language-rs">data Point:
    int x;
    int y;
    Point(x, y);

data Rectangle:
    Point top_left;
    Point bottom_right;
    Rectangle(top_left, bottom_right);
</code></pre>
<h2 id="usage"><a class="header" href="#usage">Usage:</a></h2>
<pre><code class="language-rs">def main():
    Point p1 = Point(0, 0);
    Point p2 = Point(10, 10);
    Rectangle rect = Rectangle(p1, p2);
    print($"rect.topLeft.x: {rect.topLeft.x}");
    // Outputs: rect.topLeft.x: 0
</code></pre>
<h2 id="circular-references"><a class="header" href="#circular-references">Circular References?</a></h2>
<p>Flint does not allow a data module to reference itself directly or indirectly like showcased below:</p>
<pre><code class="language-rs">data Node:
    int value;
    Node next;
    Node(value, next);
</code></pre>
<p>While this may seem restrictive, it prevents issues like infinite recursion or memory management problems. The explicit explaination of to why this is not directly possible will be explained in a later chapter. For now, focus on the fact that it is not possible.</p>
<h2 id="hint"><a class="header" href="#hint">Hint:</a></h2>
<p>Flint can handle circular references with the help of the <strong>optional type (<code>Opt</code>)</strong>. These convert a reference to a wek reference in circular context's, thus enabling the use of data in of itself, for example for <strong>linked lists</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-data-in-functions"><a class="header" href="#using-data-in-functions">Using Data in Functions</a></h1>
<p>Data modules can be passed to and returned from functions, enabling you to manipulate them easily.</p>
<h2 id="example-passing-data-to-functions"><a class="header" href="#example-passing-data-to-functions">Example: Passing Data to Functions</a></h2>
<pre><code class="language-rs">def print_point(Point p):
    print($"Point(x: {p.x}, y: {p.y})");

def main():
    Point p = Point(3, 4);
    print_point(p); // Outputs: Point(x: 3, y: 4)
</code></pre>
<h2 id="example-returning-data-from-functions"><a class="header" href="#example-returning-data-from-functions">Example: Returning Data from Functions</a></h2>
<pre><code class="language-rs">def create_point(int x, int y) -&gt; Point:
    return Point(x, y);

def main():
    Point p = create_point(5, 7);
    print($"Created Point: x={p.x}, y={p.y}");
</code></pre>
<p>By using functions with data, you can create and manipulate complex structures easily.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Data modules are the foundation of Flint’s design, allowing you to create, structure, and manage information effectively. From default values to nested structures, they provide a flexible yet powerful way to organize your program’s core logic. You’ve taken your first step into Flint’s data-centric world—congratulations!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays-organizing-data-sequentially"><a class="header" href="#arrays-organizing-data-sequentially">Arrays: Organizing Data Sequentially</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-arrays"><a class="header" href="#introduction-to-arrays">Introduction to Arrays</a></h1>
<p>An <strong>array</strong> is a data structure that stores a collection of elements sequentially in memory. Arrays are useful for storing multiple values of the same type, such as numbers, strings, or even custom data modules. In Flint, arrays are <strong>immutable by default</strong> in terms of references—assigning one array to another always creates a <strong>copy</strong>, not a reference.</p>
<h2 id="key-points-about-flint-arrays"><a class="header" href="#key-points-about-flint-arrays">Key Points About Flint Arrays</a></h2>
<ol>
<li>Arrays are always <strong>stored sequentially</strong> in memory, making access to their elements efficient.</li>
<li>Arrays are <strong>value types</strong> in Flint. This means copying an array creates a <strong>new, independent copy</strong> of its data.</li>
<li>If you modify an array inside a data object, you should <strong>access it directly</strong> using data.array instead of copying it out, as changes made to the copy won’t automatically reflect back in the original array.</li>
</ol>
<h2 id="creating-and-accessing-arrays"><a class="header" href="#creating-and-accessing-arrays">Creating and Accessing Arrays</a></h2>
<p>To declare a one-dimensional array, use the following syntax:</p>
<pre><code class="language-rs">int[] arr; // Declare an uninitialized array
arr = int[5]; // Create an array with 5 elements initialized to the default value (0)
</code></pre>
<p>To assign values to specific elements or access them:</p>
<pre><code class="language-rs">arr[0] = 10; // Set the first element to 10
int val = arr[0]; // Access the first element
</code></pre>
<h2 id="example-using-arrays-in-flint"><a class="header" href="#example-using-arrays-in-flint">Example: Using Arrays in Flint</a></h2>
<pre><code class="language-rs">def main():
    int[] arr = int[5]; // Create a 1D array of size 5
    arr[0] = 10;
    arr[1] = 20;
    print($"arr[0]: {arr[0]}, arr[1]: {arr[1]}");
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterating-over-arrays"><a class="header" href="#iterating-over-arrays">Iterating Over Arrays</a></h1>
<p>Often, you’ll want to process each element of an array. Flint supports <strong>two types of loops</strong> for working with arrays:</p>
<ol>
<li><strong>Index-Based Loops</strong>: Ideal for accessing and modifying elements at specific indices.</li>
<li><strong>Enhanced For Loops</strong>: Useful for iterating over all elements with simpler syntax.</li>
</ol>
<h2 id="using-the-index-based-loop"><a class="header" href="#using-the-index-based-loop">Using the Index-Based Loop</a></h2>
<pre><code class="language-rs">def main():
    // Initialize array of size 5 with values of 4
    arr := int[5](4);
    // Set each element to the double of the index
    for i := 0; i &lt; 5; i++:
        arr[i] = i * 2;
    print($"arr[3]: {arr[3]}"); // prints 'arr[3]: 6'
</code></pre>
<h2 id="using-the-enhanced-for-loop"><a class="header" href="#using-the-enhanced-for-loop">Using the Enhanced For Loop</a></h2>
<p>In enhanced for loops, you can access both the index (i) and the element (elem), as learned in chapter <a href="beginners_guide/7_arrays/2_iterating_over_arrays.html#4">4</a>:</p>
<pre><code class="language-rs">def main():
    int[] arr = int[5](6); // Initialize array
    for i, elem in arr:
        print($"Index: {i}, Value: {elem}");
</code></pre>
<p>Output:</p>
<blockquote>
<pre><code>Index: 0, Value: 6
Index: 1, Value: 6
Index: 2, Value: 6
Index: 3, Value: 6
Index: 4, Value: 6
</code></pre>
</blockquote>
<h2 id="iterables-in-flint"><a class="header" href="#iterables-in-flint">Iterables in Flint</a></h2>
<p>Flint arrays are <strong>iterable</strong>, meaning they can be used in enhanced for loops. Other iterables include <strong>ranges</strong>, which we’ll discuss later. Remember: the choice of loop depends on whether you need access to indices (<code>i</code>) or also elements (<code>elem</code>).</p>
<p><strong>Hint</strong>: The type of the indices (<code>i</code>) is <em>always</em> of type <em>uint</em> (no signed int values) and the type of the elements (<code>elem</code>) is <em>always</em> the type of the array elements. If you create a <code>str</code> array (<code>str[]</code>), for example, <code>elem</code> will be of type <code>str</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multidimensional-arrays"><a class="header" href="#multidimensional-arrays">Multidimensional Arrays</a></h1>
<p>Flint supports <strong>multidimensional arrays</strong>. In flint, these are <strong>always rectangle arrays</strong>, meaning that the length of each dimension is locked, unlike <em>jagged arrays</em>, which behave more like "array of arrays". Arrays are particularly useful for storing grid-like data, such as images or matrices.</p>
<h2 id="declaring-multidimensional-arrays"><a class="header" href="#declaring-multidimensional-arrays">Declaring Multidimensional Arrays</a></h2>
<p>The number of commas (<code>[,]</code>) in the declaration indicates the number of dimensions:</p>
<pre><code class="language-rs">int[,] arr; // 2D array
int[,,] cube; // 3D array
</code></pre>
<h2 id="initializing-multidimensional-arrays"><a class="header" href="#initializing-multidimensional-arrays">Initializing Multidimensional Arrays</a></h2>
<p>To initialize a multidimensional array:</p>
<ol>
<li><strong>Using Defaults</strong>:</li>
</ol>
<pre><code class="language-rs">int[,] arr = int[5, 5]; // 5x5 array with default value (0)
</code></pre>
<ol start="2">
<li><strong>Using a Specific Value</strong>:</li>
</ol>
<pre><code class="language-rs">arr := int[5, 5](4); // 5x5 array with all values set to 4
</code></pre>
<h2 id="accessing-multidimensional-arrays"><a class="header" href="#accessing-multidimensional-arrays">Accessing Multidimensional Arrays</a></h2>
<p>Use indices for each dimension:</p>
<pre><code class="language-rs">arr[1, 2] = 10; // Set the element at row 1, column 2
print(arr[1, 2]); // Access the element
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="access-patterns-with-ranges"><a class="header" href="#access-patterns-with-ranges">Access Patterns with Ranges</a></h1>
<p>Ranges allow you to <strong>access segments</strong> of an array or extract slices. This is especially powerful for creating subsets of arrays.</p>
<h2 id="using-ranges"><a class="header" href="#using-ranges">Using Ranges</a></h2>
<ul>
<li><strong>Closed Ranges</strong>: Specify a start and end (both inclusive).</li>
</ul>
<pre><code class="language-rs">int[] slice = arr[2..4]; // Elements from index 2 to 4 (inclusive)
</code></pre>
<ul>
<li><strong>One-Sided Ranges</strong>: Leave one side open to indicate "to the start" or "to the end."</li>
</ul>
<pre><code class="language-rs">int[] slice = arr[3..]; // All elements from index 3 to the end
int[] slice = arr[..2]; // All elements from the start to index 2
</code></pre>
<ul>
<li><strong>Open Ranges</strong>: Open on both sides, indicating <strong>all elements</strong>.</li>
</ul>
<pre><code class="language-rs">int[] slice = arr[..]; // Equivalent to copying the whole array
</code></pre>
<h2 id="extracted-slices-are-copies"><a class="header" href="#extracted-slices-are-copies">Extracted Slices are Copies</a></h2>
<p>When using ranges, Flint always creates a <strong>new array</strong> as a copy of the slice.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multidimensional-access-patterns"><a class="header" href="#multidimensional-access-patterns">Multidimensional Access Patterns</a></h1>
<p>Flint allows using ranges in <strong>multidimensional arrays</strong>, letting you extract slices easily. Fixed indices reduce the dimensionality of the result.</p>
<h2 id="examples"><a class="header" href="#examples">Examples:</a></h2>
<ol>
<li><strong>Extracting a Row</strong>:</li>
</ol>
<pre><code class="language-rs">int[] row = arr[2, ..]; // All elements in row 2
</code></pre>
<ol start="2">
<li><strong>Extracting a Column</strong>:</li>
</ol>
<pre><code class="language-rs">int[] column = arr[.., 3]; // All elements in column 3
</code></pre>
<ol start="3">
<li><strong>Extracting a Plane</strong>:</li>
</ol>
<pre><code class="language-rs">int[,] plane = cube[.., 2, ..]; // A 2D plane from a 3D array
// This returns a 2d array of all x and z values on index 2
</code></pre>
<h2 id="resulting-dimensionality"><a class="header" href="#resulting-dimensionality">Resulting Dimensionality:</a></h2>
<ol>
<li>Fixing one dimension reduces the result by 1 dimension.</li>
<li>Fixing all dimensions results in a <strong>single value</strong>:</li>
</ol>
<pre><code class="language-rs">int value = cube[1, 2, 3]; // Single value at [1, 2, 3]
</code></pre>
<h2 id="practical-example-transposing-a-matrix"><a class="header" href="#practical-example-transposing-a-matrix">Practical Example: Transposing a Matrix</a></h2>
<pre><code class="language-rs">// Transposing using range accessing
def transpose(int[,] matrix) -&gt; int[,]:
    new_matrix := int[matrix[0, ..].length, matrix.length];
    for y := 0; y &lt; matrix[0, *].length; y++:
        new_matrix[*, y] = matrix[y, *];
    return new_matrix;

// Transposing manually
def transpose(int[,] matrix) -&gt; int[,]:
    /**
    The range operator has to be used here because there actually is no other way to
    find the length of the second dimension
    */
    new_matrix := int[matrix[0, ..].length, matrix.length];
    for x := 0; x &lt; matrix.length; x++:
        for y := 0; y &lt; matrix[0, ..].length; y++:
            new_matrix[y, x] = matrix[x, y];
    return new_matrix;
</code></pre>
<p>The slicing operation is not only cleaner for arrays, but it is more performant too, because multiple pieces of data can be copied simultaniously, whereas with manual indexing, each value is copied 1 by 1.</p>
<h2 id="arrays-in-loops"><a class="header" href="#arrays-in-loops">Arrays in Loops</a></h2>
<p>Using ranges and slices in loops is incredibly powerful:</p>
<pre><code class="language-rs">for i, elem in arr[2..4]:
    print($"Index: {i}, Value: {elem}");
</code></pre>
<h2 id="concurrency-and-arrays"><a class="header" href="#concurrency-and-arrays">Concurrency and Arrays</a></h2>
<p>Flint’s range and array access patterns set the foundation for concurrent computations, enabling high performance. We’ll dive deeper into Flint’s concurrency model in later chapters.</p>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>Arrays are a core part of programming in Flint, allowing you to store and manipulate sequential data efficiently. From basic one-dimensional arrays to advanced multidimensional access patterns, Flint’s array system is powerful and intuitive. With this foundation, you’re ready to explore Flint’s entities, which bring even more flexibility to your data-centric applications. Let’s continue!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entities-organizing-behavior-and-data"><a class="header" href="#entities-organizing-behavior-and-data">Entities: Organizing Behavior and Data</a></h1>
<p>Entities in Flint are central to its philosophy of combining <strong>data</strong> and <strong>behavior</strong> in a modular and flexible way. They are similar to classes in object-oriented languages but follow Flint’s <strong>Data-Object Convergence Paradigm (DOCP)</strong>. Entities consist of <strong>data modules</strong> to store information and <strong>func modules</strong> to define behavior, providing a balance of structure and modularity.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monolithic-entities-the-basics"><a class="header" href="#monolithic-entities-the-basics">Monolithic Entities: The Basics</a></h1>
<p>The simplest form of an entity in Flint is a <strong>monolithic entity</strong>, where data and functionality are defined together in one place.</p>
<h2 id="example"><a class="header" href="#example">Example:</a></h2>
<pre><code class="language-rs">entity Counter:
    data:
        int value;

    func:
        def increment(int amount):
            value += amount;

        def get_value() -&gt; int:
            return value;

    Counter(value); // Constructor to initialize the entity
</code></pre>
<h2 id="key-points"><a class="header" href="#key-points">Key Points:</a></h2>
<ol>
<li><strong>Structure:</strong> Entities have two main sections:
<ul>
<li><strong>Data:</strong> Variables that store the state of the entity.</li>
<li><strong>Func:</strong> Functions that operate on the data.</li>
</ul>
</li>
<li><strong>Constructor:</strong> The constructor initializes the entity. Its parameters must match the declared fields in the <code>data</code> section.</li>
<li><strong>Use Case:</strong> Monolithic entities are straightforward and perfect for small projects or tightly coupled logic.</li>
<li><strong>Immutability:</strong> The data saved inside an entity cannot be accessed outside of func modules. So, when Entity <code>E</code> uses a func module which acts on data <code>D</code> the data of <code>D</code> cannot be accessed via an instance of <code>E</code>. This means that <code>e.value</code> is impossible. For all operations on data, getters and setters must be provided inside the <code>func</code> module.</li>
</ol>
<h2 id="usage-example"><a class="header" href="#usage-example">Usage Example:</a></h2>
<pre><code class="language-rs">def main():
    Counter counter = Counter(0);
    counter.increment(5);
    print($"Counter value: {counter.value}");
    counter.reset();
    print($"Counter value after reset: {counter.value}");
</code></pre>
<p>Monolithic entities are Flint’s simplest abstraction, but their true power emerges as we explore <strong>func modules</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-modules-modularizing-behavior"><a class="header" href="#func-modules-modularizing-behavior">Func Modules: Modularizing Behavior</a></h1>
<p>Func modules separate <strong>behavior</strong> from entities, making Flint entities highly modular. They <strong>act upon data</strong> and can be reused across multiple entities. A func module defines functionality independently of a specific entity.</p>
<h2 id="syntax-recap"><a class="header" href="#syntax-recap">Syntax Recap:</a></h2>
<pre><code class="language-rs">data CounterData:
    int value = 0;
    CounterData(value);

func CounterActions requires(CounterData c);
    def increment(int amount):
        c.value += amount;

    def get_value() -&gt; int:
        return c.value;
</code></pre>
<h2 id="key-points-1"><a class="header" href="#key-points-1">Key Points:</a></h2>
<ol>
<li><strong>Requires Keyword:</strong> The <code>requires</code> keyword specifies the data module(s) this func module operates on. In this case, it requires a data module of type <code>Counter</code>. This data module has to be present on every entity that uses the <code>CounterActions</code> func module.</li>
<li><strong>Reusability:</strong> A single func module can be shared across multiple entities that use compatible data structures.</li>
<li><strong>Immutability:</strong> Just like with monolithic entities, the data saved inside an entity cannot be accessed outside of func modules. So, when Entity <code>E</code> uses a func module which acts on data <code>D</code> the data of <code>D</code> cannot be accessed via an instance of <code>E</code>. This means that <code>e.value</code> is impossible. For all operations on data, getters and setters must be provided inside the <code>func</code> module.</li>
</ol>
<p>By separating behavior from data, Flint encourages <strong>reuse</strong> and <strong>cleaner code</strong>. But how do these fit into entities?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-monolithic-to-modular-entities"><a class="header" href="#from-monolithic-to-modular-entities">From Monolithic to Modular Entities</a></h1>
<p>A <strong>monolithic entity</strong> can be split into <strong>data</strong> and <strong>func modules</strong>, improving modularity and reusability.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example:</a></h2>
<pre><code class="language-rs">data CounterData:
    int value;
    CounterData(value);

func CounterActions requires(CounterData c):
    def increment(int amount):
        c.value += amount;

    def get_value() -&gt; int:
        return c.value;

entity Counter:
    data:
        CounterData;
    func:
        CounterActions;
    Counter(CounterData);

def main():
    Counter c = Counter(0);
    c.increment(5);
    print(c.get_value());
</code></pre>
<h2 id="key-points-2"><a class="header" href="#key-points-2">Key Points:</a></h2>
<ol>
<li><strong>Splitting Structure:</strong> Data and behavior are now split into distinct modules, improving maintainability and reducing duplication.</li>
<li><strong>Cleaner Logic:</strong> You can focus on either the data or behavior separately when extending or debugging the entity.</li>
</ol>
<p>This separation shines when working with <strong>complex entities</strong>.</p>
<h2 id="additional-information"><a class="header" href="#additional-information">Additional Information:</a></h2>
<p>When creating and using monolithic entities, the compiler inherently creates <code>data</code> and <code>func</code> modules for that entity. It keeps modular. The <code>Counter</code> example from chapter 8.1:</p>
<pre><code class="language-rs">entity Counter:
    data:
        int value;

    func:
        def increment(int amount):
            value += amount;

        def get_value() -&gt; int:
            return value;

    Counter(value); // Constructor to initialize the entity
``

will be converted by the compiler to this structure:

```rs
data DCounter:
    int value;
    DCounter(value);

func FCounter requires(DCounter d):
    def increment(int amount):
        d.value += amount;

    def get_value() -&gt; int:
        return d.value;

entity Counter:
    data:
        DCounter;
    func:
        FCounter;
    Counter(DCounter);
</code></pre>
<p>This means that monolithic entites are being modularized internally. So there is no difference performance-wise when using very small monolithic or modular entities. However, as the entity becomes bigger and bigger, the performance gains from using modular entites become increasingly bigger.</p>
<p>So, when using very small entites or for <strong>quick prototyping</strong>, creating monolithic entites can be beneficial. But for bigger entities, please use the modular design.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-multiple-data-and-func-modules"><a class="header" href="#using-multiple-data-and-func-modules">Using Multiple Data and Func Modules</a></h1>
<p>Entities can incorporate multiple <strong>data modules</strong> and <strong>func modules</strong>, making them powerful abstractions for complex systems.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example:</a></h2>
<pre><code class="language-rs">data Position:
    int x;
    int y;
    Position(x, y);

data Velocity:
    int dx;
    int dy;
    Velocity(dx, dy);

func MovementActions requires(Position p, Velocity v):
    def move():
        p.x += v.dx;
        p.y += v.dy;

entity MovingObject:
    data:
        Position, Velocity;
    func:
        MovementActions;
    MovingObject(Position, Velocity);
</code></pre>
<h2 id="key-points-3"><a class="header" href="#key-points-3">Key Points:</a></h2>
<ol>
<li><strong>Combining Data:</strong> Entities can hold multiple data modules, each serving a specific purpose.</li>
<li><strong>Behavior Composition:</strong> Multiple func modules can act on the same data or different data modules within the entity.</li>
</ol>
<p>This modular design fosters <strong>collaboration</strong>, where one developer can work on movement while another focuses on graphics.</p>
<p>It is generally not recommended to make any func dependant on many different data modules. The more dependent every func is on multiple different data modules, the less modular the whole system becomes. This would mean that the advantage <strong>DOCP</strong> has over <strong>OOP</strong> would diminish. It is not easy to keep function and data as modular as possible, but <strong>link</strong> help with that. Links are described in the next chapter and they greatly increase the possibilities of DOCP.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introducing-links"><a class="header" href="#introducing-links">Introducing Links</a></h1>
<p>Links allow you to <strong>connect func modules</strong>, enabling communication and coordination. This is achieved using the <code>#linked</code> flag and the <code>-&gt;</code> operator in the <code>link:</code> section of the entity.</p>
<h2 id="syntax-recap-1"><a class="header" href="#syntax-recap-1">Syntax Recap:</a></h2>
<pre><code class="language-rs">// POSITION MODULES
data Position:
    int x;
    int y;
    Position(x, y);

func PositionUtils requires(Position p):
    def move():
        (dx, dy) := get_velocity();
        p.x += dx;
        p.y += dy;

    def get_position() -&gt; (int, int):
        return (p.x, p.y);

    #linked
    def get_velocity() -&gt; (int, int);
</code></pre>
<pre><code class="language-rs">// VELOCITY MODULES
data Velocity:
    int dx;
    int dy;
    Velocity(dx, dy);

func VelocityUtils requires(Veclocity v):
    #linked
    def get_velocity() -&gt; (int, int):
        return (v.dx, v.dy);
</code></pre>
<pre><code class="language-rs">// MAIN ENTITY
entity MovingObject:
    data:
        Position, Velocity;
    func:
        PositionUtils, VelocityUtils;
    link:
        PositionUtils::get_velocity -&gt; VelocityUtils::get_velocity;
    MovingObject(Position, Velocity);

def main():
    obj := MovingObject(10, 7, -2, 2);
    print(obj.get_position()); // prints '(10, 7)'
    obj.move();
    print(obj.get_position()); // prints '(8, 9)'
</code></pre>
<h2 id="key-points-4"><a class="header" href="#key-points-4">Key Points:</a></h2>
<ol>
<li><strong>Linked Functions:</strong> Functions marked with <code>#linked</code> must be linked in the <code>link:</code> section of the entity.</li>
<li><strong>Compilation Behavior:</strong> If multiple functions are linked, only the <strong>end-point</strong> function is included in the compiled program.</li>
<li><strong>Forced Override:</strong> When multiple functions with the same name and the same signature coexist in multiple func modules, they have to be linked together. The function at the end of the linking chain will be executed.</li>
<li><strong>Flags Required:</strong> Each function that is linked has to be marked with the <code>#linked</code> flag.</li>
</ol>
<p>Links enable powerful abstractions and create <strong>cohesion</strong> across entities while keeping their implementations <strong>decoupled</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extending-entities"><a class="header" href="#extending-entities">Extending Entities</a></h1>
<p>The <code>extends</code> keyword allows you to create new entities that build upon existing ones. This is similar to inheritance in object-oriented programming.</p>
<h2 id="syntax-recap-2"><a class="header" href="#syntax-recap-2">Syntax Recap:</a></h2>
<pre><code class="language-rs">entity Movement:
    data:
        int x_pos = 0;
        int y_pos = 0;
        int x_vel = 0;
        int y_vel = 0;
    func:
        def move():
            x_pos += x_vel;
            y_pos += y_vel;
    Movement(x_pos, y_pos, x_vel, y_vel);

entity Player extends(Movement mv):
    data:
        int health = 100;
        int damage = 10;
    func:
        def recieve_damage(int amount):
            health -= amount;
    Player(mv, health, damage);

def main():
    mv := Movement(10, 10, 1, 2);
    player := Player(mv, 100, 10);
    player.move(); // Calling the function inherited by the Movement entity;
</code></pre>
<h2 id="key-points-5"><a class="header" href="#key-points-5">Key Points:</a></h2>
<ol>
<li><strong>Data and Func Inheritance:</strong> The new entity inherits all <code>data</code>, <code>func</code> and <code>link</code> modules from the parent entities.</li>
<li><strong>Extending Behavior:</strong> Additional functionality can be added without modifying the original entity.</li>
</ol>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p>Entities are Flint’s way of organizing and structuring both data and behavior. From <strong>monolithic entities</strong> to modular data and func modules, extending entities, and linking behavior, Flint entities provide the <strong>flexibility</strong> and <strong>power</strong> needed for modern, scalable applications.</p>
<p>Extending entities simplifies code reuse while keeping functionality <strong>modular</strong>. Together with the ability to link functions, a structure similar to "classic" OOP emerges, but the data is strictly separated, just like functions. Allthough links are very powerful, they can introduce headaches in concurrent environments. Use them with caution! As long as you use them in a <strong>readonly</strong> way (making a <em>dummy</em> function in the current func and linking it to the function in the <em>func</em> module which has access to the data, and only making it <strong>read</strong> the data, but never <strong>write</strong> it), you should see minimal to no problem with concurrency, which is talked about in the next chapter.</p>
<p>Up next: <strong>Concurrency</strong>, where we explore Flint’s capabilities for high-performance, parallel computing!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h1>
<p>Entities are Flint’s way of organizing and structuring both data and behavior. From <strong>monolithic entities</strong> to modular data and func modules, extending entities, and linking behavior, Flint entities provide the <strong>flexibility</strong> and <strong>power</strong> needed for modern, scalable applications. Up next: <strong>Concurrency</strong>, where we explore Flint’s capabilities for high-performance, parallel computing!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-concurrency"><a class="header" href="#understanding-concurrency">Understanding Concurrency</a></h1>
<p><strong>Concurrency</strong> is the ability of a program to execute multiple tasks simultaneously, either by distributing them across multiple CPU cores or interleaving their execution on a single core. This capability has become critical in modern computing as CPUs have evolved from single-core processors to multi-core architectures.</p>
<h3 id="why-concurrency"><a class="header" href="#why-concurrency">Why Concurrency?</a></h3>
<ul>
<li><strong>Performance Boost:</strong> By distributing tasks across cores, programs can complete faster.</li>
<li><strong>Efficiency:</strong> Modern processors are optimized for parallelism; concurrency allows you to use their full potential.</li>
<li><strong>Responsiveness:</strong> In applications like games or GUIs, concurrency enables smooth user interactions while background tasks run.</li>
</ul>
<h3 id="challenges-of-concurrency"><a class="header" href="#challenges-of-concurrency">Challenges of Concurrency</a></h3>
<p>Concurrency isn’t without its challenges. Some of the common pitfalls include:</p>
<ol>
<li><strong>Race Conditions:</strong> When two or more threads access and modify the same data simultaneously, unexpected behavior can occur.</li>
<li><strong>Deadlocks:</strong> When threads wait on each other indefinitely, halting progress.</li>
<li><strong>Complexity:</strong> Managing threads and ensuring proper synchronization often leads to intricate, error-prone code.</li>
</ol>
<h3 id="how-flint-simplifies-concurrency"><a class="header" href="#how-flint-simplifies-concurrency">How Flint Simplifies Concurrency</a></h3>
<p>Flint’s design philosophy eliminates many of these issues:</p>
<ul>
<li><strong>Data-Centric Approach:</strong> By separating data and behavior, Flint ensures that each entity has its own data, avoiding race conditions by default.</li>
<li><strong>Built-in Tools:</strong> Flint provides high-level abstractions for common concurrency patterns, allowing you to focus on your logic without worrying about low-level thread management.</li>
</ul>
<p>While Flint makes concurrency easier, understanding the core principles ensures you can use it effectively.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flints-concurrency-features"><a class="header" href="#flints-concurrency-features">Flint's Concurrency Features</a></h1>
<p>Flint offers several built-in tools for concurrency, with <code>run_on_all</code> being a standout feature. These tools abstract away the complexity of managing threads, making Flint one of the easiest languages to adopt for concurrent programming.</p>
<h3 id="run_on_all-the-basics"><a class="header" href="#run_on_all-the-basics"><code>run_on_all</code>: The Basics</a></h3>
<p>The <code>run_on_all</code> function distributes a task across all elements of an iterable or entities in a collection, running each task concurrently.</p>
<p>Syntax:</p>
<pre><code>run_on_all(FUNC_OR_ENTITY_TYPE, FUNCTION_REFERENCE, [COLLECTION]);
</code></pre>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<p>When an entity type is provided for the <strong>FUNC_OR_ENTITY_TYPE</strong>, the function given in the <strong>FUNCTION_REFERENCE</strong> will be executed on <strong>all</strong> entites of this type. This method is overloaded with another method, having one additional argument, the <strong>COLLECTION</strong>. A collection can be an array of entites or funcs, or a list of them.</p>
<h2 id="example-3"><a class="header" href="#example-3">Example:</a></h2>
<pre><code class="language-rs">entity SomeEntity:
    data:
        int value;
    func:
        def increment_value(int amount):
            value += amount;
    SomeEntity(value);

def main():
    arr1 := SomeEntity[100](SomeEntity(15));
    arr2 := SomeEntity[50](SomeEntity(25));

    // Increments the value of **ALL** existing entities of this type
    // This includes all entities from 'arr1' as well as all from 'arr2'
    run_on_all(SomeEntity, SomeEntity::increase_value(3));

    // Increments the value of all entities in 'arr1'
    run_on_all(SomeEntity, SomeEntity::increase_value(5), arr1);
</code></pre>
<p>Something important: A <strong>function reference</strong> is made via the <code>::</code> symbols (double colon). Because Flint differentiates between function calls with <code>.</code> and function references with <code>::</code>, the value with which the function is referenced can be bound to the function reference exaclty like a normal function call, instead of using <code>.bind(...)</code> or something similar to it. This greatly imroves the ease of use for function references.</p>
<h2 id="other-concurrency-functions"><a class="header" href="#other-concurrency-functions">Other Concurrency Functions</a></h2>
<p>Flint provides additional concurrency functions, including:</p>
<ul>
<li><strong><code>map_on_all(FUNC_OR_ENTITY_TYPE, FUNCTION_REFERENCE, [COLLECTION]) -&gt; List&lt;ResultType&gt;</code>:</strong> Similar to the <code>map</code> function in other languages, <code>map_on_all</code> would run a specified function across <strong>all</strong> or <strong>some</strong> entities, depending if the collection argument is passed in or not. It collects all the results of the function in a new <code>List</code>. Here an example:</li>
</ul>
<pre><code class="language-rs">// Assuming that 'increase_value' returns the new value as an 'int'
List&lt;int&gt; results = map_on_all(SomeEntity, SomeEntity::increase_value(5));
</code></pre>
<ul>
<li><strong><code>filter_on_all(FUNC_OR_ENTITY_TYPE, FUNCTION_REFERENCE, [COLLECTION]) -&gt; List&lt;EntityType&gt;</code>:</strong> Similar to the <code>filter</code> function in other languages, <code>filter_on_all</code> executes a given predicate function and returns a list of all entities or funcs, where the predicate function resolved to true. Here an example:</li>
</ul>
<pre><code class="language-rs">// Assuming that the 'is_value_above' function exists and returns a 'bool'
List&lt;SomeEntity&gt; filtered = filter_on_all(SomeEntity, SomeEntity::is_value_above(5));
// This filtered list then can be used in other concurrent functions as well
// Concurrent functions are inherently modular and can be chained together to create powerful commands
run_on_all(SomeEntity, SomeEntity::decrease_value(5), filtered);
</code></pre>
<p>There exist several more concurrent functions, such as <code>reduce_on_all</code>, <code>reduce_on_pairs</code> or <code>partition_on_all</code>. Now that you understand how they work and how to use them, explore them by yourself!</p>
<!-->
<ul>
<li><strong><code>run_in_parallel(func1, func2, ...)</code>:</strong> Runs multiple independent functions concurrently.</li>
<li><strong><code>run_with_limit(func, collection, limit)</code>:</strong> Similar to <code>run_on_all</code>, but limits the number of concurrent tasks.</li>
<li><strong><code>run_once(func)</code>:</strong> Ensures a function runs exactly once, even in concurrent contexts.
&lt;--&gt;</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shared-data"><a class="header" href="#shared-data">Shared Data</a></h1>
<p>While Flint’s design prevents race conditions by default, there are cases where <strong>data sharing</strong> between entities or threads is necessary. For these situations, Flint introduces <strong>shared data</strong>.</p>
<h2 id="what-is-shared-data"><a class="header" href="#what-is-shared-data">What is Shared Data?</a></h2>
<p>Shared data is a special type of data module designed to be accessed by multiple threads or entities concurrently. Unlike regular data, shared data resides in the <strong>Heap</strong>, and Flint enforces synchronization to ensure safe access.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax:</a></h2>
<pre><code class="language-rs">shared data SharedCounter:
    int value = 1;
</code></pre>
<p>As you may notice, <strong>shared data</strong> does not have a constructor. Why is that? Well, because it only exists <strong>once</strong> in the whole program. This also means that shared data cannot be initialized and used inside a variable. Its main purpose is to <strong>connect</strong> multiple entities, maybe of differnt type, where everyone of these entities can access and modify the data in a thread-safe way without much headache.</p>
<p><strong>Imporant:</strong> Every field inside a shared data module <strong>must</strong> have default values set. This is because the module gets created with the programs startup.</p>
<p>Shared data houses mutex-checks by default, meaning that only a single thread can access the data at a time. The nice thing about shared data is, that inside this data module, more complex data types than only primitive types can be created too. This is because shared data cannot be initialized, and because a shared bit was introduced in DIMA (Dynamic Incremental Memory Allocation) (Flints memory management tool) (but you will learn more about it some time later).</p>
<h2 id="accessing-shared-data"><a class="header" href="#accessing-shared-data">Accessing Shared Data</a></h2>
<h2 id="when-to-use-shared-data"><a class="header" href="#when-to-use-shared-data">When to Use Shared Data</a></h2>
<ul>
<li><strong>Global State:</strong> For variables that must be shared across multiple entities or functions.</li>
<li><strong>Coordination:</strong> When threads need to communicate through shared variables.</li>
</ul>
<h2 id="example-4"><a class="header" href="#example-4">Example:</a></h2>
<pre><code class="language-rs">shared data PlayerScore:
    int highscore = 0;

// The PlayerScore p here is not an instance from but only a reference to the data module
func ScoreUtils requires(PlayerScore p):
    def set_highscore(int score):
        p.highscore = score;

    def get_highscore() -&gt; int:
        return p.highscore;

entity ScoreManager:
    data: PlayerScore;
    func: ScoreUtils;
    // The PlayerScore is not allowed nor needed inside the constructor
    // because it is shared
    ScoreManager();

entity Player extends(ScoreManager m):
    data:
        HealthData;
    func:
        HealthUtils;
    // The ScoreManager does not have to be listed here because its constructor is empty
    Player(HealthData);

def main():
    // initializes a player with 100 health
    player := Player(100);
    print(player.get_highscore()); // prints '0'
    player.set_highscore(100));
    // because the ScoreManager is a regular entity, it can be instantiated too!
    manager := ScoreManager();
    print(manager.get_highscore()); // prints '100'
    manager.set_highscore(50);

    print(player.get_highscore()); // prints '50'
</code></pre>
<p>By default, Flint minimizes the need for shared data, promoting safer designs. Use shared data only when absolutely necessary. Use it sparingly because the additional mutex-checks to avoid race conditions make accessing shared data much slower compared to accessing "normal" data, especially in concurrent scenarios.</p>
<h2 id="conclusion-3"><a class="header" href="#conclusion-3">Conclusion</a></h2>
<p>Flints concurrency approach, through its DOCP paradigm, is inherently simpler than in many other languages. Because Flint focuses on data modules themselves, their encapsulation and separation, it becomes much simpler to prevent race conditions or other problems related to concurrency.</p>
<p>You have learned a big chunk of Flints features by now. While you do not yet know everything, lets focus next on building a small program. Lets then focus on making a small library and publishing it on <strong>FlintHub</strong> to begin your collaborative Flint journey!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="custom.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
