<!DOCTYPE HTML>
<html lang="en" class="flint sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Flint Wiki</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/flint.css">
        <link rel="stylesheet" href="theme/flint-highlight.css">
        <link rel="stylesheet" href="version_select.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "flint";
            const default_dark_theme = "flint";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('flint')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Flint Wiki</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This is the Flint Wiki. You will be able to find anything regarding Flint in this Wiki. It's primary focus is the syntax of Flint, how it works and how to use the language effectively. All features of Flint and how to use them are explained in this Wiki. All chapters are structured in a way where later chapters build on the lessions of earlier chapters, so you will naturally have the best experience with Flint if you follow the guide closely from front to end.</p>
<p>Flint is a high‐level, statically‐typed language designed to deliver maximum power in the most approachable way. Its core philosophy is the Data-Object Convergence Paradigm — an ECS-inspired model where data is separated from behavior and then composed deterministically into class-like entities. Every function in Flint is pure (no side effects), and functions themselves are data that can be passed around or even hot-reloaded — thanks to the Thread Stack, which eliminates the possibility of race conditions by design. Write fast, predictable code without hidden complexity.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>You first need to download the <code>flintc</code> binary from the <a href="https://github.com/flint-lang/flintc/releases">Releases</a> page of the <code>flintc</code> repository or use the installer script if you are on Windows.</p>
<h2 id="linux"><a class="header" href="#linux">Linux</a></h2>
<p>To make the Flint compiler available from any path in your terminal, and to make it executable through just calling <code>flintc</code> in your terminal, you need to copy the <code>flintc</code> executable into the <code>$HOME/.local/bin/</code> directory and you need to ensure it is marked as executable with this command:</p>
<p>To make the Flint compiler available from any path in your terminal, and to make it executable through just calling <code>flintc</code> in your terminal, you need to copy the <code>flintc</code> executable into the <code>$HOME/.local/bin/</code> directory (if it does not exist yet, i would highly recommend to create it) and you need to ensure it is marked as executable with this command:</p>
<pre><code class="language-sh">chmod +x $HOME/.local/bin/flintc
</code></pre>
<p>After adding the <code>flintc</code> binary to the <code>$HOME/.local/bin</code> directory you should edit your <code>$HOME/.bashrc</code> file and ensure it contains the line</p>
<pre><code class="language-sh">PATH="$PATH:$HOME/.local/bin"
</code></pre>
<p>And then you can simply use the compiler from any terminal like so:</p>
<pre><code class="language-sh">flintc --help
</code></pre>
<p>You need <code>base-devel</code> (Arch) or <code>build-essential</code> (Ubuntu) in order for the Flint compiler to be able to compile any program. It needs the <code>crt1.o</code>, <code>crti.o</code> and <code>crtn.o</code> files available to it.</p>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>Installation on Windows is pretty easy, it's just a one-line command:</p>
<pre><code class="language-ps1">powershell -NoProfile -ExecutionPolicy Bypass -Command "iex (irm 'https://github.com/flint-lang/flint/releases/download/installer/flint_installer.ps1')"
</code></pre>
<p>Or if this one-liner scares you you can still <a href="https://github.com/flint-lang/flint/releases/download/installer/flint_installer.ps1">download</a> the installer directly and execute the downloaded script using the command</p>
<pre><code class="language-ps1">PowerShell -NoProfile -ExecutionPolicy Bypass -File .\flint_installer.ps1
</code></pre>
<p>The installer will always download the latest Flint release directly and add a wrapper command for it to always point at the correct latest compiler version. You can then use the compiler using</p>
<pre><code class="language-ps1">flintc.cmd --help
</code></pre>
<p>directly in any PowerShell. Note that the <code>flintc.cmd</code> command is only available in PowerShell, not in the command prompt.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="from-beginner-to-intermediate"><a class="header" href="#from-beginner-to-intermediate">From Beginner To Intermediate</a></h1>
<p>In this guide, you will learn all the basics of Flint. For easier chapter management, the whole journey of "From Beginner to Master" is split into three parts:</p>
<ul>
<li>"From Beginner to Intermediate" which handles all basics of Flint</li>
<li>"From Intermediate to Expert" which goes more in depth into advanced Flint features</li>
<li>"From Expert to Master" which tries to explain <em>everything</em> Flint has to offer</li>
</ul>
<p>With each chapter, you will learn more and more about the Flint language and its inner workings. At the end of this guide, you will know absolutely everything there is to know about the Flint language. No hidden features, no "never ending learning" of the language itself. Flint is made to be finite. Thats also the reason to why Flint does not ship a built-in standard library (stl).</p>
<p>Flint is meant to be a language framework, which aims to be as easy as possible while being as powerful as possible. We aim to provide you with a box full of little LEGOs. At the end of this guide series, you will know every LEGO block that exists.</p>
<p>Flint is sometimes limited on purpose. It has no manual memory management capabilities, for example, but these limitations all serve a singular purpose: Making Flint easier and quicker to work with, but not letting it feel like magic. Every design choise of Flint has a purpose. At the end of this full guide, you will understand every single design decision we took and why it was made.</p>
<p>But enough talking, lets jump right into it, lets turn you into a Flint master, shall we?</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>In this chapter you will learn the absolute basics of Flint. These basics are very important and you need to keep then in mind from now on.</p>
<p>The basics of every simple program is <code>printing</code>. Any program needs to display information to the user of the program in one form or another. It does not matter if its a GUI (Graphical User Interface) or a CLI (Command Line Interface), the user of a program will almost certainly always need information to reed when executing a program.</p>
<p>So, printing to the console is, in a sense, the most minimal thing a program should do. So lets start the basics with exactly that, and lets print to the console!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="the-hello-world-program"><a class="header" href="#the-hello-world-program">The Hello World Program</a></h1>
<p>Lets create a simple <code>Hello World!</code> program which just prints the text <code>Hello, World!</code> to the CLI. But before we can do that we need to create an entry point for our Flint program.</p>
<p>The entry point of every Flint program is the <code>main</code> function. This function is reserved for the programs entry point, so no other function is allowed to be called <code>main</code>. The entry point of any program is the point where the program starts its execution. Any program works from top to bottom, and everything within the <code>main</code> function is executed first. You dont need to worry about <code>functions</code> yet, they are explained in a later chapter.</p>
<p>But, lets create the example first and then explain what actually happens afterwards:</p>
<pre><code class="language-ft">use Core.print

def main():
    print("Hello, World!\n");
</code></pre>
<p>There is a lot to unpack here. You can safely ignore the <code>use Core.print</code> line for now. Just remember that this line needs to be written in order for the <code>print</code> function to be accessible. But what that line actually does will be described in a <a href="beginners_guide/1_basics/wiki/src/beginners_guide/5_functions.html">later</a> chapter.</p>
<p>The <code>def main():</code> line is the definition of the main function, but functions are described in a <a href="beginners_guide/1_basics/wiki/src/beginners_guide/5_functions.html">later</a> chapter too.</p>
<p>Now we come to the interesting line. <code>print("Hello, World!\n");</code>. <code>print</code> is a function call. A function call is like an instruction to execute. In this case we tell the Flint program to print the text to the console thats written in between the <code>"</code> symbols. This text between the <code>"</code> symbols is called a <strong>string</strong>. Here, we tell the <code>print</code> function to print the string <code>Hello, World!\n</code>. But what is this <code>\n</code> character? Its an escaped character for a new line. The <code>print</code> function does not print a new line after the string, so we need to provide a newline character manually.</p>
<p>The output of the above program would look like this:</p>
<blockquote>
<p>Hello, World!</p>
</blockquote>
<p>Try to remove the <code>\n</code> character and see what it does for yourself!</p>
<p>Always remember: The best way to learn is to try new things. Your computer won't explode if you make mistakes in a program, so just try out a few things and see for yourself what works and what doesn't!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="compiling-the-program"><a class="header" href="#compiling-the-program">Compiling the Program</a></h1>
<p>Save the code from the previous chapter into a file named <code>hello.ft</code>. <code>ft</code> is the file extension for <code>Flint</code> source files. They only contain code in written form. Its then the resposibility of the Flint compiler to take a file containing its source code and creating an executable from it.</p>
<p>To compile the <code>.ft</code> file to an executable file, we call</p>
<pre><code class="language-sh">flintc --file hello.ft --out hello
</code></pre>
<p>This will output the executable in the current working directory. It can be exexuted with the command</p>
<pre><code class="language-sh">./hello
</code></pre>
<p>And now you should see the output of the previous chapter in the console!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="comments-in-flint"><a class="header" href="#comments-in-flint">Comments in Flint</a></h1>
<p>In Flint, comments are used to explain code or temporarily disable parts of it during debugging. Flint supports two types of comments:</p>
<ol>
<li><strong>Single-line comments</strong>: Start with // and continue until the end of the line.</li>
<li><strong>Multi-line comments</strong>: Start with /_ and end with _/.</li>
</ol>
<p><strong>Here’s how you use comments:</strong></p>
<pre><code class="language-ft">use Core.print

def main():
    // This is a single-line comment explaining the print statement below
    print("Hello, Flint!\n");

    /*
     This is a multi-line comment.
     You can use it for detailed explanations
     or temporarily disabling multiple lines of code.
    */
    // print("This line is commented out and won't run.");
</code></pre>
<p>Comments are essential for writing clear, understandable, and maintainable code. Use them to explain your logic to others (or to yourself when revisiting code later).</p>
<p>Try to copy the code above into your <code>hello.ft</code> file and try to compile and run it.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="indentation-in-flint"><a class="header" href="#indentation-in-flint">Indentation in Flint</a></h1>
<p>Flint enforces <strong>strict indentation rules</strong> to ensure clean and readable code. Also, indentation is needed for <em>scoping</em>. Everything writen within the <code>main</code> functions is "inside" that function. If you don't indent instructions that are meant to be placed within the main function, for example, Flint will try to see if the line you wrote is a function or something else, like the <code>use Core.print</code> line.</p>
<p>Lets look at it in action:</p>
<pre><code class="language-ft">use Core.print

def main():
print("This is not indented correctly.\n");
</code></pre>
<p>When you run the above code, you’ll see an error message:</p>
<blockquote>
<pre><code>Parse Error at main.ft:4:1
└─┬┤E0000│
4 │ print("This is not indented correctly.\n");
┌─┴─┘
└─ Expected a body after the : from the line above
</code></pre>
</blockquote>
<p>This happens because Flint expects all code inside main to be indented. Here’s the correct way to write it:</p>
<pre><code class="language-ft">use Core.print

def main():
	print("This is correctly indented.\n"); // Properly indented
</code></pre>
<p>Proper indentation is not just a stylistic choice in Flint – it’s a fundamental part of the syntax. You do not need to indent using hard tabs (<code>\t</code>), <strong>4 spaces</strong> are interpreted as tabs by the Flint compiler.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="variables-and-types"><a class="header" href="#variables-and-types">Variables and Types</a></h1>
<p>In the previous chapter, we learned the basics of printing to the console in Flint. Now that we have a way to display information, let's talk about how to store and manipulate that information. In this chapter, we will explore the fundamental concepts of variables and types in Flint.</p>
<h2 id="what-are-variables"><a class="header" href="#what-are-variables">What are Variables?</a></h2>
<p>A variable is a named storage location that holds a value. Think of it as a labeled box where you can store a value. You can then use the variable name to refer to the value stored in the box.</p>
<h2 id="what-are-types"><a class="header" href="#what-are-types">What are Types?</a></h2>
<p>A type is a classification of data that determines the type of value a variable can hold. In Flint, every variable has a specific type, which determines the kind of value it can store. For example, a variable of type <code>i32</code> can only store integer values, while a variable of type <code>str</code> can only store text.</p>
<h2 id="why-are-variables-and-types-important"><a class="header" href="#why-are-variables-and-types-important">Why are Variables and Types Important?</a></h2>
<p>Variables and types are essential concepts in programming because they allow you to:</p>
<ul>
<li>Store and manipulate data in a program</li>
<li>Write more efficient and readable code</li>
<li>Avoid errors by ensuring that the correct type of data is used</li>
</ul>
<p>In this chapter, we will delve deeper into the world of variables and types in Flint. We will learn how to declare variables, assign values to them, and use them in our programs. We will also explore the different types of data that Flint supports, including integers, strings, and more.</p>
<h2 id="what-to-expect"><a class="header" href="#what-to-expect">What to Expect</a></h2>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Declaring variables and assigning values to them</li>
<li>Understanding the different types of data in Flint</li>
<li>Using variables and types in our programs</li>
<li>Best practices for working with variables and types</li>
</ul>
<p>By the end of this chapter, you will have a solid understanding of variables and types in Flint, and you will be able to use them to write more effective and efficient programs. Let's get started!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h1>
<p>Primitive types are Flint's fundamental building blocks for representing data. They are the simplest forms of values you can use in your programs. Flint has the following primitive types:</p>
<ol>
<li><code>i32</code>
Represents whole numbers, both positive and negative. Use <code>i32</code> for counting, indexing, or whenever you need discrete values.</li>
</ol>
<pre><code class="language-ft">def main():
    i32 x = 42; // A positive integer
    i32 y = -15; // A negative integer
    i32 z = 0; // Zero is also an integer
</code></pre>
<ol start="2">
<li><code>u32</code>
Represents whole numbers, but only positive ones. Use <code>u32</code> for IDs.</li>
</ol>
<pre><code class="language-ft">def main():
    u32 id_1 = 1;
    u32 id_0 = 0;
</code></pre>
<ol start="3">
<li><code>f32</code>
Represents floating-point numbers (decimal numbers). Use <code>f32</code> for measurements, precise calculations, or any value that requires a fractional component.</li>
</ol>
<pre><code class="language-ft">def main():
    f32 pi = 3.14; // Approximation of Pi
    f32 zero_kelvin = -273.15; // Negative floating point values are valid
    f32 zero = 0.0; // Zero with a decimal
</code></pre>
<ol start="4">
<li><code>str</code>
Represents a sequence of characters or text, as already described in the printing chapter. Use <code>str</code> for names, messages, or any textual data. Strings must be enclosed in double quotes (<code>"</code>).</li>
</ol>
<pre><code class="language-ft">def main():
    str name = "Flint"; // A simple string
    str empty = ""; // An empty string
    str greeting = "Hello, World!"; // A common example
</code></pre>
<p>These types are the foundation of Flint's data handling. As you write more complex programs, you'll combine them in creative ways to represent and manipulate information. But these are not the only primitive types there are available for Flint, they are just the most frequently used ones.</p>
<h2 id="bit-width"><a class="header" href="#bit-width">Bit-Width</a></h2>
<p>Now lets talk a bit about bit-width. You surely have seen the number after <code>i</code>, <code>u</code> and <code>f</code>. This is the <strong>bit-width</strong>. Computers work with bits, in this case it means that the integer and floating point types are 32 bits long. Here is a full list of all primitive types in Flint and their minimum and maximum values:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Type</th><th>Description</th><th style="text-align: center">Min</th><th style="text-align: center">Max</th><th>Precision</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>u8</code></td><td>unsigned 8 bit integer</td><td style="text-align: center"><code>0</code></td><td style="text-align: center"><code>255</code></td><td>Whole numbers</td></tr>
<tr><td style="text-align: center"><code>u32</code></td><td>unsigned 32 bit integer</td><td style="text-align: center"><code>0</code></td><td style="text-align: center"><code>4,294,967,295</code></td><td>Whole numbers</td></tr>
<tr><td style="text-align: center"><code>u64</code></td><td>unsigned 64 bit integer</td><td style="text-align: center"><code>0</code></td><td style="text-align: center">≈ <code>1.844 × 10^19</code></td><td>Whole numbers</td></tr>
<tr><td style="text-align: center"><code>i32</code></td><td>signed 32 bit integer</td><td style="text-align: center"><code>-2,147,486,648</code></td><td style="text-align: center"><code>2,147,486,647</code></td><td>Whole numbers</td></tr>
<tr><td style="text-align: center"><code>i64</code></td><td>signed 64 bit integer</td><td style="text-align: center">≈ <code>-1.844 × 10^19</code></td><td style="text-align: center">≈ <code>1.844 × 10^19</code></td><td>Whole numbers</td></tr>
<tr><td style="text-align: center"><code>f32</code></td><td>32 bit floating point number</td><td style="text-align: center">≈ <code>±1.175 × 10^-38</code></td><td style="text-align: center">≈ <code>±1.701 × 10^38</code></td><td>≈ 6 - 9 digits</td></tr>
<tr><td style="text-align: center"><code>f64</code></td><td>64 bit floating point number</td><td style="text-align: center">≈ <code>±1 × 10^-383</code></td><td style="text-align: center">≈ <code>±9.999 × 10^384</code></td><td>≈ 16 digits</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>Let's talk about variables and what they really are. A <em>variable</em> is an element of data that can be modified during the execution of a program, this can be an integer value, for example, or a string value. Variables are one of, if not even <em>the</em> most important part of a program.</p>
<p>Every variable needs to have a fixed <em>type</em> assigned to it. There are much more types than only the primitive types of the last chapter, but everything in this chapter will apply to other types as well. First, we need to define a variable. This is done like this:</p>
<pre><code class="language-ft">def main():
    i32 x = 5;
</code></pre>
<p>You have already seen this in the last chapter, so lets unpack it now. <code>i32</code> is the type of the variable. <code>x</code> is the name (<em>identifier</em>) of the variable we just created, and we <em>declare</em> the variable <code>x</code> to be the value of <code>5</code>. This whole line you see above is called a <code>declaration</code>, because we declare a new variable.
Now lets look at how to assign new values to the variable:</p>
<pre><code class="language-ft">def main():
    i32 x = 5; // The declaration
    x = 7; // The assignment
</code></pre>
<p>We now store the value of <code>7</code> in the previously declared variable <code>x</code>. The variable <code>x</code> still has the type of <code>i32</code>. Types of variables cannot change after we declared a variable. This whole characteristic, that the type cannot change after the creation of a variable, and that the type of a variable is fixed, is called <strong>static typing</strong>.</p>
<h2 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h2>
<p>But what if we write something like this?</p>
<pre><code class="language-ft">def main():
    i32 x = 7;
    i32 x = 8;
</code></pre>
<p>You can try to compile this program yourself and see what you get. But to make things a bit easier i show you. You will get this error:</p>
<blockquote>
<pre><code>Parse Error at main.ft:3:9
└─┬┤E0000│
1 │ def main():
3 │ »   i32 x = 8;
┌─┴─────────┘
└─ Variable 'x' already exists
</code></pre>
</blockquote>
<p>As you can see, Flint only allows one single variable with the identifier <code>x</code> to exist within the main function, even if its type differs:</p>
<pre><code class="language-ft">def main():
    i32 x = 7;
    f32 x = 3.3;
</code></pre>
<p>This fails with the same error. Some languages support that a variable is "redefined" with another type, and from this new declaration onwards the variable has a different type. This is called <em>shadowing</em>, and Flint does not support this intentionally. Every variable can only exist once within a scope (we talk about scopes later on).</p>
<p>So, remember: The same identifier can only used once for variables!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="inferred-typing"><a class="header" href="#inferred-typing">Inferred Typing</a></h1>
<p>Flint allows for inferred typing, meaning you don't always need to explicitly state the type of a variable. The compiler can infer the type based on the assigned value.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<pre><code class="language-ft">def main():
    x := 42; // The compiler infers that x is an i32
    pi := 3.14; // The compiler infers that pi is a f32
    greeting := "Hello, Flint!"; // The compiler infers that greeting is a str
</code></pre>
<p>While inferred typing is convenient and makes code concise, explicit typing can improve readability in more complex programs. You can always use explicit typing if you prefer its clarity:</p>
<pre><code class="language-ft">def main():
    i32 x = 42; // Explicitly declare x as an i32
    f32 pi = 3.14; // Explicitly declare pi as a f32
    str greeting = "Hello, Flint!"; // Explicitly declare greeting as a str
</code></pre>
<p>Use inferred typing for shorter, simpler programs and explicit typing when clarity is crucial. It's also important to note that <em>only</em> varaibles are allowed to have inferred typing, nothing else.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="operators"><a class="header" href="#operators">Operators</a></h1>
<p>Flint has quite a few operators in its disposal. The most common and most simple ones, however, are <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code>. The <code>+</code> and <code>-</code> operators dont need much explaination, really.</p>
<h2 id="integer-arithmetic"><a class="header" href="#integer-arithmetic">Integer Arithmetic</a></h2>
<p>Lets start with the most obvious example first: integer types and lets go through all operations one by one:</p>
<h3 id="the--operator"><a class="header" href="#the--operator">The <code>+</code> Operator</a></h3>
<p>The <code>+</code> operator is very easy, it is used to add two numbers together. But there is a catch... do you remember the <a href="beginners_guide/2_variables_and_types/./1_primitive_types.html#bit-width">Bit-Width</a> table from <a href="beginners_guide/2_variables_and_types/./1_primitive_types.html">this</a> chapter? This now becomes important, more specifically the <strong>Min</strong> and <strong>Max</strong> value columns. For example, if you add two <code>u32</code> typed variables together, like so:</p>
<pre><code class="language-ft">def main():
    u32 n1 = 4_294_967_290;
    u32 n2 = 10;
    u32 n3 = n1 + n2;
</code></pre>
<p>what value should <code>n3</code> then have? Oh, and dont get confused by the <code>_</code> values in the number. Flint will ignore these and it will read the number as <code>4294967290</code> just fine, but they make the number <em>much</em> more readable!</p>
<p>If you execute the built binary you will see this message printed to your console:</p>
<blockquote>
<pre><code>u32 add overflow caught
</code></pre>
</blockquote>
<p>This happens, because the maximum value of an <code>u32</code> is <code>4.294.967.295</code> and <code>4.294.967.290 + 10 = 4.294.967.300</code>, which is greater than the maximum value of the <code>u32</code> type. In any computers, the numbers are represented as binaries (<code>0</code> and <code>1</code>) and any number uses the <code>binary</code> number system. If you are interested in this topic you can search for <strong>Integer Overflow</strong>.</p>
<p>In Flint, however, the <code>u32</code> value is just capped to the maximum value of <code>u32</code>. So, <code>n3</code> will have the value <code>4.294.967.295</code> saved in it after the addition.</p>
<h3 id="the---operator"><a class="header" href="#the---operator">The <code>-</code> Operator</a></h3>
<p>The same as above applies here. The minimum value for <code>u32</code> values is <code>0</code>, so if we try to run this program:</p>
<pre><code class="language-ft">def main():
    u32 ten = 10;
    u32 twenty = 20;
    u32 result = ten - twenty;
</code></pre>
<p>we get a similar message as before:</p>
<blockquote>
<pre><code>u32 sub underflow caught
</code></pre>
</blockquote>
<p>A <code>underflow</code> is the same as an <code>overflow</code> but for the minimum value instead of the maximum value. Just like with the overflows, Flint clamps the value at <code>0</code> here too.</p>
<h3 id="the--operator-1"><a class="header" href="#the--operator-1">The <code>/</code> Operator</a></h3>
<p>Because integer types (<code>i32</code>, <code>u32</code>, ...) don't have a fractional part like floating point types (<code>f32</code>, ...) they cannot preserve their fractional information when dividing. This means that in this function here:</p>
<pre><code class="language-ft">def main():
    i32 n1 = 100;
    i32 n2 = 30;
    i32 n3 = n1 / n2;
</code></pre>
<p>The varaible <code>n3</code> will have the value <code>3</code> saved in it, even though the value actually would be <code>3,333..</code>. This is a characteristic of <strong>integer division</strong>. The fractional part is <em>always</em> cut off. If you program a bit you will actually find out that this behaviour can work to your advantage. So, this also means that the result of <code>100 / 60</code> is <code>1,666..</code> with the fractional, but for integer divisions its just <code>1</code>.</p>
<p>The <code>*</code> Operator is pretty easy to understand, actually. There aren't much things to consider when using it ecept for a possible <em>integer overflow</em> if the result becomes too large and order of operation.</p>
<p>Order of Operation (or better said the <em>wrong</em> order of operation) is a very common mistake regarding integer arithmetic. It is commonly overlooked that a division can lead to a <code>0</code>, for example with the calculation of <code>10 / 8 * 16</code>, we would expect the result to be <code>20</code>. But the calculation is evaluated as follows: <code>(10 / 8) * 16</code> which expands to <code>10 / 8</code> which is <code>0</code>.</p>
<p>So, mathematically we would expect the result to be <code>20</code> but because of the order of operations it has become <code>0</code> instead. This can only be fixed by applying the correct oder, in our case this would be <code>10 * 16 / 8</code> which gets evaluated to <code>(10 * 16) / 8</code> which will result in the expected result of <code>20</code>.
Note that you can also use parenthesis to explicitely state the order of operation you want to have: <code>10 / (8 * 16)</code> (this will still result in <code>0</code> but its evaluated differently).</p>
<h3 id="the--and--operators"><a class="header" href="#the--and--operators">The <code>==</code> and <code>!=</code> Operators</a></h3>
<p>One can also <em>compare</em> two integer values with one another. The comparison returns a boolean (<code>bool</code> type) which is used for comparisons, but you will learn more about what a <code>bool</code> is in the upcoming chapter <a href="beginners_guide/2_variables_and_types//wiki/src/beginners_guide/3_control_flow.html">here</a>. For now, just note that the operator exists.</p>
<h2 id="floating-point-arithmetic"><a class="header" href="#floating-point-arithmetic">Floating Point Arithmetic</a></h2>
<p>Floating Point Arithmetic can be pretty tricky at times. Flint's floating points use the IEEE-754 standard. If you don't know what this means, dont worry, we will talk about it here, as easy as possible. If you want to know more about the standard and how floating point numbers are actually implemented, it is recommended to look <a href="https://www.geeksforgeeks.org/ieee-standard-754-floating-point-numbers/">here</a>.</p>
<p>But, in a nutshell, any floating point number comes with a specific level of <strong>inprecision</strong>. You dont need to worry about what this means for now, just remember that a number might not be <strong>exactly</strong> the number you specified, because some numbers (like <code>1 / 3</code>) cannot be stored in a number on the computer, because its result is <code>0.333...</code> and it cannot be stored and compared reliably. Also, some numbers just cannot be stored fully in floating point numbers. Here is a small example showing floating point arithmetic inprecision in action:</p>
<pre><code class="language-ft">use Core.print

def main():
    f64 val = 0.05;
    val += 0.3;
    print($"0.05 + 0.3 = {val}\n");
    print($"{val} == 0.35 ? {val == 0.35}\n");
</code></pre>
<p>From this small program, you will see the output</p>
<blockquote>
<pre><code>0.05 + 0.3 = 0.350000012665987

0.350000012665987 == 0.35 ? false
</code></pre>
</blockquote>
<p>Don't worry about that <code>$"{..}"</code> thing, its called <em>string interpolation</em> and you will learn about it <a href="beginners_guide/2_variables_and_types/./6_string_interpolation.html">shortly</a>.</p>
<p>But, as you can see the condition is <code>false</code>, thats because <code>val</code> is not <strong>exactly</strong> the same as <code>0.35</code> in this case, because their bits differ. So, use the <code>==</code> and <code>!=</code> operators with caution when dealing with floating point variables.</p>
<h2 id="strings"><a class="header" href="#strings">Strings</a></h2>
<p>Strings (<code>str</code> type) do not support the <code>-</code>, <code>*</code> or <code>/</code> operators. <em>But</em> you can use the <code>+</code> operator to add (concatenate) two strings:</p>
<pre><code class="language-ft">use Core.print

def main():
    str hello = "Hello, ";
    str world = "World!\n";
    str hello_world = hello + world;
    print(hello_world);
</code></pre>
<p>If you run this program, you will see this output in your console:</p>
<blockquote>
<pre><code>Hello, World!
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="typecasting"><a class="header" href="#typecasting">Typecasting</a></h1>
<p>First of all, what is typecasting? We know what a <code>type</code> is, but what is <code>casting</code>? Casting is the act of <em>converting</em> one type into another. Different types are incompatible with one another, even <code>i32</code> and <code>u32</code> are incompatible, even though both of them have the same bit width. For example, the <code>i32</code> value of <code>-233235653</code> would actually be <code>4061731643</code> when the bits would be interpreted as an <code>u32</code> instead. And if the 32 bits of the <code>i32</code> value would be interpreted as an <code>f32</code> value, we would end up with the number <code>-3.032584e30</code>. (The bit pattern of this example is <code>1111 0010 0001 1001 0001 1011 0011 1011</code>)</p>
<p>As you can see, just storing the bits of one number into the bits of another number is not enough. This is the reason to why we need to convert, or <strong>cast</strong> types. Try to compile this program and see what the compiler tells you:</p>
<pre><code class="language-ft">def main():
    i32 val = 3.3;
</code></pre>
<p>The compiler will throw an error like:</p>
<blockquote>
<pre><code>Parse Error at main.ft:2:15
└─┬┤E0000│
1 │ def main():
2 │ »   i32 val = 3.3;
┌─┴───────────────┘
└─ Type mismatch of expression
    ├─ Expected: i32
    └─ But got:  f32
</code></pre>
</blockquote>
<p>and it will tell you exactly what went wrong. The type of <code>i32</code> was expected, beause we want to store something of type <code>i32</code> in the variable <code>val</code>, but we provided a floating point number, which defaults to <code>f32</code>. So, we need to convert the type of <code>f32</code> to <code>i32</code> in this case.</p>
<h2 id="explicit-typecasting"><a class="header" href="#explicit-typecasting">Explicit Typecasting</a></h2>
<p>Types can be explicitely cast like this:</p>
<pre><code class="language-ft">def main():
    i32 val = i32(3.3);
</code></pre>
<p>We just write the type we want to have like <code>i32</code> in this case followed by an open paren <code>(</code> and then the <strong>expression</strong> which has a different type and then the closing paren <code>)</code>.</p>
<p>Also, every type can be cast to an <code>str</code> type! Try to run this program and see what happens:</p>
<pre><code class="language-ft">use Core.print

def main():
    f32 fval = 3.3;
    str message = "fval = ";
    message += str(fval);
    message += "\n";
    print(message);
</code></pre>
<p>You will see the message</p>
<blockquote>
<pre><code>fval = 3.3
</code></pre>
</blockquote>
<p>printed to the console.</p>
<p>Okay, and now a bit more complicated example:</p>
<pre><code class="language-ft">use Core.print

def main():
    f32 fval = 3.7;
    i32 ival = i32(fval);
    str message = "fval = ";
    message += str(fval);
    message += ", ival = ";
    message += str(ival);
    message += "\n";
    print(message);
</code></pre>
<p>This small program prints this message to the console:</p>
<blockquote>
<pre><code>fval = 3.7, ival = 3
</code></pre>
</blockquote>
<p>You maybe expected a result like</p>
<blockquote>
<pre><code>fval = 3.7, ival = 4
</code></pre>
</blockquote>
<p>but here comes some very important information about type casting: When casting floating point types to integer types the fractional part is simply <strong>cut off</strong>. Its never rounded, only cut. But that definitely can be a good thing, if used correctly. Just remember, that when casting floating point values to integer values you will simply loose the fractional information.</p>
<h2 id="implicit-typecasting"><a class="header" href="#implicit-typecasting">Implicit Typecasting</a></h2>
<p>Everything we have discussed up until now was regarding the act of <strong>explicitely casting</strong> values. But, some values can be cast <strong>implicitely</strong> by the compiler. There exists one rule of thumb in Flint: You can cast types implicitely if you <em>won't</em> loose any information through that cast. So, you can happily implicitely cast <code>i32</code> to <code>f32</code> but you <em>cannot</em> implicitely cast <code>f32</code> to <code>i32</code>. Also, pretty much <em>any</em> type can be implicitely cast to a <code>str</code> type too! Here's how this looks in action:</p>
<pre><code class="language-ft">use Core.print

def main():
    f32 fval = 3;
    str message = "fval = ";
    message += fval;
    message += "\n";
    print(message);
</code></pre>
<p>Notice how we did not write <em>any</em> explicit casting whatsoever? This program prints this message to the console:</p>
<blockquote>
<pre><code>fval = 3.0
</code></pre>
</blockquote>
<p>Note that the floating point to string conversion happened implicitely?</p>
<div class="warning">
<p>This behaves differntly in the current release of Flint</p>
<p>Currently, you won't see <code>fval = 3.0</code> printed to the console, but rather <code>fval = 3</code>. This is not a big deal, it only happens when the fractional part of the floating point value is zero, but this behaviour is a bit misleading, as you now could think that the value used to print <code>3</code> is an integer type, not a floating point type. Printing <code>3.0</code> makes this unambiguous and is considered the correct way to do it.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="string-interpolation"><a class="header" href="#string-interpolation">String Interpolation</a></h1>
<p>Until now you have seen quite often that we do something like this:</p>
<pre><code class="language-ft">use Core.print

def main():
    f32 fval = 3;
    str message = "fval = ";
    message += fval;
    message += "\n";
    print(message);
</code></pre>
<p>We create the <code>message</code> variable and then write <code>+=</code> over and over again to fill the string with values. But, there is a <strong>much</strong> simpler way of integrating variables into a string, its called <strong>string interpolation</strong>. You have already seen it once, but lets explain it now.</p>
<p>The syntax of string interpolation is quite simple. You write a normal string, like <code>"Hello Flint"</code>. Then you put a dollar sign in front of the string: <code>$"Hello, Flint"</code>. And thats (almost) it. Now, everything thats written in between curly braces <code>{}</code> is handled as an <strong>expression</strong>. Expressions are everything that you would write on the right side of the equals sign, for example. So, here an easy example:</p>
<pre><code class="language-ft">use Core.print

def main():
    str name = "Flint";
    i32 age = 1;
    print($"Hello, my name is {name} and I am {age} years old.\n");
</code></pre>
<p>Output:</p>
<blockquote>
<pre><code>Hello, my name is Flint and I am 1 years old.
</code></pre>
</blockquote>
<p>And now you see why its important that almost any type can be implicitely cast to a <code>str</code> type, because otherwise we would need to write <code>str(age)</code> here, or need to write <code>str(..)</code> any time we would want to use string interpolation.</p>
<p>You can actually interpolate any variable or expression into a string:</p>
<pre><code class="language-ft">use Core.print

def main():
    f32 pi = 3.14;
    // Inserting floating point values
    print($"The value of pi is approximately {pi}\n");
    // Inserting an arithmetic expression
    print($"2 + 2 equals {2 + 2}\n");
</code></pre>
<p>Which prints these lines to the console:</p>
<blockquote>
<pre><code>The value of pi is approximately 3.14
2 + 2 equals 4
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<p>In the previous chapters, we learned the basics of printing to the console and working with variables and types in Flint. Now that we have a way to display information and store data, let's talk about how to control the flow of our program's execution. In this chapter, we will explore the fundamental concepts of control flow in Flint.</p>
<h2 id="what-is-control-flow"><a class="header" href="#what-is-control-flow">What is Control Flow?</a></h2>
<p>Control flow refers to the order in which a program's statements are executed. In other words, it's the way a program decides what to do next. Control flow is essential in programming because it allows you to write programs that can make decisions, repeat tasks, and handle different situations.</p>
<h2 id="why-is-control-flow-important"><a class="header" href="#why-is-control-flow-important">Why is Control Flow Important?</a></h2>
<p>Control flow is crucial in programming because it enables you to:</p>
<ul>
<li>Write programs that can adapt to different inputs and situations</li>
<li>Repeat tasks without having to write the same code multiple times</li>
<li>Make decisions based on conditions and data</li>
</ul>
<p>In this chapter, we will learn about the different control flow statements in Flint, including conditional statements, loops, and functions. We will see how to use these statements to write more efficient, readable, and effective programs.</p>
<h2 id="what-to-expect-1"><a class="header" href="#what-to-expect-1">What to Expect</a></h2>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Conditional statements: if, else, and switch</li>
<li>Loops: for, while, and repeat</li>
<li>Best practices for working with control flow statements</li>
</ul>
<p>By the end of this chapter, you will have a solid understanding of control flow in Flint, and you will be able to use it to write more sophisticated and efficient programs. Let's get started!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="the-bool-type"><a class="header" href="#the-bool-type">The <code>bool</code> Type</a></h1>
<p>In Flint, the <code>bool</code> type represents truth values: <code>true</code> or <code>false</code>. Boolean values are fundamental in programming, as they enable decision-making and control flow. Boolean values are equal both in programming and in mathematics, they actually dont really differ. Here is a small example of how to declare a boolean variable and how to print its value to the console:</p>
<pre><code class="language-ft">use Core.print

def main():
    bool is_learning = true;
    bool is_hungry = false;
    print($"is_learing = {is_learning}, is_hungry = {is_hungry}\n");
</code></pre>
<p>This program prints this line to the console:</p>
<blockquote>
<pre><code>is_learing = true, is_hungry = false
</code></pre>
</blockquote>
<h2 id="checking-for-equality-and-inequality"><a class="header" href="#checking-for-equality-and-inequality">Checking for equality and inequality</a></h2>
<p>You can check if a boolean type is equal to another boolean type. The result of the <code>==</code> and <code>!=</code> operators is <em>always</em> a <code>bool</code> type, because either they are equal or not. So, if you look if two <code>i32</code> values are equal, the result of this check will be of type <code>bool</code>.</p>
<pre><code class="language-ft">use Core.print

def main():
    i32 val1 = 4;
    i32 val2 = 6;
    bool is_eq = val1 == val2;
    bool is_neq = val1 != val2;
    print($"val1 = {val1}, val2 = {val2}, is_eq = {is_eq}, is_neq = {is_neq}\n");
</code></pre>
<p>This program prints this line to the console:</p>
<blockquote>
<pre><code>val1 = 4, val2 = 6, is_eq = false, is_neq = true
</code></pre>
</blockquote>
<p>But now lets compare two boolean values with one another:</p>
<pre><code class="language-ft">use Core.print

def main():
    bool t_eq_f = true == false;
    print($"t_eq_f = {t_eq_f}\n");

    bool t_neq_f = true != false;
    print($"t_neq_f = {t_neq_f}\n");

    bool t_eq_t = true == true;
    print($"t_eq_t = {t_eq_t}\n");
    bool t_neq_t = true != true;
    print($"t_neq_t = {t_neq_t}\n");

    bool f_eq_f = false == false;
    print($"f_eq_f = {f_eq_f}\n");
    bool f_neq_f = false != false;
    print($"f_neq_f = {f_neq_f}\n");
</code></pre>
<p>This program prints these lines to the console:</p>
<blockquote>
<pre><code>t_eq_f = false
t_neq_f = true
t_eq_t = true
t_neq_t = false
f_eq_f = true
f_neq_f = false
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="boolean-operations"><a class="header" href="#boolean-operations">Boolean Operations</a></h1>
<p>Boolean operators, such as <code>and</code>, <code>or</code> and <code>not</code> combine or modify <code>bool</code> values. They’re useful for creating more complex conditions. In this chapter, you will learn how each operator works.</p>
<h2 id="and-operator"><a class="header" href="#and-operator"><code>and</code> Operator</a></h2>
<p>The <code>and</code> operator combines two conditions and evaluates to <code>true</code> only if <strong>both</strong> conditions are <code>true</code>.</p>
<pre><code class="language-ft">use Core.print

def main():
    bool is_adult = true;
    bool has_id = false;
    print($"Is adult and has an ID? {is_adult and has_id}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>Is adult and has an ID? false
</code></pre>
</blockquote>
<h2 id="or-operator"><a class="header" href="#or-operator"><code>or</code> Operator</a></h2>
<p>The <code>or</code> operator combines two conditions and evaluates to <code>true</code> if <strong>at least</strong> one condition is <code>true</code>.</p>
<pre><code class="language-ft">use Core.print

def main():
    bool is_vip = true;
    bool has_ticket = false;
    print($"Is VIP or has a ticket? {is_vip or has_ticket}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>Is VIP or has a ticket? true
</code></pre>
</blockquote>
<h2 id="not-operator"><a class="header" href="#not-operator"><code>not</code> Operator</a></h2>
<p>The <code>not</code> operator inverts the value of a boolean, so it makes <code>false</code> to <code>true</code> and vice versa.</p>
<pre><code class="language-ft">use Core.print

def main():
    bool is_raining = false;
    print($"Is it not raining? {not is_raining}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>Is it not raining? true
</code></pre>
</blockquote>
<h2 id="operator-precedence"><a class="header" href="#operator-precedence">Operator Precedence</a></h2>
<p>The precedence (default order of execution) of <code>and</code> is higher than the one of <code>or</code>, similar to how <code>*</code> has a higher precedence than <code>+</code> in arithmetics. This means that the <code>and</code> operation will always be evaluated <em>before</em> the <code>or</code> operation:</p>
<pre><code class="language-ft">use Core.print

def main():
    // Evaluates to 'true' ('and' happens first)
    bool condition = true or false and false;
    print($"condition = {condition}\n");

    // Evaluates to 'false' ('and' happens second)
    bool clarified = (true or false) and false;
    print($"clarified = {clarified}\n");
</code></pre>
<p>This program prints these lines to the console:</p>
<blockquote>
<pre><code>condition = true
clarified = false
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="branching"><a class="header" href="#branching">Branching</a></h1>
<p>Branching is the act of executing different "blocks" of code depending on conditions (booleans). But, before we can talk about branching we need to talk about what this <em>block</em> really is. Take the main function, for example:</p>
<pre><code class="language-ft">use Core.print

def main():
    f32 val = 3.3;
    i32 val_i = i32(val);
    print($"{val} = {val_i}\n");
</code></pre>
<p>In this function, everything thats indented once is considered to be "inside" the main function. But what does this "inside" really mean? There exists a formal description for this "inside", it's called a <code>Scope</code>. The Scope of the main function is everything thats written down within the main functions <em>body</em> ("inside" the function).</p>
<p>Scopes are a really important concept in programming, because there exist several consistent and deterministic rules about scopes and <em>subscopes</em>. But thats enough theory for now, lets look at the easiest example for branching, the <code>if</code> statement.</p>
<h2 id="the-if-statement"><a class="header" href="#the-if-statement">The if Statement</a></h2>
<p>The if statement lets your program execute code only when a condition evaluates to true. Here's how it works:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32 age = 18;

    if age &gt;= 18: // The condition evaluates to true
        print($"You are {age} years old, so you can vote!\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>You are 18 years old, so you can vote!
</code></pre>
</blockquote>
<p>Try changing the <code>age</code> to <code>17</code> and watch what happens.</p>
<p>If the condition evaluates to false, the program skips the block of code inside the <code>if</code> statement. We say that the <code>print</code> call here is <strong>inside the if statement's scope</strong>. But what does scope really mean? Have a look at this example:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32 age = 18;

    if age &gt;= 18:
        i32 somevalue = 22;
        print("Age is above or equal to 18!\n");

    print($"somevalue = {somevalue}\n");
</code></pre>
<p>Here, the declaration of the <code>age</code> variable is inside the <code>main</code> function's scope, while the <code>somevalue</code> declaration and the first <code>print</code> call are inside the <code>if</code> statement's scope. The second <code>print</code> call, however, is inside the <code>main</code> function's scope again. As you can see, the scope is direclty determined by the level of indentation.</p>
<p>If yout try to compile this program you will see a compilation error:</p>
<blockquote>
<pre><code>Parse Error at main.ft:10:26
└──┬┤E0000│
3  │ def main():
10 │ »   print($"somevalue = {somevalue}\n");
┌──┴──────────────────────────┘
└─ Use of undeclared variable 'somevalue'
</code></pre>
</blockquote>
<p>But why is that? We did define the variable <code>somevalue</code> in the if statement's scope, right? Yes, we defined the variable in the if statement's scope, but here comes one of the mentioned rules of scopes into play: Visibility.</p>
<p>But what's visibility? Visibility describes the visibility of variables within scopes and their parent or child scopes. The if statement's scope, for example, is a <code>child scope</code> of the <code>main</code> function's scope. Because its a child scope it can "see" all variables of its parent scope. <strong>But</strong> it can only see variables that have been defined up until the child scope. To illustrate what this means, look at this example:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32 val1 = 1;
    if val1 &lt; 10:
        print("val1 &lt; 10\n");
    i32 val2 = 2;
</code></pre>
<p>what i described above means nothing else than the simple fact that <code>val1</code> is <strong>visible</strong> inside the if statements scope, but <code>val2</code> is <em>not</em>, because <code>val2</code> is defined <strong>after</strong> the if statements scope. So, a child scope can only see variables of its parent scope that have been declared <strong>before</strong> it.</p>
<p>Parent scopes <strong>do not</strong> inherit <strong>any</strong> variable definitions of their child scopes. This program, for example:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32 val1 = 2;
    if val1 &lt; 10:
        i32 val2 = 44;
        print($"val1 = {val1}, val2 = {val2}\n");
    i32 val2 = 12;
    print($"val1 = {val1}, val2 = {val2}\n");
</code></pre>
<p>will compile and run fine. But lets discuss why that is. The variable <code>val2</code> is defined <em>inside</em> the if statements scope, this means that its visible for the rest of the if statements scope and all possible child scopes of it, but it is not visible for its parent scope. Because the variable <code>val2</code> does not exist in the main function's scope yet, this works fine, as no variable definition is shadowed. Because the variable <code>val2</code> never existed in the main function's scope, we can declare a new variable <code>val2</code> inside the main function.</p>
<p>This behaviour of visibility given down to children but never up to parents is the very reason why the compile error from above happened, becaue the variable <code>somevalue</code> was never defined in the main functions scope, so it simply does not exist at the position we wanted to use it.</p>
<h2 id="the-else-keyword"><a class="header" href="#the-else-keyword">The else Keyword</a></h2>
<p>Now that you know scopes and visibility, the else statement should actually be pretty easy to understand. An else statement is used whenever you want to do something if another condition failed. It is explained best through an example:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32 age = 16;

    if age &gt;= 18: // If this is false...
        print($"You are {age} years old, so you can vote!\n");
    else: // ...then this block executes
        print($"You are {age} years old, so you cannot vote.\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>You are 16 years old, so you cannot vote.
</code></pre>
</blockquote>
<p>Try changing the <code>age</code> variable to, lets say 20, and see what happens.</p>
<h2 id="the-else-if-keyword"><a class="header" href="#the-else-if-keyword">The else if Keyword</a></h2>
<p>Sometimes, you need multiple conditions. Instead of stacking multiple if statements, you can use else if to create a chain of conditions. The important thing to remember here is that <strong>only one</strong> of the branches will be executed, not multiple ones.</p>
<pre><code class="language-ft">use Core.print

def main():
    i32 age = 16;

    if age &gt;= 65:
        print("You qualify for senior discounts.\n");
    else if age &gt;= 18:
        print("You can vote but no senior discounts yet!\n");
    else:
        print("You are too young to vote.\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>You are too young to vote.
</code></pre>
</blockquote>
<p>Play around a bit. Change the value of <code>age</code> and see what happens. Try to write your own conditions and branches.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="loops"><a class="header" href="#loops">Loops</a></h1>
<p>Programming often involves repeating tasks. For example, imagine printing every number from <code>1</code> to <code>10</code>. It’s tedious to write print 10 times! Loops automate such repetition. But what even <em>is</em> a loop? Lets start with the most simple form of a loop, the <code>while</code> loop.</p>
<h2 id="the-while-loop"><a class="header" href="#the-while-loop">The <code>while</code> Loop</a></h2>
<p>The while loop is actually the more simple loop you can have. The body of the loop (its scope) is executed as long as the condition of the while loop evaluates to <code>true</code>. But be cautious, you can create <strong>infinite loops</strong> relatively easily with a <code>while</code> loop. Here is a simple example of a while loop in action:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32 num = 0;
    while num &lt; 5:
        print($"num = {num}\n");
        num++;
</code></pre>
<p>But wait! Whats this <code>num++</code>? The <code>++</code> is called an <strong>increment operator</strong> it literally just increments <code>num</code> by 1. So, <code>num++</code> is just a neat way to say <code>num += 1</code>, which is a neat way to say <code>num = num + 1</code>. The increment operator exists because its just so common to write incrementations in loops (and it looks nicer too).</p>
<p>The above program will print these lines to the console:</p>
<blockquote>
<pre><code>num = 0
num = 1
num = 2
num = 3
num = 4
</code></pre>
</blockquote>
<p>As you can see, the body of the while loop got executed <code>5</code> times. If you, for example, would forget the <code>num++</code> line, this while loop would turn into an infinite loop. Can you see why?</p>
<p>Its because the condition <code>num &lt; 5</code> will always stay <code>true</code> because <code>0 &lt; 5</code>. But the while loop is only one of the looping statements which exist in Flint, there are more.</p>
<h2 id="the-do-while-loop"><a class="header" href="#the-do-while-loop">The <code>do while</code> Loop</a></h2>
<div class="warning">
<p>The do while loop does not yet work in the compiler.</p>
<p>Do while loops do not work at the moment, as they just have not been implemented in the compiler yet. But they will work in future releases eventually.</p>
</div>
<p>The <code>do while</code> loop is actually very similar to the <code>while</code> loop. The expression of the <code>while</code> loop gets evaluated <em>before</em> the body of the loop is executed. It executes the body if the condition is true, and then jumps back to the condition and checks again and so on. In <code>do while</code> loops this is different. Here, the body is executed first and <em>then</em> the condition is checked. Similar to <code>while</code> loops, <code>do while</code> loops run as long as the condition evaluates to true. Here is a small example of a <code>do while</code> loop:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32 num = 0;
    do:
        print($"num = {num}\n");
        num++;
    while num &lt; 5;
</code></pre>
<p>This loop will have the same output as the <code>while</code> loop above. But try changing the initial value of <code>num</code> to something bigger or equal to <code>5</code>, for example setting it to <code>10</code>. Do you recognize a difference between the two loop types?</p>
<p>The <code>do while</code> loop actually always executes <strong>at least once</strong> while the <code>while</code> loop can actually skip its body entirely. Ensuring that a loop runs at least once is not as common as the "normal" while loop, but when you need it you will be greatful that it is supported, as emulating the same behaviour with "normal" while loops is pretty hard.</p>
<h2 id="the-for-loop"><a class="header" href="#the-for-loop">The <code>for</code> Loop</a></h2>
<p>A <code>for</code> loop is very interesting, and probably the loop type you will end up writing the most common in Flint. The important part of the <code>for</code> loop is, that it is composed of three main parts:</p>
<ul>
<li>The variable declaration statement</li>
<li>A condition (exactly how <code>while</code>'s condition works this condition is evaluated <em>before</em> the body runs)</li>
<li>A statement that will be executed at the end of each iteration</li>
</ul>
<p>But it is best shown how this will look:</p>
<pre><code class="language-ft">use Core.print

def main():
    for i32 i = 0; i &lt; 5; i++:
        print($"Iteration {i}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>Iteration 0
Iteration 1
Iteration 2
Iteration 3
Iteration 4
</code></pre>
</blockquote>
<p>If you look closely, its actually pretty much the same as with our while loop. Both <code>for</code> and <code>while</code> loops are actually interchangable from one another, meaning that one loop type can easily be converted to the other type. In our case, the <code>while</code> loop implementation of this very same loop would look like this:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32 i = 0;
    while i &lt; 5:
        print($"Iteration {i}\n");
        i++;
</code></pre>
<p>But there exists one rather big difference between <code>for</code> and <code>while</code> loops. While in the <code>while</code> loop, the variable <code>i</code> is now part of the main function's scope, for the <code>for</code> loop, this is not the case. The <code>i</code> variable is only contained <em>inside</em> the <code>for</code> loops scope. This is very important, because it is most common to use <code>i</code> for the <strong>i</strong>ncrementing variable of a loop:</p>
<pre><code class="language-ft">use Core.print

def main():
    for i32 i = 0; i &lt; 5; i++:
        print($"Loop 1, iteration: {i}\n");
    // 'i' cannot be used after the for loop

    // 'i' can be re-declared here, because 'i' was
    // never declared inside the main functions scope
    for u32 i = 0; i &lt; 4; i++:
        print($"Loop 2, iteration: {i}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>Loop 1, iteration: 0
Loop 1, iteration: 1
Loop 1, iteration: 2
Loop 1, iteration: 3
Loop 1, iteration: 4
Loop 2, iteration: 0
Loop 2, iteration: 1
Loop 2, iteration: 2
Loop 2, iteration: 3
</code></pre>
</blockquote>
<h2 id="remember"><a class="header" href="#remember">Remember</a></h2>
<p>The general rule of thumb is to use <code>for</code> loops when you know the bounds of your iteration (from number <code>X</code> to number <code>Y</code>, or <code>run 10 times</code>) and use <code>while</code> loops when the number of iterations of the loop is unknown to you. If you follow this rule of thumb you whould have very vew problems with loops.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<p>What is an enum? An enum essentially is just a number under the hood, but one with very interesting properties. It can be thought of as a <strong>tag</strong> which can only have one of a selected number of tags. Here is an example:</p>
<pre><code class="language-ft">use Core.print

enum MyEnum:
    TAG1, TAG2, TAG3;

def main():
    MyEnum my_enum = MyEnum.TAG1;

    if my_enum == MyEnum.TAG1:
        print("is TAG1\n");
    else if my_enum == MyEnum.TAG2:
        print("is TAG2\n");
    else if my_enum == MyEnum.TAG3:
        print("is TAG3\n");
    else:
        print("This code path is actually impossible to reach, no matter which value 'my_enum' has!\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<p>is TAG1</p>
</blockquote>
<p>As you can see, defining our own <code>enum</code> is very simple. We write the <code>enum</code> keyword followed by the name of the enum, similar how we define the name of data. As you can see, the name <code>MyEnum</code> is now a new user-defined type, which is the reason why a variable (<code>my_enum</code>) can be declared to be of type <code>MyEnum</code>. Then, we write a colon <code>:</code> to signify the "body" of the enum, where we define all the values the enum could have. And then, we define the tag names the enum could have. Each tag name has to be unique within the same enum, so we would not be allowed to define <code>TAG1</code> twice. Tags are comma-separated and Flint sees everything as a tag until it finds a semicolon <code>;</code>.</p>
<p>If you dont like the horizontal layout, you can also define an enum like so:</p>
<pre><code class="language-ft">enum MyEnum:
    TAG1, // Some description of TAG1
    TAG2, // Some description of TAG2
    TAG3; // Some description of TAG3
</code></pre>
<h2 id="comparing-enums"><a class="header" href="#comparing-enums">Comparing Enums</a></h2>
<p>Enums are considered equal if their type <em>and</em> their tag match. Here is an example of what this means:</p>
<pre><code class="language-ft">use Core.print

enum Enum1:
    TAG1, TAG2, TAG3;

enum Enum2:
    TAG1, TAG2, TAG3;

def main():
    Enum1 e1 = Enum1.TAG1;

    if e1 == Enum2.TAG1:
        print("is Enum2.TAG1!\n");
</code></pre>
<p>This program will print this error to the console:</p>
<blockquote>
<pre><code>Parse Error at main.ft:12:8
└──┬┤E0000│
9  │ def main():
12 │ »   if e1 == Enum2.TAG1:
┌──┴────────┘
├─ Type mismatch in binary expression. Cannot apply operation == on types:
│   ├─ LHS type: Enum1
│   └─ RHS type: Enum2
└─ Have you considered using explicit casting of types?
</code></pre>
</blockquote>
<h2 id="enums-with-functions"><a class="header" href="#enums-with-functions">Enums with functions</a></h2>
<p>Enums are considered to be non-complex data types in Flint, even though they are user-defined. So, we can easily pass in enums to a function and return them from it:</p>
<pre><code class="language-ft">use Core.print

enum ComparisonResult:
    BIGGER, SMALLER, EQUAL;

def compare(i32 x, i32 y) -&gt; ComparisonResult:
    if x &gt; y:
        return ComparisonResult.BIGGER;
    else if y &lt; x:
        return ComparisonResult.SMALLER;
    else:
        return ComparisonResult.EQUAL;

def main():
    ComparisonResult result = compare(10, 5);
    if result == ComparisonResult.BIGGER:
        print("is bigger\n");
    else if result == ComparisonResult.SMALLER:
        print("is smaller\n");
    else if result == ComparisonResult.EQUAL:
        print("is equal\n");
    else:
        print("Impossible to reach code block\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>is bigger
</code></pre>
</blockquote>
<p>The above program is very useless, though, as it would be much more efficient to remove the enum entirely and just use the comparisons directly. But these examples are not always meant to be absolutely useful, they are there to get a point across. So, we can not only return enums from a function but also pass them to a function. Lets dive into a bit bigger example now.</p>
<pre><code class="language-ft">use Core.print

enum Operation:
    PLUS, MINUS, MULT, DIV;

data NumberContainer:
    i32 a;
    f32 b;
    u64 c;
    NumberContainer(a, b, c);

def apply_operation(mut NumberContainer container, Operation op, f32 value):
    if op == Operation.PLUS:
        container.(a, b, c) += (i32(value), value, u64(value));
    else if op == Operation.MINUS:
        container.(a, b, c) -= (i32(value), value, u64(value));
    else if op == Operation.MULT:
        container.(a, b, c) *= (i32(value), value, u64(value));
    else if op == Operation.DIV:
        container.(a, b, c) /= (i32(value), value, u64(value));

def main():
    NumberContainer container = NumberContainer(-10, 22.5, u64(889));
    print($"container.(a, b, c) = ({container.a}, {container.b}, {container.c})\n");

    apply_operation(container, Operation.PLUS, 3.4);
    print($"container.(a, b, c) = ({container.a}, {container.b}, {container.c})\n");

    apply_operation(container, Operation.MULT, 7.2);
    print($"container.(a, b, c) = ({container.a}, {container.b}, {container.c})\n");

    apply_operation(container, Operation.MINUS, 22.1);
    print($"container.(a, b, c) = ({container.a}, {container.b}, {container.c})\n");

    apply_operation(container, Operation.DIV, 6.9);
    print($"container.(a, b, c) = ({container.a}, {container.b}, {container.c})\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>container.(a, b, c) = (-10, 22.5, 889)
container.(a, b, c) = (-7, 25.9, 892)
container.(a, b, c) = (-49, 186.479996, 6244)
container.(a, b, c) = (-71, 164.37999, 6222)
container.(a, b, c) = (-11, 23.823187, 1037)
</code></pre>
</blockquote>
<h2 id="casting-enums-to-strings"><a class="header" href="#casting-enums-to-strings">Casting Enums to Strings</a></h2>
<p>You can effortlessly cast any enum value to a string. The string value then will directly be the enum tag. It's really quite simple. Here is an example of it:</p>
<pre><code class="language-ft">use Core.print

enum MyEnum:
	VAL1, VAL2, VAL3;

def main():
	MyEnum e = MyEnum.VAL1;
	print($"e = {e}, id = {i32(e)}\n");
	e = MyEnum.VAL2;
	print($"e = {e}, id = {i32(e)}\n");
	e = MyEnum.VAL3;
	print($"e = {e}, id = {i32(e)}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>e = VAL1, id = 0
e = VAL2, id = 1
e = VAL3, id = 2
</code></pre>
</blockquote>
<p>As you can see, casting enums to strings works quite effortlessly in Flint, just like casting them to integers.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="switch"><a class="header" href="#switch">Switch</a></h1>
<h2 id="switch-statements"><a class="header" href="#switch-statements">Switch Statements</a></h2>
<p>Switch statements are actually pretty easy to understand once you grasped if chains. <code>switch</code> statements are primarily used for pattern-matching purposes or for cases where you have a limited selection of possible values, like with enums, where you only have the possibilities of each tag.</p>
<p>Let's actually re-write the same example from the previous example, but without the if chain we now use a switch statement:</p>
<pre><code class="language-ft">use Core.print

enum ComparisonResult:
    BIGGER, SMALLER, EQUAL;

def compare(i32 x, i32 y) -&gt; ComparisonResult:
    if x &gt; y:
        return ComparisonResult.BIGGER;
    else if y &lt; x:
        return ComparisonResult.SMALLER;
    else:
        return ComparisonResult.EQUAL;

def main():
    ComparisonResult result = compare(10, 5);
    switch result:
        BIGGER:
            print("is bigger\n");
        SMALLER:
            print("is smaller\n");
        EQUAL:
            print("is equal\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>is bigger
</code></pre>
</blockquote>
<p>If you know switch statements from other languages you may wonder "where are the <code>case</code> and the <code>break</code> keywords?". Flint does not have such keywords, at least in this context (<code>break</code> still exists for loops, just like <code>continue</code>). In most languages like C, switch statements undergo a default <strong>fallthrough</strong> and you must manually <strong>opt out</strong> of the fallthrough behaviour, which is extremely error prone. But if you dont know what <strong>fallthrough</strong> is, lets discuss this first.</p>
<h2 id="fallthrough"><a class="header" href="#fallthrough">Fallthrough</a></h2>
<p>Fallthrough is the act of executing multiple switch branches after another. We best look at this example from C:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

typedef enum { VAL1, VAL2, VAL3 } MyEnum;

int main() {
    MyEnum e = VAL1; // In C you dont need to write MyEnum.VAL1
    switch (e) {
        case VAL1:
            printf("is val1\n");
        case VAL2:
            printf("is val2\n");
        case VAL3:
            printf("is val3\n");
    }
}
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>is val1
is val2
is val3
</code></pre>
</blockquote>
<p>And now you might think...what? Why does this happen? This is <strong>fallthrough</strong> in action. The first case that got matched is actually the <code>case VAL1</code> line. Falltrough means that "the execution falls through (to the next branch)". So, after the <code>case VAL1</code> branch, the <code>case VAL2</code> branch got executed and the <code>case VAL3</code> branch afterwards. If we want the intuitively expected behaviour, where each branch is executed with no fallthrough, we would need to add the <code>break</code> keyword to <em>every</em> single branch:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

typedef enum { VAL1, VAL2, VAL3 } MyEnum;

int main() {
    MyEnum e = VAL1; // In C you dont need to write MyEnum.VAL1
    switch (e) {
        case VAL1:
            printf("is val1\n");
            break;
        case VAL2:
            printf("is val2\n");
            break;
        case VAL3:
            printf("is val3\n");
            break;
    }
}
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>is val1
</code></pre>
</blockquote>
<p>And this is the behaviour that Flint has by default. In Flint, falltrough is not opt-out but rather opt-in. We don't actually have a keyword for this but rather an annotation. Here is an example of it:</p>
<div class="warning">
<p>Flint does not support annotations (<code>#...</code>) yet</p>
<p>The below example will not compile, as Flint does not support annotations yet. So, at this moment in time it is not possible to have a fallthrough-behaviour in a Flint switch.</p>
</div>
<pre><code class="language-ft">use Core.print

enum MyEnum:
    VAL1, VAL2, VAL3;

def main():
    MyEnum e = MyEnum.VAL1;
    switch e:
        #fallthrough
        VAL1:
            print("is val1\n");
        VAL2:
            print("is val2\n");
        VAL3:
            print("is val3\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>is val1
is val2
</code></pre>
</blockquote>
<p>It actually is not clear yet if there will exist an explicit keyword for the fallthrough. We did not want to use the <code>continue</code> keyword for this purpose, because what happens if you have a switch statement within a for loop, would the for loop continue or would the switch branch fall through? Flint tries to avoid ambiguity at all cost at all places, so we are pretty careful with its design.</p>
<h2 id="switch-expressions"><a class="header" href="#switch-expressions">Switch Expressions</a></h2>
<p>A switch, however, can not only exist as a statement but as an expression too. Instead of executing an arbitrary block of code, each switch branch needs to be an explicit expression now, marked with the arrow <code>-&gt;</code> syntax. Have a look:</p>
<pre><code class="language-ft">use Core.print

enum MyEnum:
    VAL1, VAL2, VAL3;

def main():
    MyEnum e = MyEnum.VAL1;
    i32 result = switch e:
        VAL1 -&gt; 1;
        VAL2 -&gt; 2;
        VAL3 -&gt; 4;
    print($"result = {result}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>result = 1
</code></pre>
</blockquote>
<p>For switch expressions, there does not exist such thing as a fallthrough, because there are no code blocks executed but only single expressions. Yes, a literal like <code>1</code> is an expression too, but you could write function calls or even another nested switch expression on the place of that literal.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>In the previous chapter, we learned the control flow to control the flow of our program's execution in Flint through conditions, if statements and loops. Now that we have a solid foundation in the basics, let's talk about how to organize and reuse code in our programs. In this chapter, we will explore the fundamental concepts of functions in Flint.</p>
<h2 id="what-are-functions"><a class="header" href="#what-are-functions">What are Functions?</a></h2>
<p>A function is a reusable block of code that performs a specific task. Functions make programs easier to read, debug, and maintain by encapsulating logic into manageable pieces. Think of a function like a recipe. You can reuse it to "cook" something multiple times without rewriting the steps every single time. Similar to how loops have made our life simpler for repetition, functions make our life easier when we want to do a similar operation at multiple places in our code.</p>
<h2 id="why-are-functions-important"><a class="header" href="#why-are-functions-important">Why are Functions Important?</a></h2>
<p>Functions are essential in programming because they allow you to:</p>
<ul>
<li>Break down complex programs into smaller, more manageable pieces</li>
<li>Reuse code to avoid duplication and reduce errors</li>
<li>Write more modular and maintainable code</li>
</ul>
<p>In this chapter, we will learn about the basics of functions in Flint, including how to declare and call functions, how to pass arguments to functions, and how to return values from functions. We will also explore how to use functions to write more efficient and effective programs.</p>
<h2 id="what-to-expect-2"><a class="header" href="#what-to-expect-2">What to Expect</a></h2>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Declaring and calling functions</li>
<li>Passing arguments to functions</li>
<li>Returning values from functions</li>
<li>Function scope and lifetime</li>
<li>Best practices for working with functions</li>
</ul>
<p>By the end of this chapter, you will have a solid understanding of functions in Flint, and you will be able to use them to write more organized and reusable code. Let's get started!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="what-is-a-function"><a class="header" href="#what-is-a-function">What is a Function?</a></h1>
<p>A function is a reusable block of code designed to perform a specific task. We have been working this entire time with a function, actually, the <code>main</code> function. No, actually we have worked with multiple functions, because we also have called the <code>print</code> function <em>a lot</em> throughout the last few chapters. Now is the time you are going to understand what a function really is and how to define your own ones!</p>
<p>Okay, lets start very simple first. We define a function with the <code>def</code> keyword (define). Following by the <code>def</code> keyword we put the name of the function and parenthesis <code>()</code>. Note that the names <code>main</code>, <code>_main</code> and all names starting with <code>__flint_</code> are disallowed by the compiler. Without these few exceptions, you can name your functions how you like.</p>
<pre><code class="language-ft">use Core.print

def say_hello():
    print("Hello, World!\n");

def main():
    say_hello();
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>Hello, World!
</code></pre>
</blockquote>
<p>There is a <strong><em>very</em></strong> important note to make here. The ordering of definition does not matter in Flint. So, you can define a function like <code>say_hello</code> <em>after</em> the <code>main</code> function and still be able to use it within the main function:</p>
<pre><code class="language-ft">use Core.print

def main():
    say_hello();

def say_hello():
    print("Hello, World!\n");
</code></pre>
<p>This is an important part of how Flint works. The reasons to why this works like this are a bit more technical, but just note that ordering of definition does not matter in Flint, which will make your life a lot easier in the future, trust me.</p>
<p>While this function is cool, its not very useful yet because it will always only print the same message to the console. To make functions more useful we will need to add ways to pass data into and recieve data from functions. So, lets jump to the next chapter and discuss arguments.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="adding-parameters"><a class="header" href="#adding-parameters">Adding Parameters</a></h1>
<p>Parameters are "variables" of functions which you can change when calling the function, enabling the function to operate on different data, making them far more versatile and useful. Lets start with an example where we add a single parameter to a function:</p>
<pre><code class="language-ft">use Core.print

def greet(str name):
    print($"Hello, {name}!\n");

def main():
    greet("Alice");
    greet("Bob");
</code></pre>
<p>Its a pretty simple example, but you can clearly see that we insert the paramter <code>name</code> into the string interpolation when calling the <code>print</code> function. So, the above example will print these lines to the console:</p>
<blockquote>
<pre><code>Hello, Alice!
Hello, Bob!
</code></pre>
</blockquote>
<h2 id="multiple-parameters"><a class="header" href="#multiple-parameters">Multiple Parameters</a></h2>
<p>Functions can have multiple parameters. To declare multiple parameters, we separate them by commas, like this:</p>
<pre><code class="language-ft">use Core.print

def add_two_numbers(i32 a, i32 b):
    print($"The sum is {a + b}.\n");

def main():
    add_two_numbers(5, 7);
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>The sum is 12.
</code></pre>
</blockquote>
<h2 id="important-notes"><a class="header" href="#important-notes">Important Notes:</a></h2>
<ol>
<li>The <strong>type</strong> of each argument matters. For example, if <code>a</code> and <code>b</code> are declared as <code>i32</code>, you cannot pass values of any other type, like <code>f32</code> or <code>u32</code>.</li>
<li>The order of arguments also matters. Always pass values in the same order as declared in the function.</li>
</ol>
<p>There is an important difference between <code>parameters</code> and <code>arguments</code>, alltough this difference is only conceptual. When we define a function the "variables" that are defined, like <code>a</code> and <code>b</code> in our <code>add_two_numbers</code> function are called <strong>parameters</strong> of the function.</p>
<p>When we call a function and pass in values, like the values <code>5</code> and <code>7</code> for the call <code>add_two_numbers(5, 7)</code>, they are called <strong>arguments</strong> of the function call. This difference is important in later chapters, as they are not interchangably used by this wiki. So, if we talk about arguments we talk about <em>calls</em> and if we talk about parameters we talk about function <em>definitions</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="returning-values"><a class="header" href="#returning-values">Returning Values</a></h1>
<p>Imagine you want a function to calculate the area of a rectangle. It’s not enough to just print the result – you may need to use the value elsewhere in your program. This is where returning values is essential to any program. Here is a small and easy example of a function which returns a value:</p>
<pre><code class="language-ft">def get_greeting() -&gt; str:
    return "Hello, Flint!\n";
</code></pre>
<p>As you can see, you need to declare a return type after the <code>-&gt;</code> symbol in the function header. Also, if you want to return a value from within the function you need to use the <code>return</code> keyword followed by the value you want to return.</p>
<p>So, here is the full example:</p>
<pre><code class="language-ft">use Core.print

def get_greeting() -&gt; str:
    return "Hello, Flint!\n";

def main():
    str greeting = get_greeting();
    print(greeting);
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>Hello, Flint!
</code></pre>
</blockquote>
<h2 id="adding-parameters-and-returning-values"><a class="header" href="#adding-parameters-and-returning-values">Adding Parameters and Returning Values</a></h2>
<p>Now let’s combine function parameters with a return value:</p>
<pre><code class="language-ft">use Core.print

def add_two_numbers(i32 a, i32 b) -&gt; i32:
    return a + b;

def main():
    i32 result = add_two_numbers(10, 20);
    print($"The result is {result}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>The result is 30
</code></pre>
</blockquote>
<p>Okay, now that you know how to pass in arguments to a function and return values from the function lets move to the next chapter, <em>recursion</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="recursion"><a class="header" href="#recursion">Recursion</a></h1>
<p>First of all, what even is recursion? Recursion is the act of calling a function from within itself forming a "chain" of calls. Lets start with the most simple example of a recursive function, calculating a fibonacci number:</p>
<pre><code class="language-ft">use Core.print

def fib(i32 n) -&gt; i32:
    if n &lt;= 1:
        return n;
    else:
        return fib(n - 1) + fib(n - 2);

def main():
    for i := 0; i &lt; 10; i++:
        i32 fib_i = fib(i);
        print($"fib({i}) = {fib_i}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>fib(0) = 0
fib(1) = 1
fib(2) = 1
fib(3) = 2
fib(4) = 3
fib(5) = 5
fib(6) = 8
fib(7) = 13
fib(8) = 21
fib(9) = 34
</code></pre>
</blockquote>
<p>If you don't know what the fibonacci sequence is, you really should look into it, its beautiful. But, back to the recursive function, as there is a <em>lot</em> to unpack here. The loop itself is <strong>not</strong> part of the recursive function, only the content of the <code>fib</code> function make it recursive, because the function calls itself through the calls <code>fib(n - 1)</code> and <code>fib(n - 2)</code>.</p>
<p>To understand the function you must first understand the fibonacci sequence itself. Basically, every number is the sum of the last two numbers that came before it with the exceptions of <code>1</code> and <code>0</code> as they are just the number itself. This exception is handled in the recursive function through the <code>if</code> branch. So, <code>fib(2)</code> is the sum of the last two numbers, <code>0</code> and <code>1</code>, so its result is <code>1</code> and so on and so forth.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="returning-multiple-values"><a class="header" href="#returning-multiple-values">Returning Multiple Values</a></h1>
<p>Sometimes, a single return value isn’t enough. For instance, a function might need to calculate both the area and perimeter of a rectangle. Flint allows functions to return multiple values at once, without limiting the number of maximum returned values.</p>
<h2 id="how-to-return-multiple-values"><a class="header" href="#how-to-return-multiple-values">How to Return Multiple Values</a></h2>
<p>To return multiple values we use parentheses <code>()</code> to group multiple values in the return statement and also use parentheses for declaring the return types:</p>
<pre><code class="language-ft">def calculate_rectangle(i32 length, i32 width) -&gt; (i32, i32):
    i32 area = length * width;
    i32 perimeter = 2 * (length + width);
    return (area, perimeter);
</code></pre>
<p>As you can see, this function now returns a <code>group</code>. Groups are a special concept of Flint, but you will learn about them more in the next chapter. Its important that you separate the values you want to return with commas inside the parenthesis like shown above.</p>
<h2 id="accessing-multiple-return-values"><a class="header" href="#accessing-multiple-return-values">Accessing Multiple Return Values</a></h2>
<p>To recieve the values from a function which returns multiple values we also need to use a group to assign them.</p>
<pre><code class="language-ft">use Core.print

def calculate_rectangle(i32 length, i32 width) -&gt; (i32, i32):
    i32 area = length * width;
    i32 perimeter = 2 * (length + width);
    return (area, perimeter);

def main():
    (area, perimeter) := calculate_rectangle(5, 3);
    print($"Area: {area}, Perimeter: {perimeter}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>Area: 15, Perimeter: 16
</code></pre>
</blockquote>
<p>As you can see, we can declare two variables at once using inferred typing (<code>:=</code>) from the call <code>calculate_rectangle</code>. Both <code>area</code> and <code>perimeter</code> are of type <code>i32</code> now and then we can print their values.</p>
<h2 id="important-note"><a class="header" href="#important-note">Important Note</a></h2>
<p>The types and order of the group must match the function’s return type.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="groups"><a class="header" href="#groups">Groups</a></h1>
<p>What are groups? Groups are a new concept of Flint which allow us to do operations on multiple variables at the same time. You will see the potential and the integration of groups into other systems of Flint in later chapters, but even now groups are very powerful.</p>
<p>You have already seen groups in action when returning multiple values from a function, but that was just the beginning.</p>
<h2 id="variable-swaps"><a class="header" href="#variable-swaps">Variable Swaps</a></h2>
<p>Lets kick things off with a very simple example: variable swaps. For that we define a simple small program which prints the values of two <code>i32</code> variables:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32 x = 1;
    i32 y = 5;
    print($"x = {x}, y = {y}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>x = 1, y = 5
</code></pre>
</blockquote>
<p>Okay, now lets say that we want to swap the values of <code>x</code> and <code>y</code>. With most languages, better said with almost every language, you would need to create a temporary value to swap values:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32 x = 1;
    i32 y = 5;
    print($"x = {x}, y = {y}\n");

    i32 temp = x;
    x = y;
    y = temp;
    print($"x = {x}, y = {y}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>x = 1, y = 5
x = 5, y = 1
</code></pre>
</blockquote>
<p>The temp variable exists because once we store the value of <code>y</code> into <code>x</code>, everything that was stored in <code>x</code> before is lost, so we need a way to keep track of the old value of <code>x</code> to be able to store it in <code>y</code>.</p>
<p>Okay, but now do groups help us with that? Have a look at the same example, but this time utilizing groups:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32 x = 1;
    i32 y = 5;
    print($"x = {x}, y = {y}\n");

    (x, y) = (y, x);
    print($"x = {x}, y = {y}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>x = 1, y = 5
x = 5, y = 1
</code></pre>
</blockquote>
<p>Lets unpack what this group even says. We know that the right hand side of any assignment is always executed before assigning the value. So, we create a group and load the values of <code>y</code> and <code>x</code> into it. Note that a group does not create any temporary values or "store" the values anywhere. When we load <code>y</code> and <code>x</code> in the group <code>(y, x)</code> these values exist only in the cache of the CPU, they are not really stored annywhere else.</p>
<p>So then, when we assign <code>(y, x)</code> which holds the values <code>(5, 1)</code> to the group of <code>(x, y)</code> this is called a <strong>grouped assignment</strong> as we assign multiple values of multiple variables at the same time. So, we store the values of <code>(5, 1)</code> on the group <code>(x, y)</code> which means that we store <code>5</code> in <code>x</code> and <code>1</code> in <code>y</code>, swapping the values of the variables.</p>
<h2 id="swapping-multiple-variables"><a class="header" href="#swapping-multiple-variables">Swapping Multiple Variables</a></h2>
<p>It is very important to note that groups have <strong>no</strong> runtime footprint, they exist in order for us to be able to "tell" the compiler that we want stuff to happen at the same time. But groups are not limited to only 2 values, we can have as many values in a group as we would like. Here an example:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32 a = 1;
    i32 b = 2;
    i32 c = 3;
    i32 d = 4;
    print($"a = {a}, b = {b}, c = {c}, d = {d}\n");

    (a, b, c, d) = (c, d, a, b);
    print($"a = {a}, b = {b}, c = {c}, d = {d}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>a = 1, b = 2, c = 3, d = 4
a = 3, b = 4, c = 1, d = 2
</code></pre>
</blockquote>
<p>So, we assigned <code>c</code> to <code>a</code>, <code>d</code> to <code>b</code>, <code>a</code> to <code>c</code> and <code>b</code> to <code>d</code>. Try around a bit, you can also assign all values to <code>a</code> in the same group:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32 a = 1;
    i32 b = 2;
    i32 c = 3;
    i32 d = 4;
    print($"a = {a}, b = {b}, c = {c}, d = {d}\n");

    (a, b, c, d) = (a, a, a, a);
    print($"a = {a}, b = {b}, c = {c}, d = {d}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>a = 1, b = 2, c = 3, d = 4
a = 1, b = 1, c = 1, d = 1
</code></pre>
</blockquote>
<p>Funny thing is, you can also assign to the same variable twice inside a single group, because the order of operation is strictly defined. So, you can write this without a problem:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32 a = 3;
    print($"a = {a}\n");

    (a, a, a) = (a + 1, a + 2, a + 3);
    print($"a = {a}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>a = 3
a = 6
</code></pre>
</blockquote>
<p>As you can see, this does not yield to an error...why? Because there is no reason why it should. The compiler should, however, print a warning describing the behaviour in this case. The right hand side of the grouped assignment is executed before any values are stored on the left, so first the group is evalueated to be <code>(4, 5, 6)</code> and then it is assigned to the group of <code>(a, a, a)</code>. Grouped assignments work from left to right, so we first assign <code>a</code> to be <code>4</code>, then to be <code>5</code> and finally to be <code>6</code>. The evaluation of a group is completely separate from the assignment of it, so this is a well-defined situation, and <code>a</code> will have its rightmost value from the group assigned to it.</p>
<p>But groups will become very important later on, and they will become more and more powerful regarding <code>data</code> and <code>SIMD</code>. If you know what this means, great. If not, don't worry, as all of these concepts will be explained in later chapters and <code>data</code> is actually the next chapter to follow!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="data"><a class="header" href="#data">Data</a></h1>
<p>Flint brings along a completely new paradigm called <strong>Data-Object Convergence Paradigm (DOCP)</strong>. What this paradigm means and what it brings to the table will be discussed thoroughly in later chapters, but <code>data</code> is very important for it. Unlike other paradigms like OOP (Object-Oriented Programming) you cannot attach functions to data. In Flint, data is exactly just that: data. Nothing more, nothing less.</p>
<p>Data is used to "pack" values together and to make them reusable, just like functions made instructions and operations reusable, <code>data</code> modules make working with similar data much simpler.</p>
<p>But lets not focus on the theory so much but dive into declaring and using data right away.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="declaring-data-modules"><a class="header" href="#declaring-data-modules">Declaring Data Modules</a></h1>
<p>To define a new <code>data</code> module in Flint, we use the <code>data</code> keyword. A <code>data</code> module consists of <strong>fields</strong> (the pieces of information it holds) and a constructor (in which order to initialize those fields).</p>
<h2 id="basic-syntax"><a class="header" href="#basic-syntax">Basic Syntax:</a></h2>
<pre><code class="language-ft">data Vector2:
    i32 x;
    i32 y;
    Vector2(x, y);
</code></pre>
<p>As you can see, we start with the <code>data</code> keyword, followed with the name of our data module, in this case <code>Vector2</code>. Then, we start by defining the <strong>fields</strong> of the data one by one. At the end of the definition we write the <strong>Constructor</strong> of the data, which specifies in which order we need to pass in the field values when creating the data module. This might seem weird for now, but keep going, things will become more clear as we go.</p>
<p>The important thing to note is that we now have a new type at our disposal: <code>Vector2</code>. Defining data modules creates new types, so you now can create variables of type <code>Vector2</code>, just like we did before with <code>i32</code>. Here is a small example:</p>
<pre><code class="language-ft">data Vector2:
    i32 x;
    i32 y;
    Vector2(x, y);

def main():
    Vector2 v2 = Vector2(10, 20);
</code></pre>
<p>As you can see, the variable <code>v2</code> now is of type <code>Vector2</code> and we create it by calling the constructor of the data type with <code>Vector2(10, 20)</code>. This constructor sets <code>x</code> to <code>10</code> and <code>y</code> to <code>20</code>. But when we try to run this program we cannot see anything in the console, we need a way to print the values the data fields have.</p>
<h2 id="field-access"><a class="header" href="#field-access">Field Access</a></h2>
<p>When we want to access a field of our data variable, for example the <code>x</code> field of our <code>v2</code> varaible we need to do so through a <strong>field access</strong>. There exists a symbol for this very use case: The <code>.</code> (dot). It's best if you just look at the example for yourself:</p>
<pre><code class="language-ft">use Core.print

data Vector2:
    i32 x;
    i32 y;
    Vector2(x, y);

def main():
    Vector2 v2 = Vector2(10, 20);
    print($"v2.x = {v2.x}, v2.y = {v2.y}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>v2.x = 10, v2.y = 20
</code></pre>
</blockquote>
<p>As you can see, the variable of type <code>Vector2</code> now contains two fields of type <code>i32</code>, <code>x</code> and <code>y</code> and we can access and modify themthrough the <code>.</code> access.</p>
<h2 id="field-assignment"><a class="header" href="#field-assignment">Field Assignment</a></h2>
<p>In the next example we will store a new value only on the <code>x</code> field of data:</p>
<pre><code class="language-ft">use Core.print

data Vector2:
    i32 x;
    i32 y;
    Vector2(x, y);

def main():
    Vector2 v2 = Vector2(10, 20);
    print($"v2.x = {v2.x}, v2.y = {v2.y}\n");
    v2.x = 15;
    print($"v2.x = {v2.x}, v2.y = {v2.y}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>v2.x = 10, v2.y = 20
v2.x = 15, v2.y = 20
</code></pre>
</blockquote>
<p>As you can see, we can only modify a single field of data without touching the other fields. But thats not all... now let's talk about how groups can make our life with data easier.</p>
<h2 id="grouped-field-access"><a class="header" href="#grouped-field-access">Grouped Field Access</a></h2>
<p>You already know what a group is, but groups can also be extremely powerful for data manipulation. Grouped field accesses are a new concept of Flint, together with groups. The idea is simple: Access and modify multiple fields of data at the same time. Here is a small example showcasing it:</p>
<pre><code class="language-ft">use Core.print

data Vector3:
    f32 x;
    f32 y;
    f32 z;
    Vector3(x, y, z);

def main():
    Vector3 v3 = Vector3(1.0, 2.0, 3.0);
    (x, y, z) := v3.(x, y, z);
    print($"(x, y, z) = ({x}, {y}, {z})\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>(x, y, z) = (1, 2, 3)
</code></pre>
</blockquote>
<p>The syntax is pretty easy, actually. First, we say the variable we want to access the fields in: <code>v3.</code> and then we open a left paren <code>(</code> and within the parenthesis we describe the <em>names</em> of the fields we want to access and we wrap it up with the closing paren <code>)</code>. You could see that this line: <code>v3.(x, y, z)</code> is actually the same as writing this: <code>(v3.x, v3.y, v3.z)</code> but it's much neater to look at and to write. Why should we write <code>v3.</code> three times when we only want to access multiple fields of it?</p>
<h2 id="grouped-field-assignment"><a class="header" href="#grouped-field-assignment">Grouped Field Assignment</a></h2>
<p>Just like we can access mutliple fields of data at once, we can also assign multiple values of it at the same time. Here is an example of that:</p>
<pre><code class="language-ft">use Core.print

data Vector3:
    f32 x;
    f32 y;
    f32 z;
    Vector3(x, y, z);

def main():
    Vector3 v3 = Vector3(1.0, 2.0, 3.0);
    print($"v3.(x, y, z) = ({v3.x}, {v3.y}, {v3.z})\n");
    v3.(x, y, z) = v3.(z, x, y);
    print($"v3.(x, y, z) = ({v3.x}, {v3.y}, {v3.z})\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>v3.(x, y, z) = (1, 2, 3)
v3.(x, y, z) = (3, 1, 2)
</code></pre>
</blockquote>
<p>As you can see, we did the same thing as we did for variable swaps, but now on data fields. This is only possible through the concoept of groups. A very important thing is that groups themselves have a type. If you would write out the type of the access <code>v3.(x, y, z)</code> it would look like this: <code>(f32, f32, f32)</code>. As you can see, this looks exactly like the return type of a function when we would return multiple values, enforcing the connection that a function returning multiple values returns a group of values.</p>
<p>But swaps are not all we can do, we can for example calculate multiple values at once, for example incrementing all fields of the vector <code>v3</code> by one:</p>
<pre><code class="language-ft">use Core.print

data Vector3:
    f32 x;
    f32 y;
    f32 z;
    Vector3(x, y, z);

def main():
    Vector3 v3 = Vector3(1.0, 2.0, 3.0);
    print($"v3.(x, y, z) = ({v3.x}, {v3.y}, {v3.z})\n");

    v3.(x, y, z) += (1.0, 1.0, 1.0);
    print($"v3.(x, y, z) = ({v3.x}, {v3.y}, {v3.z})\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>v3.(x, y, z) = (1, 2, 3)
v3.(x, y, z) = (2, 3, 4)
</code></pre>
</blockquote>
<p>As you can clearly see, all fields of the variable <code>v3</code> have been incremented by one. By combining data with groups you can create very powerful and still compact code.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="default-values"><a class="header" href="#default-values">Default Values</a></h1>
<div class="warning">
<p>Default values do not work yet.</p>
<p>While default values are able to be parsed in the data definition itself, the constructor of data cannot be called with the <code>_</code> operator to create a default instance of the type.</p>
</div>
<p>Sometimes, you may want a field to have a <strong>default value</strong>. In Flint, this is done by assigning a value to the field directly in its declaration.</p>
<pre><code class="language-ft">data MyData:
    i32 x = 5;
    i32 y;
    MyData(x, y);
</code></pre>
<p>When instantiating this data module, you can use <code>_</code> to signify using the default value for a field. The <code>_</code> operator is <strong>only</strong> used in <em>unused</em> or <em>default</em> contexts, nowhere else. So, if you see a single <code>_</code> in Flint you can <strong>always</strong> assume that either something is unused or set to a default.</p>
<pre><code class="language-ft">use Core.print

data MyData:
    i32 x = 5;
    i32 y;
    MyData(x, y);

def main():
    MyData d = MyData(_, 20); // x uses the default value of 5
    print($"d.x = {d.x}, d.y = {d.y}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>d.(x, y) = (5, 20)
</code></pre>
</blockquote>
<p>If <strong>all</strong> fields of a given data type have default values set the constructor of the data type can be called with a single <code>_</code> operator to singify to <strong>set every field to its default value</strong>. But, note that this only works if <strong>every</strong> field in the given data type has a default value set. If one of them has no default value set this will fail.</p>
<pre><code class="language-ft">use Core.print

data MyData:
    i32 x = 5;
    i32 y = 7;
    MyData(x, y);

def main():
    MyData d = MyData(_);
    print($"d.(x, y) = ({d.x}, {d.y})\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>d.(x, y) = (5, 7)
</code></pre>
</blockquote>
<ol>
<li>Default values simplify initialization but are optional.</li>
<li>If a field doesn’t have a default value, using <code>_</code> will result in a <strong>compiler error</strong></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="nested-data"><a class="header" href="#nested-data">Nested Data</a></h1>
<p>Data modules can include other data modules as fields. This allows you to create nested structures, which are common in real-world programming. Here is an example of this concept in action:</p>
<pre><code class="language-ft">use Core.print

data Point:
    i32 x;
    i32 y;
    Point(x, y);

data Rectangle:
    Point top_left;
    Point bottom_right;
    Rectangle(top_left, bottom_right);

def main():
    Point p1 = Point(0, 0);
    Point p2 = Point(10, 10);
    Rectangle rect = Rectangle(p1, p2);
    print($"rect.top_left.(x, y) = ({rect.top_left.x}, {rect.top_left.y})\n");
    print($"rect.bottom_right.(x, y) = ({rect.bottom_right.x}, {rect.bottom_right.y})\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>rect.top_left.(x, y) = (0, 0)
rect.bottom_right.(x, y) = (10, 10)
</code></pre>
</blockquote>
<p>Note that storing the <code>Point</code> variables in the <code>rect</code> variable through its constructor creates <em>copies</em> of the points. In other languages this would need to be done manually, but in Flint its automatic. So, when changing <code>p1</code> and <code>p2</code> after the creation of <code>rect</code>, the <code>top_left</code> and <code>bottom_right</code> fields will not be changed:</p>
<pre><code class="language-ft">use Core.print

data Point:
    i32 x;
    i32 y;
    Point(x, y);

data Rectangle:
    Point top_left;
    Point bottom_right;
    Rectangle(top_left, bottom_right);

def main():
    Point p1 = Point(0, 0);
    Point p2 = Point(10, 10);
    Rectangle rect = Rectangle(p1, p2);

    print($"p1.(x, y) = ({p1.x}, {p1.y})\n");
    print($"p2.(x, y) = ({p2.x}, {p2.y})\n");
    print($"rect.top_left.(x, y) = ({rect.top_left.x}, {rect.top_left.y})\n");
    print($"rect.bottom_right.(x, y) = ({rect.bottom_right.x}, {rect.bottom_right.y})\n");

    print("\n");
    p1.(x, y) = (4, 5);
    p2.(x, y) = (22, 33);

    print($"p1.(x, y) = ({p1.x}, {p1.y})\n");
    print($"p2.(x, y) = ({p2.x}, {p2.y})\n");
    print($"rect.top_left.(x, y) = ({rect.top_left.x}, {rect.top_left.y})\n");
    print($"rect.bottom_right.(x, y) = ({rect.bottom_right.x}, {rect.bottom_right.y})\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>p1.(x, y) = (0, 0)
p2.(x, y) = (10, 10)
rect.top_left.(x, y) = (0, 0)
rect.bottom_right.(x, y) = (10, 10)

p1.(x, y) = (4, 5)
p2.(x, y) = (22, 33)
rect.top_left.(x, y) = (0, 0)
rect.bottom_right.(x, y) = (10, 10)
</code></pre>
</blockquote>
<h2 id="what-about-circular-references"><a class="header" href="#what-about-circular-references">What about Circular References?</a></h2>
<div class="warning">
<p>The below example actually compiles, but its impossible to run usefully.</p>
<p>Data is actually allowed to contain itself, but its impossible to initialize, as Flint has noo concept of <strong>nullpointers</strong> or <strong>null</strong> like other languages have. Flint has its optionals <code>T?</code> instead, but you will learn about them in a much later chapter. For now, just be aware that it <em>is</em> possible to create circular data, but you cannot initialize it.</p>
</div>
<p>Flint does not allow a data module to reference itself directly or indirectly like showcased below:</p>
<pre><code class="language-ft">data Node:
    i32 value;
    Node next;
    Node(value, next);

def main():
    return;
</code></pre>
<p>While this may seem restrictive, it is pretty easy explained why this does not work: If you try to initialize a new variable of type <code>Node</code> you need to provide both its fields for the initializer. The <code>value</code> is fine, you can just pass in a literal, but what about the second field, <code>next</code>? To create a new variable of type <code>Node</code> you need an already existent variable of the same type to pass into, and thats impossible.</p>
<h2 id="hint"><a class="header" href="#hint">Hint:</a></h2>
<p>Flint can handle circular references with the help of the <strong>optional type (<code>?</code>)</strong>. These convert a reference to a wek reference in circular context's, thus enabling the use of data in of itself, for example for <strong>linked lists</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="using-data-in-functions"><a class="header" href="#using-data-in-functions">Using Data in Functions</a></h1>
<p>Data modules can be passed to and returned from functions, enabling you to manipulate them easily.</p>
<pre><code class="language-ft">use Core.print

data Point:
    i32 x;
    i32 y;
    Point(x, y);

def print_point(Point p):
    print($"Point(x: {p.x}, y: {p.y})\n");

def main():
    Point p = Point(3, 4);
    print_point(p);
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>Point(x: 3, y: 4)
</code></pre>
</blockquote>
<h2 id="mutability-and-immutability"><a class="header" href="#mutability-and-immutability">Mutability and Immutability</a></h2>
<p>Okay, but what if we want to modify the point in a function? Lets look at an example:</p>
<pre><code class="language-ft">use Core.print

data Point:
    i32 x;
    i32 y;
    Point(x, y);

def increment_by(Point p, i32 value):
    p.(x, y) += (value, value);

def main():
    Point p = Point(3, 4);
    increment_by(p, 3);
    print($"Point(x: {p.x}, y: {p.y})\n");
</code></pre>
<p>If you try to compile this program you will actually get a compile error:</p>
<blockquote>
<pre><code>Parse Error at main.ft:9:5
└─┬┤E0000│
8 │ def increment_by(Point p, i32 value):
9 │ »   p.(x, y) += (value, value);
┌─┴─────┘
└─ Variable 'p' is marked as 'const' and cannot be modified!
</code></pre>
</blockquote>
<p>But why is that? For this to explain we actually need to talk about <strong>mutability</strong> for a bit. Mutability is the ability to mutate (change) variables. Up until now this has not been a problem yet, because Flint actually has clear mutability rules:</p>
<ul>
<li>Local variables declared within a scope are always <strong>mutable</strong> except explicitely made immutable</li>
<li>Function parameters are always <strong>immutable</strong> except explicitely made mutable</li>
</ul>
<p>Flint has two keywords for this very reason: <code>mut</code> and <code>const</code>. You can use <code>const</code> when declaring a variable in a scope to make the variable constant, thus not-changable after its declaration and you can use <code>mut</code> to make parameters of functions explicitely mutable. Note that putting <code>const</code> in front of a function parameter has no effect, as its const annyway, same as putting <code>mut</code> in front of a variable declaration, as variables are mutable annyway.</p>
<p>So, to fix our little compile error we need to change the signature of our function a bit:</p>
<pre><code class="language-ft">use Core.print

data Point:
    i32 x;
    i32 y;
    Point(x, y);

def increment_by(mut Point p, i32 value):
    p.(x, y) += (value, value);

def main():
    Point p = Point(3, 4);
    increment_by(p, 3);
    print($"Point(x: {p.x}, y: {p.y})\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>Point(x: 6, y: 7)
</code></pre>
</blockquote>
<p>As you can see, the functions signature of the <code>increment_by</code> function now explicitely states that its parameter is a mutable one. This means that we can only pass in mutable <code>Point</code> variables to it when calling it. So, this example:</p>
<pre><code class="language-ft">use Core.print

data Point:
    i32 x;
    i32 y;
    Point(x, y);

def increment_by(mut Point p, i32 value):
    p.(x, y) += (value, value);

def main():
    const Point p = Point(3, 4);
    increment_by(p, 3);
    print($"Point(x: {p.x}, y: {p.y})\n");
</code></pre>
<p>will not compile again. Because now we have declared <code>p</code> to be immutable, but we try to pass it to to the call <code>increment_by</code> which expects a mutable <code>Point</code> argument, so we have a type mismatch here, because when we made <code>p</code> immutable it would be wrong if it could be modified by a function. We get this compile error:</p>
<blockquote>
<pre><code>Parse Error at main.ft:13:18
└──┬┤E0000│
11 │ def main():
13 │ »   increment_by(p, 3);
┌──┴──────────────────┘
└─ Variable 'p' is marked as 'const' and cannot be modified!
</code></pre>
</blockquote>
<h2 id="returning-data-from-functions"><a class="header" href="#returning-data-from-functions">Returning Data from Functions</a></h2>
<p>You can also return data from functions, for example when creating them inside the function.</p>
<pre><code class="language-ft">use Core.print

data Point:
    i32 x;
    i32 y;
    Point(x, y);

def create_point(i32 x, i32 y) -&gt; Point:
    return Point(x, y);

def main():
    Point p = create_point(5, 7);
    print($"Point(x: {p.x}, y: {p.y})\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>Point(x: 5, y: 7)
</code></pre>
</blockquote>
<p>By using functions with data, you can create and manipulate complex structures easily.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="tuples"><a class="header" href="#tuples">Tuples</a></h1>
<p>Tuples are a really nice concept in general and they exist in pretty much every language. But first, lets talk about what tuples even are and maybe take a closer look at <code>data</code> in general.
In Flint, <code>data</code> is essentially just a <code>struct</code> from C, if you have seen that one before. So when we write</p>
<pre><code class="language-ft">data Vector2:
    i32 x;
    i32 y;
    Vector2(x, y);
</code></pre>
<p>we could do something similar in C which would look like this:</p>
<pre><code class="language-c">typedef struct {
    int x;
    int y;
} Vector2;
</code></pre>
<p>Under the hood, both Flint's <code>data</code> module and C's <code>struct</code> are exactly the same. They are just collections of data packed into a struct. So, what are tuples then? Well, tuples are collections of data, packed into a struct too. But with one big difference: They are <strong>anonymous</strong>, meaning that they dont get a <em>type name</em>, but when looking at the lowest level, <code>data</code> and tuples are actually extremely similar.</p>
<h2 id="defining-tuples"><a class="header" href="#defining-tuples">Defining Tuples</a></h2>
<p>Because tuples are anonymous they are not defined like data modules are. They are rather defined inline, like a variable, for example. So here is the basic syntax to define a tuple in Flint:</p>
<pre><code class="language-ft">def main():
    data&lt;i32, f32, str&gt; tuple = (3, 2.2, "hello!");
</code></pre>
<p>Do you recognize the <code>data</code> keyword? This is the reason i told you earlier that tuples and data are actually pretty much the same thing, but one is named while the other one is not. This connection and the understanding of it is crucial to understand tuples, because otherwise you now would be really confused by the syntax: "Wait, what does the <code>data</code> keyword have to do with tuples here?".</p>
<p>And here we have another very nice property of Flint's groups – they enable seemless interoperability between different types! As you can see, the "initializer" for a tuple is actually a group with the same types as the tuple itself. So, the "initializer" of a tuple could also be a grouped field access (d.(a, b, c)` or a group from multiple variables or anything else you can do with groups. As you can see, groups form a whole layer of making syntax easier for a lot of systems.</p>
<h2 id="tuple-access"><a class="header" href="#tuple-access">Tuple Access</a></h2>
<p>But what about assigning and accessing the specific fields of a tuple? With <code>data</code> modules, we can access the fields directly by the name of the field (<code>v2.x</code>) but tuples are anonymous, meaning that neither the type itself has a name, nor do the fields.</p>
<p>In Flint, we access the fields of a tuple by its "index". The first field of the tuple above is of type <code>i32</code>, the second of type <code>f32</code> and the third of type <code>str</code>, so we can use the fixed ordering as our accessing syntax right away. But we cannot do <code>tuple.0</code>, <code>tuple.1</code> etc directly because that would look pretty weird to have an integer literal directly. Here is an example of how to access the single values of a tuple in Flint:</p>
<pre><code class="language-ft">use Core.print

def main():
    data&lt;i32, f32, str&gt; tuple = (3, 2.2, "hello!");

    i32 first = tuple.$0;
    f32 second = tuple.$1;
    str third = tuple.$2;

    print($"first = {first}\n");
    print($"second = {second}\n");
    print($"third = \"{third}\"\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>first = 3
second = 2.2
third = "hello!"
</code></pre>
</blockquote>
<p>As you can clearly see, we access the elements of the tuple with the <code>.&lt;span class="katex"&gt;&lt;span class="katex-html" aria-hidden="true"&gt;&lt;span class="base"&gt;&lt;span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"&gt;&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.10903em;"&gt;N&lt;/span&gt;&lt;span class="mord"&gt;‘&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.03588em;"&gt;sy&lt;/span&gt;&lt;span class="mord mathnormal"&gt;n&lt;/span&gt;&lt;span class="mord mathnormal"&gt;t&lt;/span&gt;&lt;span class="mord mathnormal"&gt;a&lt;/span&gt;&lt;span class="mord mathnormal"&gt;x&lt;/span&gt;&lt;span class="mpunct"&gt;,&lt;/span&gt;&lt;span class="mspace" style="margin-right:0.1667em;"&gt;&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.02691em;"&gt;w&lt;/span&gt;&lt;span class="mord mathnormal"&gt;h&lt;/span&gt;&lt;span class="mord mathnormal"&gt;ere&lt;/span&gt;&lt;span class="mord"&gt;‘&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.10903em;"&gt;N&lt;/span&gt;&lt;span class="mord"&gt;‘&lt;/span&gt;&lt;span class="mord mathnormal"&gt;i&lt;/span&gt;&lt;span class="mord mathnormal"&gt;s&lt;/span&gt;&lt;span class="mord mathnormal"&gt;t&lt;/span&gt;&lt;span class="mord mathnormal"&gt;h&lt;/span&gt;&lt;span class="mord mathnormal"&gt;e&lt;/span&gt;&lt;span class="mord mathnormal"&gt;in&lt;/span&gt;&lt;span class="mord mathnormal"&gt;d&lt;/span&gt;&lt;span class="mord mathnormal"&gt;e&lt;/span&gt;&lt;span class="mord mathnormal"&gt;x&lt;/span&gt;&lt;span class="mord mathnormal"&gt;o&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.10764em;"&gt;f&lt;/span&gt;&lt;span class="mord mathnormal"&gt;t&lt;/span&gt;&lt;span class="mord mathnormal"&gt;h&lt;/span&gt;&lt;span class="mord mathnormal"&gt;ee&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.01968em;"&gt;l&lt;/span&gt;&lt;span class="mord mathnormal"&gt;e&lt;/span&gt;&lt;span class="mord mathnormal"&gt;m&lt;/span&gt;&lt;span class="mord mathnormal"&gt;e&lt;/span&gt;&lt;span class="mord mathnormal"&gt;n&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.02691em;"&gt;tw&lt;/span&gt;&lt;span class="mord mathnormal"&gt;e&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.02691em;"&gt;w&lt;/span&gt;&lt;span class="mord mathnormal"&gt;an&lt;/span&gt;&lt;span class="mord mathnormal"&gt;tt&lt;/span&gt;&lt;span class="mord mathnormal"&gt;o&lt;/span&gt;&lt;span class="mord mathnormal"&gt;a&lt;/span&gt;&lt;span class="mord mathnormal"&gt;ccess&lt;/span&gt;&lt;span class="mord"&gt;.&lt;/span&gt;&lt;span class="mord mathnormal"&gt;L&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.03148em;"&gt;ik&lt;/span&gt;&lt;span class="mord mathnormal"&gt;e&lt;/span&gt;&lt;span class="mord mathnormal"&gt;a&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.02691em;"&gt;lw&lt;/span&gt;&lt;span class="mord mathnormal"&gt;a&lt;/span&gt;&lt;span class="mord mathnormal"&gt;ys&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.10764em;"&gt;f&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.02778em;"&gt;or&lt;/span&gt;&lt;span class="mord mathnormal"&gt;in&lt;/span&gt;&lt;span class="mord mathnormal"&gt;d&lt;/span&gt;&lt;span class="mord mathnormal"&gt;i&lt;/span&gt;&lt;span class="mord mathnormal"&gt;ces&lt;/span&gt;&lt;span class="mpunct"&gt;,&lt;/span&gt;&lt;span class="mspace" style="margin-right:0.1667em;"&gt;&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.02691em;"&gt;w&lt;/span&gt;&lt;span class="mord mathnormal"&gt;es&lt;/span&gt;&lt;span class="mord mathnormal"&gt;t&lt;/span&gt;&lt;span class="mord mathnormal"&gt;a&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.02778em;"&gt;r&lt;/span&gt;&lt;span class="mord mathnormal"&gt;t&lt;/span&gt;&lt;span class="mord mathnormal"&gt;a&lt;/span&gt;&lt;span class="mord mathnormal"&gt;t&lt;/span&gt;&lt;span class="mord"&gt;0&lt;/span&gt;&lt;span class="mord mathnormal"&gt;a&lt;/span&gt;&lt;span class="mord mathnormal"&gt;s&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.01968em;"&gt;Fl&lt;/span&gt;&lt;span class="mord mathnormal"&gt;in&lt;/span&gt;&lt;span class="mord mathnormal"&gt;t&lt;/span&gt;&lt;span class="mord mathnormal"&gt;ha&lt;/span&gt;&lt;span class="mord mathnormal"&gt;szero&lt;/span&gt;&lt;span class="mspace" style="margin-right:0.2222em;"&gt;&lt;/span&gt;&lt;span class="mbin"&gt;−&lt;/span&gt;&lt;span class="mspace" style="margin-right:0.2222em;"&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="base"&gt;&lt;span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"&gt;&lt;/span&gt;&lt;span class="mord mathnormal"&gt;ba&lt;/span&gt;&lt;span class="mord mathnormal"&gt;se&lt;/span&gt;&lt;span class="mord mathnormal"&gt;d&lt;/span&gt;&lt;span class="mord mathnormal"&gt;in&lt;/span&gt;&lt;span class="mord mathnormal"&gt;d&lt;/span&gt;&lt;span class="mord mathnormal"&gt;e&lt;/span&gt;&lt;span class="mord mathnormal"&gt;x&lt;/span&gt;&lt;span class="mord mathnormal"&gt;in&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.03588em;"&gt;g&lt;/span&gt;&lt;span class="mord"&gt;.&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.07847em;"&gt;I&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.10764em;"&gt;f&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.02691em;"&gt;w&lt;/span&gt;&lt;span class="mord mathnormal"&gt;e&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.02691em;"&gt;w&lt;/span&gt;&lt;span class="mord mathnormal"&gt;o&lt;/span&gt;&lt;span class="mord mathnormal"&gt;u&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.01968em;"&gt;l&lt;/span&gt;&lt;span class="mord mathnormal"&gt;d&lt;/span&gt;&lt;span class="mord mathnormal"&gt;t&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.03588em;"&gt;ry&lt;/span&gt;&lt;span class="mord mathnormal"&gt;t&lt;/span&gt;&lt;span class="mord mathnormal"&gt;o&lt;/span&gt;&lt;span class="mord mathnormal"&gt;a&lt;/span&gt;&lt;span class="mord mathnormal"&gt;ccess&lt;/span&gt;&lt;span class="mord mathnormal"&gt;an&lt;/span&gt;&lt;span class="mord mathnormal"&gt;e&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.01968em;"&gt;l&lt;/span&gt;&lt;span class="mord mathnormal"&gt;e&lt;/span&gt;&lt;span class="mord mathnormal"&gt;m&lt;/span&gt;&lt;span class="mord mathnormal"&gt;e&lt;/span&gt;&lt;span class="mord mathnormal"&gt;n&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.02691em;"&gt;tw&lt;/span&gt;&lt;span class="mord mathnormal"&gt;hi&lt;/span&gt;&lt;span class="mord mathnormal"&gt;c&lt;/span&gt;&lt;span class="mord mathnormal"&gt;hi&lt;/span&gt;&lt;span class="mord mathnormal"&gt;so&lt;/span&gt;&lt;span class="mord mathnormal"&gt;u&lt;/span&gt;&lt;span class="mord mathnormal"&gt;t&lt;/span&gt;&lt;span class="mord mathnormal"&gt;o&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.10764em;"&gt;f&lt;/span&gt;&lt;span class="mord mathnormal"&gt;b&lt;/span&gt;&lt;span class="mord mathnormal"&gt;o&lt;/span&gt;&lt;span class="mord mathnormal"&gt;u&lt;/span&gt;&lt;span class="mord mathnormal"&gt;n&lt;/span&gt;&lt;span class="mord mathnormal"&gt;d&lt;/span&gt;&lt;span class="mord mathnormal"&gt;s&lt;/span&gt;&lt;span class="mpunct"&gt;,&lt;/span&gt;&lt;span class="mspace" style="margin-right:0.1667em;"&gt;&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.01968em;"&gt;l&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.03148em;"&gt;ik&lt;/span&gt;&lt;span class="mord mathnormal"&gt;e&lt;/span&gt;&lt;span class="mord"&gt;‘.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;3</code> in our case we would actually get a compile error:</p>
<pre><code class="language-ft">def main():
    data&lt;i32, f32, str&gt; tuple = (3, 2.2, "hello!");
    i32 x = tuple.$3;
</code></pre>
<p>This program will produce this compile error:</p>
<blockquote>
<pre><code>Parse Error at main.ft:3:19
└─┬┤E0000│
1 │ def main():
3 │ »   i32 x = tuple.$3;
┌─┴───────────────────┘
├─ Out of bounds access on tuple type 'data&lt;i32, f32, str&gt;'
└─ The tuples last element is '$2'
</code></pre>
</blockquote>
<h2 id="tuple-assignment"><a class="header" href="#tuple-assignment">Tuple Assignment</a></h2>
<p>Just like we can access elements from a tuple, we can also assign new values to the elements of a tuple. Here is a simple example of this in action:</p>
<pre><code class="language-ft">use Core.print

def main():
    data&lt;i32, f32, str&gt; tuple = (3, 2.2, "hello!");

    tuple.$0 = 7;
    tuple.$1 = 4.7;
    tuple.$2 = "yes";

    print($"first = {tuple.$0}\n");
    print($"second = {tuple.$1}\n");
    print($"third = \"{tuple.$2}\"\n");
</code></pre>
<p>This program prints these lines to the console:</p>
<blockquote>
<pre><code>first = 7
second = 4.7
third = "yes"
</code></pre>
</blockquote>
<h2 id="grouped-accesses-and-assignments"><a class="header" href="#grouped-accesses-and-assignments">Grouped accesses and assignments</a></h2>
<p>Just like with "normal" data you can do grouped field accesses and assignments with tuples too. Instead of the field names you need to write the field ids again:</p>
<pre><code class="language-ft">use Core.print

def main():
    data&lt;i32, f32, str&gt; tuple = (3, 2.2, "hello!");
    tuple.($0, $1, $2) = (7, 4.7, "yes");
    print($"tuple.($0, $1, $2) = ({tuple.$0}, {tuple.$1}, \"{tuple.$2}\")\n");
</code></pre>
<p>This program prints this line to the console:</p>
<blockquote>
<pre><code>tuple.($0, $1, $2) = (7, 4.7, "yes")
</code></pre>
</blockquote>
<h2 id="addition-information"><a class="header" href="#addition-information">Addition Information</a></h2>
<h3 id="multi-type-overlap"><a class="header" href="#multi-type-overlap">Multi-Type overlap</a></h3>
<p>Tuples are not allowed to be defined as a type that can be represented with a mutli-type instead. So, this example for example:</p>
<pre><code class="language-ft">use Core.print

def main():
    data&lt;i32, i32, i32&gt; tuple = (1, 1, 1);
    tuple.($0, $1, $2) = (2, 3, 4);
    print($"tuple.($0, $1, $2) = ({tuple.$0}, {tuple.$1}, {tuple.$2})\n");
</code></pre>
<p>will throw a this compilation error:</p>
<blockquote>
<pre><code>Parse Error at main.ft:4:5
└─┬┤E0000│
3 │ def main():
4 │ »   data&lt;i32, i32, i32&gt; tuple = (1, 1, 1);
┌─┴─────┘
└─ Cannot create a tuple type which overlaps with a multi-type
</code></pre>
</blockquote>
<h3 id="returning-tuples"><a class="header" href="#returning-tuples">Returning Tuples</a></h3>
<p>It is not allowed to return a tuple from a function if its the only return type of said function. You need to return a group instead and this is compile-time enforced. The exact reason to why this is required will be clarified in the chapter aboout Flint's error handling. So, this code:</p>
<pre><code class="language-ft">use Core.print

def get_tuple(i32 a, f32 b, str c) -&gt; data&lt;i32, f32, str&gt;:
    data&lt;i32, f32, str&gt; tuple = (a, b, c);
    return tuple;

def main():
    data&lt;i32, f32, str&gt; tuple = get_tuple(1, 4.7, "hello");
    print($"tuple.($0, $1, $2) = ({tuple.$0}, {tuple.$1}, {tuple.$2})\n");
</code></pre>
<p>will produce this compile error telling you to use a group of type <code>(i32, f32, str)</code> instead as the return type of the function.</p>
<blockquote>
<pre><code>Parse Error at main.ft:3:39
└─┬┤E0000│
3 │ def get_tuple(i32 a, f32 b, str c) -&gt; data&lt;i32, f32, str&gt;:
┌─┴───────────────────────────────────────┘
├─ Functions cannot return a tuple type directly.
└─ If you want to return multiple values, change the return type to '(i32, f32, str)'
</code></pre>
</blockquote>
<p>So, instead of trying to return a tuple, you need to return a group instead:</p>
<pre><code class="language-ft">use Core.print

def get_tuple(i32 a, f32 b, str c) -&gt; (i32, f32, str):
    return (a, b, c);

def main():
    data&lt;i32, f32, str&gt; tuple = get_tuple(1, 4.7, "hello");
    print($"tuple.($0, $1, $2) = ({tuple.$0}, {tuple.$1}, {tuple.$2})\n");
</code></pre>
<p>annyway. This program will print this line to the console:</p>
<blockquote>
<pre><code>tuple.($0, $1, $2) = (1, 4.7, hello)
</code></pre>
</blockquote>
<h3 id="passing-tuples-to-functions"><a class="header" href="#passing-tuples-to-functions">Passing Tuples to functions</a></h3>
<p>Tuples can also be passed to functions as any value can:</p>
<pre><code class="language-ft">use Core.print

def print_tuple(data&lt;i32, f32, str&gt; tuple):
    print($"tuple.(i32, f32, str) = ({tuple.$0}, {tuple.$1}, \"{tuple.$2}\")\n");

def main():
    data&lt;i32, f32, str&gt; tuple = (1, 2.2, "three");
    print_tuple(tuple);
</code></pre>
<p>This program will print this message to the console:</p>
<blockquote>
<pre><code>tuple.(i32, f32, str) = (1, 2.2, "three")
</code></pre>
</blockquote>
<p>Also, like "normal" data, tuples can be passed to functions as mutable references:</p>
<pre><code class="language-ft">use Core.print

def change_tuple(mut data&lt;i32, f32, str&gt; tuple):
    tuple.($0, $1, $2) = (2, 3.3, "four");

def main():
    data&lt;i32, f32, str&gt; tuple = (1, 2.2, "three");
    print($"tuple.(i32, f32, str) = ({tuple.$0}, {tuple.$1}, \"{tuple.$2}\")\n");

    change_tuple(tuple);
    print($"tuple.(i32, f32, str) = ({tuple.$0}, {tuple.$1}, \"{tuple.$2}\")\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>tuple.(i32, f32, str) = (1, 2.2, "three")
tuple.(i32, f32, str) = (2, 3.3, "four")
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="multi-types"><a class="header" href="#multi-types">Multi-Types</a></h1>
<p>Multi-Types are essentially vectorized variants of <em>some</em> primitive types to increase both readability, performance (SIMD) and ease of use for vectorized math operations and much more. Here is an example of how multi-types work:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32x3 v3 = (1, 2, 3);
    print($"v3.(x, y, z) = ({v3.x}, {v3.y}, {v3.z})\n");
    v3.(x, y, z) = (4, 5, 6);
    print($"v3 = {v3}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>v3.(x, y, z) = (1, 2, 3)
v3 = (4, 5, 6)
</code></pre>
</blockquote>
<p>As you can see, the 3-width i32 multi-type has the "fields" of x, y and z, each being of type <code>i32</code>. There exist several multi-types in Flint today:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Type</th><th style="text-align: center">Element Type</th><th style="text-align: center">Vector Size</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>u8x2</code></td><td style="text-align: center"><code>u8</code></td><td style="text-align: center">2</td></tr>
<tr><td style="text-align: center"><code>u8x3</code></td><td style="text-align: center"><code>u8</code></td><td style="text-align: center">3</td></tr>
<tr><td style="text-align: center"><code>u8x4</code></td><td style="text-align: center"><code>u8</code></td><td style="text-align: center">4</td></tr>
<tr><td style="text-align: center"><code>u8x8</code></td><td style="text-align: center"><code>u8</code></td><td style="text-align: center">8</td></tr>
<tr><td style="text-align: center"><hr></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><code>i32x2</code></td><td style="text-align: center"><code>i32</code></td><td style="text-align: center">2</td></tr>
<tr><td style="text-align: center"><code>i32x3</code></td><td style="text-align: center"><code>i32</code></td><td style="text-align: center">3</td></tr>
<tr><td style="text-align: center"><code>i32x4</code></td><td style="text-align: center"><code>i32</code></td><td style="text-align: center">4</td></tr>
<tr><td style="text-align: center"><code>i32x8</code></td><td style="text-align: center"><code>i32</code></td><td style="text-align: center">8</td></tr>
<tr><td style="text-align: center"><hr></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><code>i64x2</code></td><td style="text-align: center"><code>i64</code></td><td style="text-align: center">2</td></tr>
<tr><td style="text-align: center"><code>i64x3</code></td><td style="text-align: center"><code>i64</code></td><td style="text-align: center">3</td></tr>
<tr><td style="text-align: center"><code>i64x4</code></td><td style="text-align: center"><code>i64</code></td><td style="text-align: center">4</td></tr>
<tr><td style="text-align: center"><hr></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><code>f32x2</code></td><td style="text-align: center"><code>f32</code></td><td style="text-align: center">2</td></tr>
<tr><td style="text-align: center"><code>f32x3</code></td><td style="text-align: center"><code>f32</code></td><td style="text-align: center">3</td></tr>
<tr><td style="text-align: center"><code>f32x4</code></td><td style="text-align: center"><code>f32</code></td><td style="text-align: center">4</td></tr>
<tr><td style="text-align: center"><code>f32x8</code></td><td style="text-align: center"><code>f32</code></td><td style="text-align: center">8</td></tr>
<tr><td style="text-align: center"><hr></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><code>f64x2</code></td><td style="text-align: center"><code>f64</code></td><td style="text-align: center">2</td></tr>
<tr><td style="text-align: center"><code>f64x3</code></td><td style="text-align: center"><code>f64</code></td><td style="text-align: center">3</td></tr>
<tr><td style="text-align: center"><code>f64x4</code></td><td style="text-align: center"><code>f64</code></td><td style="text-align: center">4</td></tr>
<tr><td style="text-align: center"><hr></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><code>bool8</code></td><td style="text-align: center"><code>bool</code></td><td style="text-align: center">8</td></tr>
</tbody></table>
</div>
<p>All multi-types with less than width 4 can be accessed via the field names directly, while all multi-types which are bigger, like <code>i32x8</code> can only be accessed with the same index-based accesser like tuples through the <code>.$N</code> syntax. This is also the reason why tuples needed to be explained before multi-types. There actually exist several aliases for each component, each being unambiguous. Below is a table describing which "field" names exist for each component:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Width</th><th style="text-align: center">Field 0</th><th style="text-align: center">Field 1</th><th style="text-align: center">Field 2</th><th style="text-align: center">Field 3</th></tr></thead><tbody>
<tr><td style="text-align: center">2</td><td style="text-align: center"><code>u</code></td><td style="text-align: center"><code>v</code></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><hr></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">2</td><td style="text-align: center"><code>i</code></td><td style="text-align: center"><code>j</code></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: center"><code>i</code></td><td style="text-align: center"><code>j</code></td><td style="text-align: center"><code>k</code></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: center"><code>i</code></td><td style="text-align: center"><code>j</code></td><td style="text-align: center"><code>k</code></td><td style="text-align: center"><code>l</code></td></tr>
<tr><td style="text-align: center"><hr></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">2</td><td style="text-align: center"><code>x</code></td><td style="text-align: center"><code>y</code></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: center"><code>x</code></td><td style="text-align: center"><code>y</code></td><td style="text-align: center"><code>z</code></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: center"><code>x</code></td><td style="text-align: center"><code>y</code></td><td style="text-align: center"><code>z</code></td><td style="text-align: center"><code>w</code></td></tr>
<tr><td style="text-align: center"><hr></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">2</td><td style="text-align: center"><code>s</code></td><td style="text-align: center"><code>t</code></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: center"><code>s</code></td><td style="text-align: center"><code>t</code></td><td style="text-align: center"><code>p</code></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: center"><code>s</code></td><td style="text-align: center"><code>t</code></td><td style="text-align: center"><code>p</code></td><td style="text-align: center"><code>q</code></td></tr>
<tr><td style="text-align: center"><hr></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: center"><code>r</code></td><td style="text-align: center"><code>g</code></td><td style="text-align: center"><code>b</code></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: center"><code>r</code></td><td style="text-align: center"><code>g</code></td><td style="text-align: center"><code>b</code></td><td style="text-align: center"><code>a</code></td></tr>
</tbody></table>
</div>
<p>As you can see, different widths have different aliases for the coordinates. The <code>u</code> and <code>v</code> aliases for vectors of size two, for example, are used a lot in UV-coordinate systems, and <code>rgba</code> just starts at three components, because just having <code>r</code> and <code>g</code> for two-sized vectors does not make any sense.</p>
<p>The names are designed in a way that eliminates collisions in every case. The same letter will always be used for the same coordinate. If we would have added <code>uvw</code>, like it nomally would be, the <code>w</code> would collide with the fourth field in <code>xyzw</code>, so now it would be ambiguous whether <code>w</code> is the third or fourth field of a multi-type without knowing the type upfront, which would be really bad UX. So, instead we opted to design the names in a way that completely eliminates ambiguity.</p>
<h2 id="multi-types-with-functions"><a class="header" href="#multi-types-with-functions">Multi-Types with Functions</a></h2>
<p>But let's move on to functions, because multi-types can be returned from functions too, unlike tuples. So, we can very well define a function like this:</p>
<pre><code class="language-ft">use Core.print

def get_vec_2(i32 x, i32 y) -&gt; i32x2:
    return (x, y);

def main():
    (x, y) := get_vec_2(10, 20);
    print($"(x, y) = ({x}, {y})\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>(x, y) = (10, 20)
</code></pre>
</blockquote>
<p>As you can see, interoperability between mutli-types and groups <em>just works</em>. <strong>Groups</strong> are Flint's "type interoperability layer". You can pack multiple single values into a group, then store it in a tuple. Or access multiple fields of a tuple and store it in a multi-type etc. Groups are the real "middle-ground" of Flint's type system, because you can return a group of <code>(i32, i32)</code> and still store it in a mutli-type or you can return a <code>i32x2</code> and store it in a group. The group, however, could also be a grouped assignment of a tuple, so you could very well write <code>tuple.($0, $2) = get_vec_2(10, 20);</code> and store the <code>i32x2</code> return value on the <code>$0</code> and <code>$2</code> fields of the tuple, because its a grouped assignment and groups are natively meant to be interoperable with Flint's other types.</p>
<h2 id="multi-type-arithmetic"><a class="header" href="#multi-type-arithmetic">Multi-Type Arithmetic</a></h2>
<p>Multi-types are <strong>primitive types</strong> in Flint, which means that they have first-class arithmetic support. The mutli-type variant of any type supports the same arithmetic operations as its underlying type. Here is one example of this:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32x4 v4_1 = (1, 2, 3, 4);
    i32x4 v4_2 = (5, 6, 7, 8);
    i32x4 sum = v4_1 + v4_2;
    print($"sum = {sum}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>sum = (6, 8, 10, 12)
</code></pre>
</blockquote>
<h2 id="important-note-1"><a class="header" href="#important-note-1">Important Note</a></h2>
<p>When using Multi-Types you gain free access to SIMD instructions. SIMD means <strong>S</strong>ingle <strong>I</strong>nstruction, <strong>M</strong>ultiple <strong>D</strong>ata and its a very optimized way of doing operations, such as additions. For example, adding two <code>i32x4</code> variables is just as fast as adding a single <code>i32</code> variable. This makes Flint's multi-types both extremely fast and extremely easy to use.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="groups-2"><a class="header" href="#groups-2">Groups 2</a></h1>
<p>Until now everything you know about groups is to use them when returning multiple values from a function or when swapping variables. But there is so much more we can do with them. You have learned in the last few chapters that we can define data types, tuples and use multi-types to store multiple values at once. But what if we would want to <em>modify</em> multiple values at once? You may have guessed it from the name of this chapter, but we again can use groups for that!</p>
<h2 id="grouped-access"><a class="header" href="#grouped-access">Grouped Access</a></h2>
<p>Let's start with the most simple form of groups in combination with <code>data</code>: The grouped field access. You have already learned that you can write <code>mydata.field</code> to access a value stored inside the data variable. To access multiple fields at once, we can use the <strong>grouped access</strong> operator <code>.()</code> for that. Here is a small example:</p>
<pre><code class="language-ft">use Core.print

data MyData:
    i32 x;
    f32 y;
    u64 z;
    MyData(x, y, z);

def main():
    MyData m = MyData(10, 3.5, u64(100));
    i32 x = 0;
    f32 y = 0.0;
    u64 z = 0;
    (x, y, z) = m.(x, y, z);
    print($"(x, y, z) = ({x}, {y}, {z})\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>(x, y, z) = (10, 3.5, 100)
</code></pre>
</blockquote>
<p>It's actually quite simple. Normally we would write <code>m.x</code> to access a single field and if we would want to create a group of three accesses we would then write <code>(m.x, m.y, m.z)</code>. Just like in math, we can see that the <code>m.</code> is common in each case so we end up with <code>m.(x, y, z)</code>. This is the absolute minimal syntax we could write to access multiple values of the data at once.</p>
<h2 id="grouped-assignment"><a class="header" href="#grouped-assignment">Grouped Assignment</a></h2>
<p>Just like we can access multiple values with the grouped access operator, we can use the same operator for grouped field assignments on data variables. Just like we would write <code>m.x = 5</code> we can express it as a group too:</p>
<pre><code class="language-ft">use Core.print

data MyData:
    i32 x;
    f32 y;
    u64 z;
    MyData(x, y, z);

def main():
    MyData m = MyData(10, 3.5, u64(100));
    m.(x, y, z) = (3, 3.14, u64(33));
    print($"m.(x, y, z) = ({m.x}, {m.y}, {m.z})\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>m.(x, y, z) = (3, 3.14, 33)
</code></pre>
</blockquote>
<p>Once you understood the concepts of groups all together, it really becomes second nature writing them. Because normally, without groups, the above code would look like this:</p>
<pre><code class="language-ft">use Core.print

data MyData:
    i32 x;
    f32 y;
    u64 z;
    MyData(x, y, z);

def main():
    MyData m = MyData(10, 3.5, u64(100));
    m.x = 3;
    m.y = 3.14;
    m.z = u64(33);
    print($"m.(x, y, z) = ({m.x}, {m.y}, {m.z})\n");
</code></pre>
<p>This program will, again, write this line to the console:</p>
<blockquote>
<pre><code>m.(x, y, z) = (3, 3.14, 33)
</code></pre>
</blockquote>
<p>Groups make code both more readable and more consise too. But we are far not done yet.</p>
<h2 id="grouped-field-value-swaps"><a class="header" href="#grouped-field-value-swaps">Grouped Field Value Swaps</a></h2>
<p>Just like with direct variable values, we can swap values inside of fields too with one another. But for this example we will use multi-types instead because, yes, you can use grouped accesses / assignments on multitypes (and tuples) too:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32x4 vec4 = (10, 20, 30, 40);
    vec4.(r, g, b, a) = vec4.(b, r, a, g);
    print($"vec4 = {vec4}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>vec4 = (30, 10, 40, 20)
</code></pre>
</blockquote>
<h2 id="vectorization"><a class="header" href="#vectorization">Vectorization</a></h2>
<p>As you can see, in Flint it is trivial to essentially write vector operations in one line of code. A <strong>vector</strong> operation essentially means that the same operation is applied to multiple different values. Each of those values is called a <strong>scalar</strong>. A sclar operation would be something like <code>vec4.x += 5</code> for example, or even a simple addition like <code>x + y</code> is considered a scalar operation, because it's an operation applied to two scalar (single) values. Vector operations are pretty common in modern processors, essentially every single processor has support for them. Most modern AMD and Intel CPUs have the capability to perform vector operations up to at least <code>256 bits</code>, sometimes even higher.</p>
<p>If you want to know more about this topic you need to wait until the later <a href="beginners_guide/5_data/">SIMD</a> chapter. But essentially this means that the CPU has a 256 bit "budget" for vectorized operations, which means it can apply the same operation on 4 <code>64 bit</code> values or 8 <code>32 bit</code> values at the same time. And these are also the types supported by multi-types: <code>i64x4</code> and <code>i32x8</code>. So, everything you need to know is that the vectorized code has the potential to run as much as <strong>8x faster</strong> than scalar code. So, if you can, <em>always</em> use Flint's multi-types.</p>
<p>But to pull the circle back to grouped operations. Whenever possible, Flint will try to vectorize grouped operations. So, not only are they less to write and easier to read but they also have the potential to be magnitudes faster than scalar operations. Just note that it is <em>not guaranteed</em> for a grouped operation to compile down to a vectorized operation, but it <em>is guaranteed</em> for multi-types.</p>
<h2 id="set-like-comparisons"><a class="header" href="#set-like-comparisons">Set-Like Comparisons</a></h2>
<p>The last thing we talk about for now about groups is that groups can be used for set-like comparisons. It is <em>really</em> powerful and once you have seen and understood it you may see it being appliccable in many different cases. Stay with me for this one, it will be great. First we need to discuss a simple example to get to the point why set-like comparisons are even needed or wanted, so here is a small example (without using the set-like comparisons):</p>
<pre><code class="language-ft">use Core.print

def print_cmp(i32 x):
    if x == 1 or x == 2 or x == 3:
        print($"{x} is 1, 2 or 3\n");

    if x != 1 and x != 2 and x != 3:
        print($"{x} is not 1, 2 or 3\n");

def main():
    for i := 0; i &lt; 5; i++:
        print_cmp(i);
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>0 is not 1, 2 or 3
1 is 1, 2 or 3
2 is 1, 2 or 3
3 is 1, 2 or 3
4 is not 1, 2 or 3
</code></pre>
</blockquote>
<p>The example is not the most useful, but it clearly shows a point. We quite often want to check if a given value is <strong>one of</strong> or <strong>none of</strong> a given set of values. So, it can be quite common to check if a single value is part of a given "set" of values. This is actually much more often used for <code>enum</code>s than it is for other types. We will look at an enum example later, but now let's look at how we would write this using the set-like comparisons:</p>
<pre><code class="language-ft">use Core.print

def print_cmp(i32 x):
    if x == (1, 2, 3):
        print($"{x} is 1, 2 or 3\n");

    if x != (1, 2, 3):
        print($"{x} is not 1, 2 or 3\n");

def main():
    for i := 0; i &lt; 5; i++:
        print_cmp(i);
</code></pre>
<p>This program will have the same output as the last one. But let's look at what's happening here. We compare one <strong>scalar</strong> type to a single group. Flint has one single special rule about these comparisons. We are allowed to compare a scalar value to a group if and only if the type of the scalar is the same type as <strong>every</strong> value inside the group. A group where all elements have the same type is called a <strong>homogeneous group</strong> in Flint.</p>
<p>Both shown examples actually compile down to the same code under the hood, but the grouped set-like comparison make the intent much clearer and it als reads much nicer. But you cannot just use the <code>==</code> and <code>!=</code> operators like this, but actually all comparison operations like <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> or <code>&gt;=</code> too. So, let's now move on to a smaller example but using enums instead, because it makes a much bigger difference there:</p>
<pre><code class="language-ft">use Core.print

enum MyEnum:
    VAL1, VAL2, VAL3, VAL4, VAL5;

def main():
    MyEnum me = MyEnum.VAL2;
    if me == MyEnum.VAL1 or me == MyEnum.VAL3 or me == MyEnum.VAL5:
        print("is VAL1, VAL3 or VAL5\n");
    else:
        print("is VAL2 or VAL4\n");

    if me == MyEnum.(VAL1, VAL3, VAL5):
        print("is VAL1, VAL3 or VAL5\n");
    else:
        print("is VAL2 or VAL4\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>is VAL2 or VAL4
is VAL2 or VAL4
</code></pre>
</blockquote>
<p>And here you can see the "superpower" of this approach. Because we compare a scalar to a <strong>group</strong>, not a set value, we can use <em>any</em> grouped operation in the comparison. The grouped operation <code>MyEnum.(VAL1, VAL3, VAL5)</code> looks exaclty like a grouped field access, but for enum values. The resulting group will have the result type of <code>(MyEnum, MyEnum, MyEnum)</code>, so it's a homogeneous group and it has the same type as the lhs, namely the type of <code>MyEnum</code>. And the length comparison for the grouped and non-grouped comparison will only grow bigger and bigger, the set-like comparison will look simpler the more values it contiains.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="arrays"><a class="header" href="#arrays">Arrays</a></h1>
<p>In the previous chapter we learned the importance of <code>data</code>, groups, mutli-types, tuples and how to use all of them in functions. With all these concepts we now developed a good understanding of Flint's type-system. So, its now time to move to more complex types than those of the last chapter – arrays.</p>
<h2 id="what-are-arrays"><a class="header" href="#what-are-arrays">What are Arrays?</a></h2>
<p>An array is a collection of the same data type which can be resized and filled with values. While mutli-types and tuples are great for storing a small amount of values, what if we want to store a hundred of them? Using a tuple to store 100 elements would not only be extremely tedious but also extremely verbose. Just imagine writing <code>i32, </code> a hundred times inside the <code>data&lt;..&gt;</code> definition.</p>
<p>You actually already know an array type: Strings! The <code>str</code> type is just an array of characters (<code>i8</code>) but you will also learn how strings work under the hood in this chapter!</p>
<h2 id="why-are-arrays-important"><a class="header" href="#why-are-arrays-important">Why are Arrays Important?</a></h2>
<p>Arrays are essential in programming because the allow you to:</p>
<ul>
<li>Store and manipulate large amounts of data</li>
<li>Perform operations on multiple values at once</li>
<li>Use indexing to access specific values in the array</li>
</ul>
<h2 id="what-to-expect-3"><a class="header" href="#what-to-expect-3">What to Expect</a></h2>
<p>In this chapter, we will conver the following topics:</p>
<ul>
<li>Declaring and using arrays</li>
<li>Accessing and modifying array elements</li>
<li>Using arrays in functions and data modules</li>
<li>What strings and arrays have in common with one another</li>
<li>What ranges are and how to use them</li>
<li>The enhanced for loop, what it is and how it works</li>
<li>Multi-dimensional arrays and access patterns</li>
<li>Best practices for working with arrays</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="introduction-to-arrays"><a class="header" href="#introduction-to-arrays">Introduction to Arrays</a></h1>
<p>An <strong>array</strong> is a data structure that stores a collection of elements sequentially in memory. Arrays are useful for storing multiple values of the same type, such as numbers, strings, or even custom data modules. In Flint, arrays are <strong>immutable by default</strong> in terms of references — assigning one array to another always creates a <strong>copy</strong>, not a reference.</p>
<ul>
<li>Arrays are always <strong>stored sequentially</strong> in memory, making access to their elements efficient.</li>
<li>Arrays are <strong>value types</strong> in Flint. This means copying an array creates a <strong>new, independent copy</strong> of its data.</li>
<li>If you modify an array inside a data object, you should <strong>access it directly</strong> using data.array instead of copying it out, as changes made to the copy won’t automatically reflect back in the original array.</li>
<li>They are considered complex data types, so passing them to functions passes them as a reference, not a copy.</li>
</ul>
<h2 id="creating-arrays"><a class="header" href="#creating-arrays">Creating Arrays</a></h2>
<p>To declare a one-dimensional array, we write brackets after the array type, for example <code>i32[]</code> for an array of <code>i32</code> values:</p>
<pre><code class="language-ft">def main():
    i32[] arr = i32[10](0);
</code></pre>
<p>This program does not print anything to the console, but we need to talk about it nonetheless and talk about whats happening here. So, we create an array of type <code>i32[]</code> and store it on the variable <code>arr</code>. We <strong>initialize</strong> the array quite similar to how we would initialize <code>data</code>. For <code>data</code>, we wrote the <strong>name</strong> of the data type, followed by parenthesis in which we wrote the initializer arguments. For arrays, this works a bit differently. First of all, we need to provide a <strong>size</strong> in between the squared brackets, in the above example the size will be set to <code>10</code>, which means that the array <code>arr</code> will contain <code>10</code> values of type <code>i32</code>. And lastly, the <code>(0)</code>. For arrays, we need to define a "default-value" with which all array elements are filled. In our case, this is the <code>i32</code> value of <code>0</code>, which means that every single one of the 10 elements in the array has the value <code>0</code> stored in it after the arrays creation.</p>
<h2 id="accessing-elements"><a class="header" href="#accessing-elements">Accessing Elements</a></h2>
<p>To access an element of an array we need to use a new syntax, different from when we accessed elements of the tuple via <code>.$N</code>. Now, for arrays, we need to access it using <code>[N]</code>, where <code>N</code> is the index we want to access. Here is a small example of that:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32[] arr = i32[10](0);
    i32 elem_3 = arr[3];
    print($"elem_3 = {elem_3}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>elem_3 = 0
</code></pre>
</blockquote>
<p>Okay, the array is of size <code>10</code> and we start counting at <code>0</code>, so the last index we are allowed to access is <code>9</code>...what happens if we access index <code>10</code>? In most languages this would yield into a hard crash of the program, but in Flint we have extra safety-guards in place for out-of-bounds checks. But try it for yourself, try to compile and run this program:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32[] arr = i32[10](0);
    i32 elem_10 = arr[10];
    print($"elem_10 = {elem_10}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>Out Of Bounds access occured: Arr Len: 10, Index: 10
elem_10 = 0
</code></pre>
</blockquote>
<p>As you can see, Flint just continues with execution. When you try to access an value thats outside the bounds of the array, Flint will just clamp the index to the last element of the array instead, and printing a message that an Out Of Bounds access has occured. You can actually change Flint's behaviour for OOB-handling with the <strong>Array Options</strong>. Here is a small cutout of the help message of the compiler:</p>
<blockquote>
<pre><code>Array Options:
  --array-print               [Default] Prints a small message to the console whenever accessing an array OOB
  --array-silent              Disables the debug printing when OOB access happens
  --array-crash               Hard crashes when an OOB access happens
  --array-unsafe              Disables all bounds checks for array accesses
</code></pre>
</blockquote>
<p>Try compiling the above code with the different array options set and see for yourself how the Flint program behaves. Flint aims to be as safe and as verbose (in its output) as possible and we try to make safety the default and let you opt-out of safety (for example through the --array-unsafe flag) if you are 100% sure that OOB accesses are impossible for your program.</p>
<h2 id="assigning-values"><a class="header" href="#assigning-values">Assigning Values</a></h2>
<p>To assign new values to elements of the array we use the same accessing-syntax as before:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32[] arr = i32[10](0);
    arr[3] = 8;
    arr[4] = 4;
    print($"arr[3] + arr[4] = {arr[3] + arr[4]}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>arr[3] + arr[4] = 12
</code></pre>
</blockquote>
<h2 id="grouped-access-and-assignment"><a class="header" href="#grouped-access-and-assignment">Grouped Access and Assignment</a></h2>
<div class="warning">
<p>This feature is not yet implemented in the compiler</p>
<p>Currently, this feature does not yet work in the current version of the compiler, but it is <strong>definitely</strong> planned to be implemented in a later version.</p>
</div>
<p>Just like with tuples, mutli-types, data or basically any type in Flint, arrays have some form of interoperability with groups too. The syntax looks a bit different, though. Here is the same example as above, but using a grouped assignment:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32[] arr = i32[10](0);
    arr.[3, 4] = (8, 4);
    print($"arr[3] + arr[4] = {arr[3] + arr[4]}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>arr[3] + arr[4] = 12
</code></pre>
</blockquote>
<p>As you can see, instead of doing <code>.(x, y)</code> (for example for <code>i32x2</code>) we write <code>.[idx1, idx2]</code>. We definitely need the <code>.</code> in front of the <code>[</code> symbol to differentiate a grouped array access from a multi-dimensional array access, but you will learn about multi-dimensional arrays soon.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="iterating-over-arrays"><a class="header" href="#iterating-over-arrays">Iterating Over Arrays</a></h1>
<p>Often, you will want to process each element of an array inside of a loop. For this, you can easily use a <code>for</code> loop, like so:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32[] arr = i32[5](4);
    // Set each element to the double of the index
    for i := 0; i &lt; 5; i++:
        arr[i] = i * 2;
        print($"Index: {i}, Value: {arr[i]}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>Index: 0, Value: 0
Index: 1, Value: 2
Index: 2, Value: 4
Index: 3, Value: 6
Index: 4, Value: 8
</code></pre>
</blockquote>
<p>With loops, we can better demonstrate the OOB-behaviour mentioned in the last chapter. Here is an example to better demonstrate this behaviour:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32[] arr = i32[5](4);
    for i := 0; i &lt; 10; i++:
        arr[i] = i * 2;
        print($"Index: {i}, Value: {arr[i]}\n");

    print("\n");
    for i := 0; i &lt; 5; i++:
        print($"Index: {i}, Value: {arr[i]}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>Index: 0, Value: 0
Index: 1, Value: 2
Index: 2, Value: 4
Index: 3, Value: 6
Index: 4, Value: 8
Out Of Bounds access occured: Arr Len: 5, Index: 5
Out Of Bounds access occured: Arr Len: 5, Index: 5
Index: 5, Value: 10
Out Of Bounds access occured: Arr Len: 5, Index: 6
Out Of Bounds access occured: Arr Len: 5, Index: 6
Index: 6, Value: 12
Out Of Bounds access occured: Arr Len: 5, Index: 7
Out Of Bounds access occured: Arr Len: 5, Index: 7
Index: 7, Value: 14
Out Of Bounds access occured: Arr Len: 5, Index: 8
Out Of Bounds access occured: Arr Len: 5, Index: 8
Index: 8, Value: 16
Out Of Bounds access occured: Arr Len: 5, Index: 9
Out Of Bounds access occured: Arr Len: 5, Index: 9
Index: 9, Value: 18

Index: 0, Value: 0
Index: 1, Value: 2
Index: 2, Value: 4
Index: 3, Value: 6
Index: 4, Value: 18
</code></pre>
</blockquote>
<p>You can spot two out of bounds accesses here. The first one happens when we want to assign <code>i * 2</code> to the array at <code>i</code> and the second one is in the printing when trying to print <code>arr[i]</code> in the string interpolation. And then, at the end we print the current values of the array and you can clearly see that the last element at index 4 holds the value 18, which is double the last index of the last loop. As you can see, OOB accesses are considered "safe" in Flint, because it is well-defined what will happen when an OOB access occurs.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="strings-1"><a class="header" href="#strings-1">Strings</a></h1>
<p>As stated earlier, strings and arrays have very much in common, actually. If we would make a deep-dive into how Flint works internally we would see that arrays and strings actually are the same data structure, but thats too low level for now. But, the important thing to note here is the similarity of strings with arrays, as a string is essentially just an array of characters, but what <em>is</em> a character in string really?</p>
<p>In Flint, a character has the type <code>u8</code>, a type we have not discussed until now. So, if you save the sting <code>hello</code> on a variable its essentially the same as if you would store a <code>u8[]</code> array of length <code>5</code>. There exists a separate <code>str</code> type, however, to make our life with strings a lot easier than it would if we would need to think of strings as arrays of bytes.</p>
<p>But what does all of this mean? Well, first we can access a given character of a string exactly as we would access any element of an array, here is an example:</p>
<pre><code class="language-ft">use Core.print

def main():
    str name = "Marc";
    u8 third = name[2];
    print($"third = '{third}'\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>third = 'r'
</code></pre>
</blockquote>
<p>Now you might say...wait a minute, why is the character printed as <code>r</code> and not as a number, it's an <code>u8</code> type nonetheless, right? Yes, it is. Flint currently only supports characters from the ASCII set. In computers, characters as text is represented as numbers in the ASCII set. You can look at the whole ASCII table <a href="https://www.ascii-code.com/en">here</a>. According to the table, the character <code>r</code> should be the ASCII value of <code>114</code>, lets check that:</p>
<pre><code class="language-ft">use Core.print

def main():
    str name = "Marc";
    u8 third = name[2];
    print($"third = '{third}' at idx {i32(third)}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>third = 'r' at idx 114
</code></pre>
</blockquote>
<p>As you can see, <code>r</code> really is just the number <code>114</code> inside the computer. But what does this mean for arithmetic, comparisons etc? Because <code>u8</code> is "just a normal integer type" we can add, multiply, substract, divide, compare etc, everything like with <code>i32</code> values. But, we can not directly just store numbers on it without explicit typecasting. Here is an example of this:</p>
<pre><code class="language-ft">use Core.print

def main():
    u8 character = 'C';
    print($"character '{character}' is {i32(character)}\n");

    character++;
    print($"character '{character}' is {i32(character)}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>character 'C' is 67
character 'D' is 68
</code></pre>
</blockquote>
<h2 id="getting-a-strings-length"><a class="header" href="#getting-a-strings-length">Getting a string's length</a></h2>
<p>It is not uncommon to have a string as a paramter of a function, for example, and then we often want to get the length of the string somehow, maybe we dont know the length of a string beforehand, for example when parsing user input (will be talked about in a later chapter). But, very often we don't know the size of a string when writing the program, so we need a way to get a strings length at runtime. Here is a small program demonstrating how to get and use the length of a string:</p>
<pre><code class="language-ft">use Core.print

def main():
    str some_string = "some neat string";
    len := some_string.length;
    print($"string '{some_string}' is {len} characters long\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>string 'some neat string' is 16 characters long
</code></pre>
</blockquote>
<p>The variable <code>len</code> is of type <code>u64</code> here. The <code>length</code> field of a string is <strong>always</strong> a <code>u64</code>. One-dimensional arrays have also the result type of <code>u64</code> for their <code>.length</code> field. Here is a small example how you can print an unknown string line by line:</p>
<pre><code class="language-ft">use Core.print

def print_str(str input):
    for i := 0; i &lt; input.length; i++:
        print($"{i}: '{input[i]}'\n");

def main():
    print_str("Hello");
    print_str(", ");
    print_str("World!\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>0: 'H'
1: 'e'
2: 'l'
3: 'l'
4: 'o'
0: ','
1: ' '
0: 'W'
1: 'o'
2: 'r'
3: 'l'
4: 'd'
5: '!'
6: '
'
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="multidimensional-arrays"><a class="header" href="#multidimensional-arrays">Multidimensional Arrays</a></h1>
<p>Flint supports <strong>multidimensional arrays</strong>. In Flint, these arrays are <strong>always rectangular</strong>, meaning that the length of each dimension is locked, unlike <em>jagged arrays</em>, which behave more like "array of arrays". Multidimensional Arrays are particularly useful for storing grid-like data, such as images or matrices.</p>
<h2 id="declaring-multidimensional-arrays"><a class="header" href="#declaring-multidimensional-arrays">Declaring Multidimensional Arrays</a></h2>
<p>The number of commas between the brackets of the array type directly indicates the dimensionality of an array. So, the array <code>i32[]</code> is a one-dimensional array (we have one "line" of values), then <code>i32[,]</code> is a two-dimensional array (we have a "plane" of values), <code>i32[,,]</code> is a three-dimensional array (we have a "cube" of values) and so on. There is no limit to how high the dimensionality of an array can be, really. We start with dimensionality of <code>1</code> because a dimensionality of <code>0</code> is already defined: its a single value, so <code>i32</code> is "an array of 0 dimensionality" if you want to see it like this.</p>
<p>When declaring a multi-dimensional array we use the same syntax as for "normal" arrays, with the same default-value that gets put into all elements of the array as usual:</p>
<pre><code class="language-ft">def main():
    // 2D array
    i32[,] plane = i32[10, 10](0);
    // 3D array
    i32[,,] cube = i32[10, 10, 10](0);
</code></pre>
<p>Here, we defined the <code>plane</code> array to be of size <code>10 × 10</code>, which means there can be stored <code>100</code> elements in this two-dimensional array. We also defined the <code>cube</code> array to be of size <code>10 × 10 × 10</code>, which means there can be stored <code>1000</code> elements in this three-dimensional array.</p>
<h2 id="accessing-multidimensional-arrays"><a class="header" href="#accessing-multidimensional-arrays">Accessing Multidimensional Arrays</a></h2>
<p>To access and assign elements at a given index we need to specify the index of each dimensionality explicitely. For our plane, this would mean that we need to specify the "row" and the "column" of the plane, or the "x" and the "y" coordinates (if the plane is seen as a coordinate plane).</p>
<pre><code class="language-ft">use Core.print

def main():
    i32[,] plane = i32[10, 10](0);
    // Set the element at row 1, column 2
    plane[1, 2] = 10;
    print($"plane[1, 2] = {plane[1, 2]}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>plane[1, 2] = 10
</code></pre>
</blockquote>
<h2 id="getting-the-lengths-of-multi-dimensional-arrays"><a class="header" href="#getting-the-lengths-of-multi-dimensional-arrays">Getting the lengths of multi-dimensional arrays</a></h2>
<p>In the last chapter we talked about how we can access the length of strings and arrays by the <code>.length</code> field on them. This also is true for multi-dimensional arrays. But we have more than one dimension, so how is it possible to get the lengths in one <code>u64</code> variable? Thats a good question, and the answer is very simple: we don't.</p>
<p>Instead, when accessing the <code>.length</code> field of an array we <em>actually</em> get a group of size <code>N</code>, where <code>N</code> is the dimensionality of the array. So, if we access the <code>.length</code> field of an one-dimensional array we get a group of size 1, so we get one <code>u64</code> value. If we access the <code>.length</code> field on the <code>plane</code> array we will get a <code>(u64, u64)</code> group as a return, and if we access the length of a 3D array like our <code>cube</code> we will get a <code>(u64, u64, u64)</code> group as the lengths value, one value for each dimension:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32[,] plane = i32[10, 20](0);
    (x, y) := plane.length;
    print($"plane.length = ({x}, {y})\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>plane.length = (10, 20)
</code></pre>
</blockquote>
<h2 id="iterating-over-multidimensional-arrays"><a class="header" href="#iterating-over-multidimensional-arrays">Iterating over Multidimensional Arrays</a></h2>
<p>Now that we know how to access the lengths of a multi-dimensional array we also can iterate through the array. And for this very reason we need to discuss <strong>row-major</strong> vs <strong>column-major</strong> formats. In Flint, arrays are <strong>always</strong> stored in row-major format, but what does this mean and why is it important?</p>
<p>The array format describes how elements are layed out in memory. Multi-dimensional arrays are essentially "fake"... and in this small section you will also learn why the distinction between the <code>str</code> type and the <code>u8[]</code> type is important. Lets get started then...</p>
<p>Multi-dimensional arrays are "fake" because the values are <em>still</em> stored in <strong>one</strong> contiguous line in memory. Lets look at this easy example here to understand it better: a <code>i32[,]</code> array where each dimensionality has the size of <code>3</code>. Below is a small table in which we give every element a unique ID, from top left to bottom right. We actually start counting at the top left at 0:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th><th style="text-align: center"><code>X0</code></th><th style="text-align: center"><code>X1</code></th><th style="text-align: center"><code>X2</code></th></tr></thead><tbody>
<tr><td style="text-align: center"><code>Y0</code></td><td style="text-align: center">0</td><td style="text-align: center">1</td><td style="text-align: center">2</td></tr>
<tr><td style="text-align: center"><code>Y1</code></td><td style="text-align: center">3</td><td style="text-align: center">4</td><td style="text-align: center">5</td></tr>
<tr><td style="text-align: center"><code>Y2</code></td><td style="text-align: center">6</td><td style="text-align: center">7</td><td style="text-align: center">8</td></tr>
</tbody></table>
</div>
<p>What this table tells us is that <code>arr[0, 2]</code> would be the value of <code>6</code> (x = 0, y = 2). Okay, so the difference between row-major and column-major is this one:</p>
<p>In <strong>Row-Major</strong> format, the array is stored in memory like this:</p>
<pre><code>0 1 2 3 4 5 6 7 8
</code></pre>
<p>In <strong>Column-Major</strong> format, the array is stored in memory like this:</p>
<pre><code>0 3 6 1 4 7 2 5 8
</code></pre>
<p>Note that the numbers that have been chosen do not matter at all, they are just to showcase how it works under the hood. For you, it actually doesn't really matter if it would be saved in row-major or column-major format, if you access arr[0, 2] you would get the same value (<code>X0</code>, <code>Y2</code>) for both formats, its just a matter of how it's saved to memory. But this very reason, how it is saved to memory, is really important for one and only one reason: <strong><em>performance</em></strong>.</p>
<p>You see, when we iterate over an array we can choose between those two methods:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32[,] mat = i32[3, 3](0);
    i32 n = 0;
    // Row-major looping + fills the array
    for i32 y = 0; y &lt; 3; y++:
        for i32 x = 0; x &lt; 3; x++:
            mat[x, y] = n;
            print($"mat[{x}, {y}] = {mat[x, y]}\n");
            n++;

    // Print one empty line in between
    print("\n");

    // Column-major looping
    for i32 x = 0; x &lt; 3; x++:
        for i32 y = 0; y &lt; 3; y++:
            print($"mat[{x}, {y}] = {mat[x, y]}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>mat[0, 0] = 0
mat[1, 0] = 1
mat[2, 0] = 2
mat[0, 1] = 3
mat[1, 1] = 4
mat[2, 1] = 5
mat[0, 2] = 6
mat[1, 2] = 7
mat[2, 2] = 8

mat[0, 0] = 0
mat[0, 1] = 3
mat[0, 2] = 6
mat[1, 0] = 1
mat[1, 1] = 4
mat[1, 2] = 7
mat[2, 0] = 2
mat[2, 1] = 5
mat[2, 2] = 8
</code></pre>
</blockquote>
<p>As you can see, the two looping techniques directly correlate to the order the elements are stored in memory for the examples i have provided you with above. But what is more performant now? If you access the element at <code>mat[1, 2]</code> you are actually accessing the <code>8th</code> element of the array (when starting to count at <code>1</code> here). Because in row-major format, when accessing the element at the third row (y is the row, x is the column) we first need to go through all elements of the two rows that came before it, which is <code>6</code> elements.</p>
<p>So, you may be able to see now that the index at which we would read memory from would constantly jump between positions when iterating through an array using column-major looping whereas when we loop through the array using row-major looping we go through all indices of the two-dimensional array one by one. This is called a <strong>sequentail operation</strong> and the other one is called a <strong>random operation</strong> in computer science. The CPU is <strong>much</strong> more performant with sequential operations than it is with random operations, as it is not as prone to <strong>cache-misses</strong> with sequential loads. If you want to read more about this topic, look <a href="https://www.hostinger.com/uk/tutorials/cache-miss">here</a>.</p>
<p>TLDR: The row-major loop properly utilizes the CPU cache and reduces cache-misses, making the operations <em>much</em> faster in return.</p>
<p>Before you wonder why i told you all of this, everything i talked about becomes important in the next chapter!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="enhanced-for-loops"><a class="header" href="#enhanced-for-loops">Enhanced for Loops</a></h1>
<p>Enhanced for loops are for loops without explicitely declaring a range, but instead they directly operate on a so-called <strong>iterable</strong>. They are extremely useful for iterating through arrays, as enhanced for loops will <strong>always</strong> iterate through a multidimensional array <em>sequentially</em>.</p>
<p>Here is a small example:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32[] arr = i32[5](0);
    // First, fill the array with meaningful values
    for i := 0; i &lt; arr.length; i++:
        arr[i] = i * 2;

    // Iterate through the array element by element
    for (idx, elem) in arr:
        print($"Index {idx}, Value {elem}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>Index 0, Value 0
Index 1, Value 2
Index 2, Value 4
Index 3, Value 6
Index 4, Value 8
</code></pre>
</blockquote>
<p>Okay, lets go through everything about the enhanced for loops one by one. You surely wonder what this <code>(idx, elem)</code> is, and why it looks like a group, right? Well, because it is! When iterating through an iterable we <em>always</em> get the index as the first value of the iteration context (the group) and the element at that index as the second value of the iteration context.</p>
<p>Note that <code>elem</code> is a <strong>mutable reference</strong> to the array element. So, writing <code>elem = ...</code> is the same as if you would write <code>arr[..] = </code>. Here is an example:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32[] arr = i32[5](0);
    // First, fill the array with meaningful values
    for (idx, elem) in arr:
        elem = idx * 2;

    // Iterate through the array element by element
    for (idx, elem) in arr:
        print($"Index {idx}, Value {elem}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>Index 0, Value 0
Index 1, Value 2
Index 2, Value 4
Index 3, Value 6
Index 4, Value 8
</code></pre>
</blockquote>
<p>As you can see, modifying <code>elem</code> directly modifies the array at the current index inplace. This is <em>extremely</em> powerful for mutli-dimensional arrays, because yes, multidimensional arrays are considered iterables too!</p>
<h2 id="not-using-index-or-elem"><a class="header" href="#not-using-index-or-elem">Not using index or elem</a></h2>
<p>We can opt out of using the <code>index</code> or <code>elem</code> variables for enhanced for loops entirely through the <code>_</code> operator. Again, it is used in the context of <code>unused</code> here. Here is a small example:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32[] arr = i32[5](0);
    // Just fill the array with stuff
    for (idx, elem) in arr:
        elem = idx * 2;

    // Ignoring the index value in the enhanced for loop
    for (_, elem) in arr:
        print($"elem is {elem}\n");

    // Ignoring the elem in the enhanced for loop
    for (idx, _) in arr:
        print($"Iteration {idx}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>elem is 0
elem is 2
elem is 4
elem is 6
elem is 8
Iteration 0
Iteration 1
Iteration 2
Iteration 3
Iteration 4
</code></pre>
</blockquote>
<h2 id="iterating-through-mutlidimensional-arrays"><a class="header" href="#iterating-through-mutlidimensional-arrays">Iterating through Mutlidimensional Arrays</a></h2>
<p>As multidimensional arrays are also considered <strong>iterables</strong> we can use the enhanced for loop on multi-dimensional arrays just like we did with the nested for loops:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32[,] plane = i32[3, 3](0);

    for (index, elem) in plane:
        elem = i32(index);

    for y := 0; y &lt; 3; y++:
        for x := 0; x &lt; 3; x++:
            print($"plane[{x}, {y}] = {plane[x, y]}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>plane[0, 0] = 0
plane[1, 0] = 1
plane[2, 0] = 2
plane[0, 1] = 3
plane[1, 1] = 4
plane[2, 1] = 5
plane[0, 2] = 6
plane[1, 2] = 7
plane[2, 2] = 8
</code></pre>
</blockquote>
<p>As you can see, using the enhanced for loop for multi-dimensional arrays yields both the best performance, as we iterate sequentially through the whole array, we have an easy counter to see in which iteration we are and we can modify each element of the multi-dimensional array one by one. If you ever need to modify each element of the array without necessarily needing the positional information (<code>x</code> and <code>y</code> in our case) enhanced for loops are your friend!</p>
<h2 id="iteration-context"><a class="header" href="#iteration-context">Iteration Context</a></h2>
<p>It was said earlier that the group with the index and the element is called the <strong>iteration context</strong> but what does this mean and why does it have a name? Its actually pretty simple: Because this context can be a tuple variable as well!</p>
<p>The <code>index</code> of the iteration context is always a <code>const</code> variable, while the <code>elem</code> of it is always a <code>mut</code> "variable" (its a reference). The iteration context as a tuple itself is <code>const</code>, and the <code>elem</code> field of it (the second field of the tuple) is not a mutable reference anymore, but its an immutable copy (for primitives) or an immutable reference (for complex data types) instead. This means that when using a tuple as the iteration context, we can no longer change the iterable directly through the <code>elem</code> reference. Here is an example:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32[] arr = i32[5](0);
    // First, initialize the array, as always
    for (idx, elem) in arr:
        elem = idx * 2;

    for ctx in arr:
        print($"{ctx.$0}: {ctx.$1}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>0: 0
1: 2
2: 4
3: 6
4: 8
</code></pre>
</blockquote>
<h2 id="enhanced-for-loop-for-strings"><a class="header" href="#enhanced-for-loop-for-strings">Enhanced for loop for strings</a></h2>
<p>You can also iterate over a string using the enhanced for loop, just like you can for arrays. Here is an example of this in action:</p>
<pre><code class="language-ft">use Core.print

def main():
    str my_string = "something useful";
    for (idx, elem) in my_string:
        if idx == 2 or idx == 4:
            // The difference between upcase and lowercase is 32
            u8 tmp_elem = elem;
            elem = tmp_elem - u8(32);

    print($"my_string = '{my_string}'\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>my_string = 'soMeThing useful'
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="cli-arguments"><a class="header" href="#cli-arguments">CLI Arguments</a></h1>
<p>CLI Arguments stands for <strong>C</strong>ommand <strong>L</strong>ine <strong>I</strong>nterface Arguments. CLI arguments describe the act of passing in arguments to a program when executing said program, just like executing a function and passing in the arguments to the function. In fact, many programs can be thought of as "functions" in the Linux world, where you pass in data to a function and get something from it in return.</p>
<p>Here is an example of CLI arguments in action:</p>
<pre><code class="language-ft">use Core.print

def main(str[] args):
    for (idx, elem) in args:
        print($"args[{idx}] = {elem}\n");
</code></pre>
<p>Note how the <strong>signature</strong> of the main function has changed. The main function is allowed to have a parameter of type <code>str[]</code> or to have no parameter. All other cases will lead to an compile error.</p>
<p>This program will print different lines to the console, depending on how we execute it. If we execute the built program (for example the <code>main</code> binary) with this command:</p>
<pre><code class="language-sh">./main
</code></pre>
<p>we will see this line being printed to the console:</p>
<blockquote>
<pre><code>args[0] = ./main
</code></pre>
</blockquote>
<p>If we execute the program like so:</p>
<pre><code class="language-sh">./main someargument somethingelse third-thing
</code></pre>
<p>we will se theese lines being printed to the console instead:</p>
<blockquote>
<pre><code>args[0] = ./main
args[1] = someargument
args[2] = somethingelse
args[3] = third-thing
</code></pre>
</blockquote>
<p>As you can see, the first argument is always the command with which the program was executed with. If the built binary is in a subdirectory, for example, and you execute it with this command:</p>
<pre><code class="language-sh">./somedirectory/main
</code></pre>
<p>you will see this line being printed to the console in this case:</p>
<blockquote>
<pre><code>args[0] = ./somedirectory/main
</code></pre>
</blockquote>
<p>So, if you execute a program with the absolute path to said program, the first CLI argument will contain the command used to execute the program.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="imports"><a class="header" href="#imports">Imports</a></h1>
<p>Up until now, we have always worked with one single file, and with a small file too. But a project that only contains a sinlge file is extremely limiting in what you can do with it and it quickly becomes very messy and confusing if you only have one very large file in which everything is defined in.</p>
<p>For this very reason, Flint supports multi-file projects. Unlike languages like C or C++, where you manually need to collect all your translation units when compiling, Flint provides a much clearer experience: You only specify the file which contains your <code>main</code> function and <code>flintc</code> will dynamically discover all included files, build its internal dependency tree and compile your project from this one and single entry point. So, you can compile your programs with the Flint compiler the same way you did until now, support for multi-file projects does not make compilation any harder for you.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="the-use-clausel"><a class="header" href="#the-use-clausel">The <code>use</code> clausel</a></h1>
<p>The <code>use</code> clausel is a top-level definition, like a function definition for example, which provides a way to "import" code from other files (or modules). You have seen it quite a lot until now:</p>
<pre><code class="language-ft">use Core.print
</code></pre>
<p>You have seen this line a lot of times and you have surely wondered what it means. But why do we call it a <em>clausel</em> and not a <em>statement</em>? In many other languages this inclusion of other code is known as the use-statement or include/import-statement, and they end with a semicolon. But, as you can see, the <code>use</code> clausel does not end with a semicolon in Flint, but why is that?</p>
<p>A <em>statement</em> is a line of code thats written within a <em>scope</em>. Many languages see the empty space in which we define our functions as their <em>top-level scope</em> or <em>file-level scope</em>. This means that global variables, imports, function definitions etc are all defined at this global scope. But Flint is a bit different in this regard. We do not call it a <em>use-statement</em> because in Flint <strong>there is no global scope</strong>. You cannot define a variable outside a function and use it inside multiple different functions. <strong>There is no global state in Flint</strong>, and that's a deliberate design choice. This also means that the use-clausel is <em>not</em> a statement, so it cannot be written inside the body of a function itself (unlike C or C++, for example).</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>But before moving on to any more complex topics, here is a small example of creating two files and compining them together:</p>
<p>This is the <code>main.ft</code> file:</p>
<pre><code class="language-ft">use "utils.ft"
use Core.print

def main():
    i32 x = 5;
    i32 y = 6;
    i32 res = add(x, y);
    print($"res = {res}\n");
</code></pre>
<p>This is the <code>utils.ft</code> file:</p>
<pre><code class="language-ft">def add(i32 x, i32 y) -&gt; i32:
    return x + y;
</code></pre>
<p>And you compile the program with the same command as usual:</p>
<pre><code class="language-ft">flintc -f main.ft
</code></pre>
<p>When running the built program, this line will be printed to the console:</p>
<blockquote>
<pre><code>res = 11
</code></pre>
</blockquote>
<p>As you can see, we have successfully called the function <code>add</code> defined in the file <code>utils.ft</code> from the <code>main</code> function inside the <code>main.ft</code> file, and the Flint compiler discovered the used file dynamically during compilation.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="circular-dependencies"><a class="header" href="#circular-dependencies">Circular Dependencies</a></h1>
<p>You may have asked yourself already <em>"What will happen if file <code>A</code> imports file <code>B</code> and file <code>B</code> imports file <code>A</code> again?"</em>. This is called a circular dependency. It's called circular, because the dependency graph forms a circle, where the "line of imports" ends up at its starting point. If you try to write import statements in C where every file imports another file you will get a compilation error, as circular dependencies are not allowed and cannot be resolved.</p>
<p>But Flint's <code>use</code> clausels work quite different from the <code>#import</code> from C-style languages. Whereas these literally just copy and paste the code from the other file, the <code>use</code> clausel in Flint is a lot...smarter. The <code>use</code> clausel only imports files at a depth of <code>1</code>, but what does this mean? Well, here is a small example to showcase what i mean with that:</p>
<p>The <code>helper.ft</code> file:</p>
<pre><code class="language-ft">def substract_and_mult(i32 x, i32 y) -&gt; i32:
    i32 diff = x - y;
    return diff * 2;
</code></pre>
<p>The <code>utils.ft</code> file:</p>
<pre><code class="language-ft">use "helper.ft"

def some_operation(i32 x, i32 y) -&gt; i32:
    i32 res = substract_and_mult(x, y);
    return res - (x + y);
</code></pre>
<p>The <code>main.ft</code> file:</p>
<pre><code class="language-ft">use "utils.ft"
use Core.print

def main():
    i32 res = some_operation(44, 33);
    print($"res = {res}\n");
</code></pre>
<p>When compiling this program, you will see this line printed to the console:</p>
<blockquote>
<pre><code>res = -55
</code></pre>
</blockquote>
<p>In this example you can see how Flint has an importing depth of <code>1</code>, unlike many other languages. So, when you include <code>utils.ft</code> in the <code>main.ft</code> file you <em>only</em> gain access to the <code>some_operation</code> function, but <em>not</em> to the <code>substract_and_mult</code> function from the <code>helper.ft</code> file. There is no recursive resolution of imports happening, meaning that <strong>every</strong> import in Flint is "shallow". If you would need the <code>substract_and_mult</code> function within your <code>main.ft</code> file you would need to write an explicit <code>use "helper.ft"</code> clausel. This is absolutely intentional, because having <em>only</em> shallow inclusions we get something even better: <strong><em>circular inclusion support</em></strong>.</p>
<p>Circular dependencies are <strong>not</strong> considered a fault in Flint, at all. Often times you want to separate code on meaning, but the single files still need access to one another. In C-style languages you would solve this with forward-declarations, header files etc. But in Flint you just include any file you like, and it simply does not matter if a circle emerges or not, the Flint compiler will handle it all! Here is an example showcasing circular dependencies with a recursive function:</p>
<p>The <code>utils.ft</code> file:</p>
<pre><code class="language-ft">use "main.ft"
use Core.print

def recursive_count_utils(i32 x):
    if x &gt; 5:
        print("utils end\n");
        return;
    print($"utils: {x}\n");
    recursive_count_main(x + 1);
</code></pre>
<p>The <code>main.ft</code> file:</p>
<pre><code class="language-ft">use "utils.ft"
use Core.print

def recursive_count_main(i32 x):
    if x &gt; 5:
        print("main end\n");
        return;
    print($"main:  {x}\n");
    recursive_count_utils(x + 1);

def main():
    recursive_count_main(0);
    print("\n");
    recursive_count_utils(0);
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>main:  0
utils: 1
main:  2
utils: 3
main:  4
utils: 5
main end

utils: 0
main:  1
utils: 2
main:  3
utils: 4
main:  5
utils end
</code></pre>
</blockquote>
<p>As you can see, circular dependencies are absolutely no problem in Flint, and the only reason they are no problem is the dynamic exploratory nature of the compiler (you only specify one file and the compiler will find all included functions on its own) and the fact that the inclusion depth is only 1, so every use clausel is a shallow include.</p>
<h2 id="side-note"><a class="header" href="#side-note">Side note</a></h2>
<p>Because the files <code>main.ft</code> and <code>utils.ft</code> form a circle in the last example, you actually also could compile the program with the command <code>flintc -f utils.ft</code> and it would still work, as it would explore all files until it finds the main function. You can always think of file dependencies as a "tree". If, for example, file <code>main.ft</code> includes file <code>A</code>, which includes file <code>B</code> and you specify file <code>A</code> when compiling, you will get an error that no main function is defined, as the <code>main.ft</code> function was no longer part of the tree. If, however, file <code>A</code> or file <code>B</code> include <code>main.ft</code>, the compiler will be able to find the main file and main function again. Try it out and test a few file dependency trees and see for yourself how the compiler will react to it.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="import-aliasing"><a class="header" href="#import-aliasing">Import Aliasing</a></h1>
<div class="warning">
<p>Import aliasing works, but is messed up.</p>
<p>Use Import aliasing with caution, its pretty messed up at the moment, so it would be best to avoid it for the current version of Flint.</p>
</div>
<p>Import aliasing is pretty useful if you have a lot of files in your project and if you have colliding definition names between your files, or imported libraries. For this very reason you can use import-aliasing, to make definitions from different files unambigue. Here is a small example of this:</p>
<p>The <code>utils.ft</code> file:</p>
<pre><code class="language-ft">use Core.print as p

def print(str msg):
    p.print(msg + "\n");
</code></pre>
<p>The <code>main.ft</code> file:</p>
<pre><code class="language-ft">use "utils.ft"

def main():
    print("Hello, World!");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>Hello, Word!
</code></pre>
</blockquote>
<p>As you can see, <strong>any</strong> <code>use</code> clausel can be aliased. The identifier after the <code>as</code> keyword is the aliasing name, which you need to specify when you call the function. If you would remove the <code>p.</code> in the <code>utils.ft</code> file you would get a compile error.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="core-modules"><a class="header" href="#core-modules">Core Modules</a></h1>
<p>Core Modules are essential to Flint, as Flint does not ship with a standard library. Core Modules provide core functionality which just <strong>cannot</strong> be implemented in pure Flint code, as Flint is a high level language. The general rule of thumb is that <strong>everything that can be implemented in pure Flint code will not be part of Core Modules</strong>. In Flint, we aim to provide libraries over on FlintHub and aim to make it as easy as possible to include FlintHub libraries. These libraries are the place where "standard" libraries can be found.</p>
<p>You have actually seen the core modules in action quite a lot until now: The <code>use Core.print</code> line is a special use clausel which tells the compiler to include the <code>print</code> Core module. There are several more core modules than just the <code>print</code> module, though. In this chapter, you will learn which Core modules there exist, which functions they provide and how to use them.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="print"><a class="header" href="#print">print</a></h1>
<pre><code class="language-ft">use Core.print
</code></pre>
<p>The <code>print</code> core module provides several print functions. Here are all the print functions this module provides. There exist <em>a lot</em> of builtin print overloads for the print function.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Parameter Types</th><th style="text-align: center">Return Types</th><th style="text-align: center">Possible Errors</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>str</code></td><td style="text-align: center"><code>void</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>i32</code></td><td style="text-align: center"><code>void</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>i64</code></td><td style="text-align: center"><code>void</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>u32</code></td><td style="text-align: center"><code>void</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>u64</code></td><td style="text-align: center"><code>void</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>f32</code></td><td style="text-align: center"><code>void</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>f64</code></td><td style="text-align: center"><code>void</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>u8</code></td><td style="text-align: center"><code>void</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>bool</code></td><td style="text-align: center"><code>void</code></td><td style="text-align: center">No</td></tr>
</tbody></table>
</div>
<p>Note that none of the print functions prints a new line after the print. This could be important when printing values in a loop, for example, because calling a "native" print function like <code>print(i32)</code> is generally speaking faster than calling the <code>print(str)</code> function with an interpolated string as argument, as string casting + concatenation takes more time than just calling the specialized print functions one after another. So, while string interpolation is <strong>much</strong> more ergonomic for the programmer, its is also a bit slower generally speaking.</p>
<p>The <code>print(str)</code> function was used throughout this wiki until now. Every string interpolation evaluates to a string value, so this is the function we have called <em>exclusively</em> thus far, to make printing not as overwhelming.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="read"><a class="header" href="#read">read</a></h1>
<pre><code class="language-ft">use Core.read
</code></pre>
<p>The <code>read</code> module provides several functions to read input from the command line and to read input from the user, like numbers or text edited by the user.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">Function Name</th><th style="text-align: center">Parameter Types</th><th style="text-align: center">Return Types</th><th style="text-align: center">Possible Errors</th></tr></thead><tbody>
<tr><td style="text-align: right"><code>read_str</code></td><td style="text-align: center">No</td><td style="text-align: center"><code>str</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: right"><code>read_i32</code></td><td style="text-align: center">No</td><td style="text-align: center"><code>i32</code></td><td style="text-align: center">ErrRead</td></tr>
<tr><td style="text-align: right"><code>read_i64</code></td><td style="text-align: center">No</td><td style="text-align: center"><code>i64</code></td><td style="text-align: center">ErrRead</td></tr>
<tr><td style="text-align: right"><code>read_u32</code></td><td style="text-align: center">No</td><td style="text-align: center"><code>u32</code></td><td style="text-align: center">ErrRead</td></tr>
<tr><td style="text-align: right"><code>read_u64</code></td><td style="text-align: center">No</td><td style="text-align: center"><code>u64</code></td><td style="text-align: center">ErrRead</td></tr>
<tr><td style="text-align: right"><code>read_f32</code></td><td style="text-align: center">No</td><td style="text-align: center"><code>f32</code></td><td style="text-align: center">ErrRead</td></tr>
<tr><td style="text-align: right"><code>read_f64</code></td><td style="text-align: center">No</td><td style="text-align: center"><code>f64</code></td><td style="text-align: center">ErrRead</td></tr>
</tbody></table>
</div>
<h2 id="error-sets"><a class="header" href="#error-sets">error sets</a></h2>
<p>These are the error sets this Core module provides.</p>
<h3 id="errread"><a class="header" href="#errread">ErrRead</a></h3>
<p>This error set does not have a parent error, so it directly and only extends <code>anyerror</code> directly. These are the possible values this error could have:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Error Value</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>ReadLines</code></td><td style="text-align: left">Could not read lines from console</td></tr>
<tr><td style="text-align: left"><code>ParseInt</code></td><td style="text-align: left">Could not parse text to integer</td></tr>
<tr><td style="text-align: left"><code>NegativeUint</code></td><td style="text-align: left">Negative input not allowed for unsigned integers</td></tr>
<tr><td style="text-align: left"><code>ParseFloat</code></td><td style="text-align: left">Could not parse text to floating‑point</td></tr>
</tbody></table>
</div>
<h2 id="read_str"><a class="header" href="#read_str">read_str</a></h2>
<p>The <code>read_str</code> function has no parameters and returns a <code>str</code> value. It is used to read a whole line from the console. Note that tis function <em>cannot</em> return an error, as there is no input parsing or input validation taking place.</p>
<pre><code class="language-ft">use Core.print
use Core.read

def main():
    str text = read_str();
    print($"entered text: \"{text}\"\n");
</code></pre>
<h2 id="read_i32"><a class="header" href="#read_i32">read_i32</a></h2>
<p>The <code>read_i32</code> function has no parameters and returns a <code>i32</code> value. It is used to read <code>i32</code> values from the console. It can throw an error if the entered text is not parsable to an signed integer value.</p>
<pre><code class="language-ft">use Core.print
use Core.read

def main():
    i32 num = read_i32();
    print($"entered i32: {num}\n");
</code></pre>
<h2 id="read_i64"><a class="header" href="#read_i64">read_i64</a></h2>
<p>The <code>read_i64</code> function has no parameters and returns a <code>i64</code> value. It is used to read <code>i64</code> values from the console. It can throw an error if the entered text is not parsable to an signed integer value.</p>
<pre><code class="language-ft">use Core.print
use Core.read

def main():
    i64 num = read_i64();
    print($"entered i64: {num}\n");
</code></pre>
<h2 id="read_u32"><a class="header" href="#read_u32">read_u32</a></h2>
<p>The <code>read_u32</code> function has no parameters and returns a <code>u32</code> value. It is used to read <code>u32</code> values from the console. It can throw an error if the entered text is not parsable to an unsigned integer value.</p>
<pre><code class="language-ft">use Core.print
use Core.read

def main():
    u32 num = read_u32();
    print($"entered u32: {num}\n");
</code></pre>
<h2 id="read_u64"><a class="header" href="#read_u64">read_u64</a></h2>
<p>The <code>read_u64</code> function has no parameters and returns a <code>u64</code> value. It is used to read <code>u64</code> values from the console. It can throw an error if the entered text is not parsable to an unsigned integer value.</p>
<pre><code class="language-ft">use Core.print
use Core.read

def main():
    u64 num = read_u64();
    print($"entered u64: {num}\n");
</code></pre>
<h2 id="read_f32"><a class="header" href="#read_f32">read_f32</a></h2>
<p>The <code>read_f32</code> function has no parameters and returns a <code>f32</code> value. It is used to read <code>f32</code> values from the console. It can throw an error if the entered text is not parsable to an floating point value.</p>
<pre><code class="language-ft">use Core.print
use Core.read

def main():
    f32 num = read_f32();
    print($"entered f32: {num}\n");
</code></pre>
<h2 id="read_f64"><a class="header" href="#read_f64">read_f64</a></h2>
<p>The <code>read_f64</code> function has no parameters and returns a <code>f64</code> value. It is used to read <code>f64</code> values from the console. It can throw an error if the entered text is not parsable to an floating point value.</p>
<pre><code class="language-ft">use Core.print
use Core.read

def main():
    f64 num = read_f64();
    print($"entered f64: {num}\n");
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="assert"><a class="header" href="#assert">assert</a></h1>
<pre><code class="language-ft">use Core.assert
</code></pre>
<p>The <code>assert</code> module provides a single <code>assert</code> function, which returns an error if the given condition evaluates to false. It is used for code-assertions and to fail loud and clear.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">Function Name</th><th style="text-align: center">Parameter Types</th><th style="text-align: center">Return Types</th><th style="text-align: center">Possible Errors</th></tr></thead><tbody>
<tr><td style="text-align: right"><code>assert</code></td><td style="text-align: center"><code>bool</code></td><td style="text-align: center">No</td><td style="text-align: center"><code>ErrAssert</code></td></tr>
</tbody></table>
</div>
<h2 id="error-sets-1"><a class="header" href="#error-sets-1">error sets</a></h2>
<p>These are the error sets this Core module provides.</p>
<h3 id="errassert"><a class="header" href="#errassert">ErrAssert</a></h3>
<p>This error set does not have a parent error, so it directly and only extends <code>anyerror</code> directly. These are the possible values this error could have:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Error Value</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>AssertionFailed</code></td><td style="text-align: left">The assertion has failed</td></tr>
</tbody></table>
</div>
<h2 id="assert-1"><a class="header" href="#assert-1">assert</a></h2>
<pre><code class="language-ft">use Core.assert

def main():
    i32 x = 5;
    assert(x &gt; 6);
</code></pre>
<p>When executing this program you will see this error message printed to the console:</p>
<blockquote>
<pre><code>ERROR: main function returned error
 - type_id: 2448605372
 - value_id: 0
 - message: "The assertion has failed"
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="filesystem"><a class="header" href="#filesystem">filesystem</a></h1>
<pre><code class="language-ft">use Core.filesystem
</code></pre>
<p>The <code>filesystem</code> module provides several functions to read data from and write data to files.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">Function Name</th><th style="text-align: center">Parameter Types</th><th style="text-align: center">Return Types</th><th style="text-align: center">Possible Errors</th></tr></thead><tbody>
<tr><td style="text-align: right"><code>read_file</code></td><td style="text-align: center"><code>str</code></td><td style="text-align: center"><code>str</code></td><td style="text-align: center"><code>ErrIO</code></td></tr>
<tr><td style="text-align: right"><code>read_lines</code></td><td style="text-align: center"><code>str</code></td><td style="text-align: center"><code>str[]</code></td><td style="text-align: center"><code>ErrFS</code></td></tr>
<tr><td style="text-align: right"><code>file_exists</code></td><td style="text-align: center"><code>str</code></td><td style="text-align: center"><code>bool</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: right"><code>write_file</code></td><td style="text-align: center"><code>str</code>, <code>str</code></td><td style="text-align: center">No</td><td style="text-align: center"><code>ErrFS</code></td></tr>
<tr><td style="text-align: right"><code>append_file</code></td><td style="text-align: center"><code>str</code>, <code>str</code></td><td style="text-align: center">No</td><td style="text-align: center"><code>ErrFS</code></td></tr>
<tr><td style="text-align: right"><code>is_file</code></td><td style="text-align: center"><code>str</code></td><td style="text-align: center"><code>bool</code></td><td style="text-align: center">No</td></tr>
</tbody></table>
</div>
<h2 id="error-sets-2"><a class="header" href="#error-sets-2">error sets</a></h2>
<p>These are the error sets this Core module provides.</p>
<h3 id="errio"><a class="header" href="#errio">ErrIO</a></h3>
<p>This error set does not have a parent error, so it directly and only extends <code>anyerror</code> directly. These are the possible values this error could have:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Error Value</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>OpenFailed</code></td><td style="text-align: left">Could not open the file</td></tr>
<tr><td style="text-align: left"><code>NotFound</code></td><td style="text-align: left">File does not exist</td></tr>
<tr><td style="text-align: left"><code>NotReadable</code></td><td style="text-align: left">Exists but is not readable</td></tr>
<tr><td style="text-align: left"><code>NotWritable</code></td><td style="text-align: left">Exists but is not writable (permissions)</td></tr>
<tr><td style="text-align: left"><code>UnexpectedEOF</code></td><td style="text-align: left">Hit EOF in the middle of a read</td></tr>
</tbody></table>
</div>
<h3 id="errfs"><a class="header" href="#errfs">ErrFS</a></h3>
<p>This error set extens the <code>ErrIO</code> error set. These are the possible values this error set could have in addition to all the error values from <code>ErrIO</code>:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Error Value</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>TooLarge</code></td><td style="text-align: left">File is unreasonably large</td></tr>
<tr><td style="text-align: left"><code>InvalidPath</code></td><td style="text-align: left">Path string is malformed</td></tr>
</tbody></table>
</div>
<h2 id="read_file"><a class="header" href="#read_file">read_file</a></h2>
<p>The <code>read_file</code> function takes a <code>str</code> parameter, which is the path to the file that wants to be read and returns a <code>str</code> value, containing the content of the given file. This function throws an error if the file does not exist or is not readable.</p>
<pre><code class="language-ft">use Core.print
use Core.filesystem

def main(str[] args):
    if args.length &lt; 2:
        print("No path provided as a cli argument! Exiting...\n");
        return;

    str file_content = read_file(args[1]);
    print($"Read file '{args[1]}':\n");
    print(file_content);
    print("\n");
</code></pre>
<p>When executing this program with the command <code>./main main.ft</code> we get this output:</p>
<blockquote>
<pre><code>Read file 'main.ft':
use Core.print
use Core.filesystem

def main(str[] args):
    if args.length &lt; 2:
        print("No path provided as a cli argument! Exiting...\n");
        return;

    str file_content = read_file(args[1]);
    print($"Read file '{args[1]}':\n");
    print(file_content);
    print("\n");
</code></pre>
</blockquote>
<h2 id="read_lines"><a class="header" href="#read_lines">read_lines</a></h2>
<p>The <code>read_lines</code> function reads a given file (the <code>str</code> path to the file) and returns an array of all read lines (<code>str[]</code>). This function is really useful for reading a file and iterating through each line after reading the file. This function throws an error if the file does not exist or is not readable.</p>
<pre><code class="language-ft">use Core.print
use Core.filesystem

def main(str[] args):
    if args.length &lt; 2:
        print("No path provided as a cli argument! Exiting...\n");
        return;

    str[] lines = read_lines(args[1]);
    print($"Read file '{args[1]}':\n");
    for (idx, line) in lines:
        print($"{idx}:\t| {line}\n");
</code></pre>
<p>When executing this program with the command <code>./main main.ft</code> we get this output:</p>
<blockquote>
<pre><code>Read file 'main.ft':
0:	| use Core.print
1:	| use Core.filesystem
2:	|
3:	| def main(str[] args):
4:	|     if args.length &lt; 2:
5:	|         print("No path provided as a cli argument! Exiting...\n");
6:	|         return;
7:	|
8:	|     str[] lines = read_lines(args[1]);
9:	|     print($"Read file '{args[1]}':\n");
10:	|     for (idx, line) in lines:
11:	|         print($"{idx}:\t| {line}\n");
</code></pre>
</blockquote>
<h2 id="file_exists"><a class="header" href="#file_exists">file_exists</a></h2>
<p>The <code>file_exists</code> function checks whether the given file (<code>str</code> path to the file) exists. This function cannot crash, as it checks for a file's existence, so when it does not exist or is not readable, it just returns <code>false</code>.</p>
<pre><code class="language-ft">use Core.print
use Core.filesystem

def main(str[] args):
    if args.length &lt; 2:
        print("No path provided as a cli argument! Exiting...\n");
        return;

    bool exists = file_exists(args[1]);
    print($"Does file '{args[1]}' exist? {exists}\n");
</code></pre>
<p>When executing this program with the command <code>./main main.ft</code> we get this output:</p>
<blockquote>
<pre><code>Does file 'main.ft' exist? true
</code></pre>
</blockquote>
<h2 id="write_file"><a class="header" href="#write_file">write_file</a></h2>
<p>The <code>write_file</code> function takes two arguments. The first argument is the path to the file to write to (or create) as a <code>str</code> path. The second parameter is the content of the to-be-written file (<code>str</code>). This function will create a file at the given path if the file does not exist yet. If the file exists, this function just overwrites it. This function will throw an error if the given file coould not be opened or could not be written to (for example a permission error).</p>
<pre><code class="language-ft">use Core.print
use Core.filesystem

def main():
    write_file("test_file", "Test File content\nThis is going to be great!");
    str file = read_file("test_file");
    print($"test_file content:\n{file}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>test_file content:
Test File content
This is going to be great!
</code></pre>
</blockquote>
<h2 id="append_file"><a class="header" href="#append_file">append_file</a></h2>
<p>The <code>append_file</code> function will try to append text to an already existent file. The first parameter of the function is the path to the file the new content is appended (<code>str</code> path). The second parameter is the content which will be appended to the file (<code>str</code>). This function will throw an error if the given file does not exist or could not be opened with write access.</p>
<pre><code class="language-ft">use Core.print
use Core.filesystem

def main():
    write_file("test_file", "Test File content\nThis is going to be great!");
    append_file("test_file", "\n\nThis is written with one space in between!");

    str file = read_file("test_file");
    print($"test_file content:\n{file}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>test_file content:
Test File content
This is going to be great!

This is written with one space in between!
</code></pre>
</blockquote>
<h2 id="is_file"><a class="header" href="#is_file">is_file</a></h2>
<p>The <code>is_file</code> function checks whether the file at the given path (<code>str</code>) even is a file. It will return <code>false</code> in the case that the file / directory does not exist. It will also return false if the given "file" is actually a directory. This function cannot throw any errors.</p>
<pre><code class="language-ft">use Core.print
use Core.filesystem

def main():
    print($"is 'test_file' a file? {is_file("test_file")}\n");
    print($"is 'somegarbage' a file? {is_file("somegarbage")}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>is 'test_file' a file? true
is 'somegarbage' a file? false
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="env"><a class="header" href="#env">env</a></h1>
<pre><code class="language-ft">use Core.env
</code></pre>
<p>The <code>env</code> module provides several functions to read from and write to environment variables.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">Function Name</th><th style="text-align: center">Parameter Types</th><th style="text-align: center">Return Types</th><th style="text-align: center">Possible Errors</th></tr></thead><tbody>
<tr><td style="text-align: right"><code>get_env</code></td><td style="text-align: center"><code>str</code></td><td style="text-align: center"><code>str</code></td><td style="text-align: center"><code>ErrEnv</code></td></tr>
<tr><td style="text-align: right"><code>set_env</code></td><td style="text-align: center"><code>str</code>, <code>str</code>, <code>bool</code></td><td style="text-align: center"><code>bool</code></td><td style="text-align: center"><code>ErrEnv</code></td></tr>
</tbody></table>
</div>
<h2 id="error-sets-3"><a class="header" href="#error-sets-3">error sets</a></h2>
<p>These are the error sets this Core module provides.</p>
<h3 id="errenv"><a class="header" href="#errenv">ErrEnv</a></h3>
<p>This error set does not have a parent error, so it directly and only extends <code>anyerror</code> directly. These are the possible values this error could have:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Error Value</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>VarNotFound</code></td><td style="text-align: left">Requested variable not set</td></tr>
<tr><td style="text-align: left"><code>InvalidName</code></td><td style="text-align: left">Name contains illegal characters</td></tr>
<tr><td style="text-align: left"><code>InvalidValue</code></td><td style="text-align: left">Value cannot be used (e.g. embedded NUL)</td></tr>
</tbody></table>
</div>
<h2 id="get_env"><a class="header" href="#get_env">get_env</a></h2>
<p>The <code>get_env</code> function recieves the currently stored value of a given environment variable (<code>str</code>). The content of the environment variable is returned as a <code>str</code>. This function will throw an error if the requested environment variable does not exist.</p>
<pre><code class="language-ft">use Core.print
use Core.env

def main():
    print($"HOME = {get_env("HOME")}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>HOME = /home/zweiler1
</code></pre>
</blockquote>
<h2 id="set_env"><a class="header" href="#set_env">set_env</a></h2>
<p>The <code>set_env</code> function sets a given environment variable (<code>str</code>) to a newly specified value (<code>str</code>). The third parameter (<code>bool</code>) controls whether the given environment variable should be overwritten if it already exists. If the third parameter is <code>false</code> an already existent environment variable wont be overwritten. This function will throw an error if the environment variable or the content of the variable contain invalid characters.</p>
<pre><code class="language-ft">use Core.print
use Core.env

def main():
    bool overwrite_home = set_env("HOME", "something new", false);
    print($"HOME overwritten? {overwrite_home}\n");
    print($"HOME value: {get_env("HOME")}\n");

    bool create_new = set_env("NEW_ENV_VARIABLE", "some nice value", false);
    print($"NEW_ENV_VARIABLE craeted? {create_new}\n");
    print($"NEW_ENV_VARIABLE content: {get_env("NEW_ENV_VARIABLE")}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>HOME overwritten? true
HOME value: /home/zweiler1
NEW_ENV_VARIABLE craeted? true
NEW_ENV_VARIABLE content: some nice value
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="system"><a class="header" href="#system">system</a></h1>
<pre><code class="language-ft">use Core.system
</code></pre>
<p>The <code>system</code> module provides functions to interact with the system, for example to execute system commands.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">Function Name</th><th style="text-align: center">Parameter Types</th><th style="text-align: center">Return Types</th><th style="text-align: center">Possible Errors</th></tr></thead><tbody>
<tr><td style="text-align: right"><code>system_command</code></td><td style="text-align: center"><code>str</code></td><td style="text-align: center"><code>i32</code>, <code>str</code></td><td style="text-align: center"><code>ErrSystem</code></td></tr>
</tbody></table>
</div>
<h2 id="error-sets-4"><a class="header" href="#error-sets-4">error sets</a></h2>
<p>These are the error sets this Core module provides.</p>
<h3 id="errsystem"><a class="header" href="#errsystem">ErrSystem</a></h3>
<p>This error set does not have a parent error, so it directly and only extends <code>anyerror</code> directly. These are the possible values this error could have:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Error Value</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>SpawnFailed</code></td><td style="text-align: left">Process could not be created</td></tr>
</tbody></table>
</div>
<h2 id="system_command"><a class="header" href="#system_command">system_command</a></h2>
<p>The <code>system_command</code> function executes a given command, for example <code>ls -lah</code> and returns the exit code of the given command together with the output of the command, stored in a string. The function can throw an error if the process (the command) cannot be created.</p>
<pre><code class="language-ft">use Core.print
use Core.system

def main():
    (exit_code, output) = system_command("ls");
    print($"exit_code = {exit_code}\n");
    print($"output = '{output}'\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>exit_code = 0
output = 'build
build.zig
build.zig.zon
cmake
CMakeLists.txt
compile_flags.txt
documents
examples
fetch_crt.sh
include
LICENSE
logfile
lsp
main
main.o
main.obj
output.ll
README.md
resources
scripts
src
test
test_files
test.o
tests
vendor
'
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="math"><a class="header" href="#math">math</a></h1>
<pre><code class="language-ft">use Core.math
</code></pre>
<p>The <code>math</code> module provides math functions which are used very frequently in math-heavy workloads.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Function Name</th><th style="text-align: center">Parameter Types</th><th style="text-align: center">Return Types</th><th style="text-align: center">Possible Errors</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>sin</code></td><td style="text-align: center"><code>f32</code></td><td style="text-align: center"><code>f32</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>sin</code></td><td style="text-align: center"><code>f64</code></td><td style="text-align: center"><code>f64</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><hr></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><code>cos</code></td><td style="text-align: center"><code>f32</code></td><td style="text-align: center"><code>f32</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>cos</code></td><td style="text-align: center"><code>f64</code></td><td style="text-align: center"><code>f64</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><hr></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><code>sqrt</code></td><td style="text-align: center"><code>f32</code></td><td style="text-align: center"><code>f32</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>sqrt</code></td><td style="text-align: center"><code>f64</code></td><td style="text-align: center"><code>f64</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><hr></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><code>abs</code></td><td style="text-align: center"><code>i32</code></td><td style="text-align: center"><code>i32</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>abs</code></td><td style="text-align: center"><code>i64</code></td><td style="text-align: center"><code>i64</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>abs</code></td><td style="text-align: center"><code>f32</code></td><td style="text-align: center"><code>f32</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>abs</code></td><td style="text-align: center"><code>f64</code></td><td style="text-align: center"><code>f64</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><hr></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><code>min</code></td><td style="text-align: center"><code>u32</code>, <code>u32</code></td><td style="text-align: center"><code>u32</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>min</code></td><td style="text-align: center"><code>u64</code>, <code>u64</code></td><td style="text-align: center"><code>u64</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>min</code></td><td style="text-align: center"><code>i32</code>, <code>i32</code></td><td style="text-align: center"><code>i32</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>min</code></td><td style="text-align: center"><code>i64</code>, <code>i64</code></td><td style="text-align: center"><code>i64</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>min</code></td><td style="text-align: center"><code>f32</code>, <code>f32</code></td><td style="text-align: center"><code>f32</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>min</code></td><td style="text-align: center"><code>f64</code>, <code>f64</code></td><td style="text-align: center"><code>f64</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><hr></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><code>max</code></td><td style="text-align: center"><code>u32</code>, <code>u32</code></td><td style="text-align: center"><code>u32</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>max</code></td><td style="text-align: center"><code>u64</code>, <code>u64</code></td><td style="text-align: center"><code>u64</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>max</code></td><td style="text-align: center"><code>i32</code>, <code>i32</code></td><td style="text-align: center"><code>i32</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>max</code></td><td style="text-align: center"><code>i64</code>, <code>i64</code></td><td style="text-align: center"><code>i64</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>max</code></td><td style="text-align: center"><code>f32</code>, <code>f32</code></td><td style="text-align: center"><code>f32</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>max</code></td><td style="text-align: center"><code>f64</code>, <code>f64</code></td><td style="text-align: center"><code>f64</code></td><td style="text-align: center">No</td></tr>
</tbody></table>
</div>
<h2 id="error-sets-5"><a class="header" href="#error-sets-5">error sets</a></h2>
<p>These are the error sets this Core module provides.</p>
<h2 id="sin"><a class="header" href="#sin">sin</a></h2>
<p>The <code>sin</code> function executes the sine function on the given parameter. The parameter is in radians, so you need to convert it from degrees to radians before using it.</p>
<pre><code class="language-ft">use Core.print
use Core.math

def main():
    f32 x = sin(0.5236)
    print($"x = {x}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>x = 0.5
</code></pre>
</blockquote>
<h2 id="cos"><a class="header" href="#cos">cos</a></h2>
<p>The <code>cos</code> function executes the cosine function on the given parameter. The parameter is in radians, so you need to convert it from degrees to radians before using it.</p>
<pre><code class="language-ft">use Core.print
use Core.math

def main():
    f32 x = sin(1.0472)
    print($"x = {x}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>x = 0.5
</code></pre>
</blockquote>
<h2 id="sqrt"><a class="header" href="#sqrt">sqrt</a></h2>
<p>The <code>sqrt</code> function executes the sqare root on the given parameter.</p>
<pre><code class="language-ft">use Core.print
use Core.math

def main():
    f32 x = sqrt(9.0);
    print($"x = {x}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>x = 3
</code></pre>
</blockquote>
<h2 id="abs"><a class="header" href="#abs">abs</a></h2>
<p>The <code>abs</code> function returns the absolute value of the given signed value parameter. Note that this function only has overloads for signed integers and floating point types. If the input of the integer overloads of the <code>abs</code> function is <code>I32_MIN</code> or <code>I64_MIN</code> then <code>I32_MAX</code> or <code>I64_MAX</code> is returned instead (one smaller than the "real" absolute value would be).</p>
<pre><code class="language-ft">use Core.print
use Core.math

def main():
    i32 x = -2_147;
    print($"abs({x}) = {abs(x)}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>abs(-2147) = 2147
</code></pre>
</blockquote>
<h2 id="min"><a class="header" href="#min">min</a></h2>
<p>The <code>min</code> function simply returns the minimum of two given values.</p>
<pre><code class="language-ft">use Core.print
use Core.math

def main():
    i32 x = 121;
    i32 y = 234;
    print($"min({x}, {y}) = {min(x, y)}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>min(121, 234) = 121
</code></pre>
</blockquote>
<h2 id="max"><a class="header" href="#max">max</a></h2>
<p>The <code>max</code> function simply returns the maximum of two given values.</p>
<pre><code class="language-ft">use Core.print
use Core.math

def main():
    i32 x = 121;
    i32 y = 234;
    print($"max({x}, {y}) = {max(x, y)}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>max(121, 234) = 234
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="interop"><a class="header" href="#interop">Interop</a></h1>
<p>Interop, or Interoperability is the capability to interact with other languages than the language you are using right now. It is often described as <code>FFI</code>, Foreign Function Interface. Is is an essential part of programming, to use libraries or code of other languages in your project. It makes sharing code much easier, the most popular language as a common denominator between multiple languages is the <code>C</code> programming language. It has evolved much more into a protocol than an actual language (in the context of FFI) over the years. Nearly all languages are able to interact with C code in a way, and Flint is no exception to that.</p>
<p>But Flint's approach to interop is much more generalized and not limited to C, as a matter of fact, you can call into <strong>any</strong> other language using Flint. There are, of course, limitations, especially around the topic of language-specifc constructs (<code>trait</code>s in Rust, <code>class</code>es in C++, etc) but the benefits of a generalized interop approach are immense.</p>
<p>In this chapter, you will learn about the <code>FIP</code>, the <strong>F</strong>lint <strong>I</strong>nterop <strong>P</strong>rotocol, how to use it and how much power it gives you. You will not learn all the FIP internals in this chapter, though, that's a topic for a <a href="beginners_guide/">waaay later</a> chapter. After this chapter, you will be able to call into external C code without any problem. I will not teach you the <code>C</code> programming language here, mind you, just how you can interact with it. But you do not need any prior knowledge in the C programming language for this chapter either, so don't worry, it will all be fine!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h1>
<p>We still need to cover the basics and a bit of internals of the FIP (Flint Interop Protocol) here, especially <strong>what</strong> it is. The FIP is, as it's name suggests, is a protocol for interoperability. The base idea is very simple: Flint handles <em>all</em> extern code as a black box and communicates with separate Interop Modules over the FIP to find out who provides a given function. It's essentially a communication pipeline, similar to a phone line. But let's start at the beginning actually.</p>
<p>FIP is a small, extensible IPC protocol between the Flint Compiler (the <strong>master</strong>) and one or more <strong>Interop Modules</strong> (IMs). Each IM is a helper program that understands a specific language (for example <code>fip-c</code> for C). The compiler asks IMs for symbol information, asks them to compile/produce objects, and receives responses back. Treat the IMs as language-specific assistants: Flint does not try to parse or compile every language itself — it asks the IMs to do the language work and then consumes the results.</p>
<p>Key properties you can rely on:</p>
<ul>
<li><strong>Master / IM separation</strong>: The Flint compiler is the master. IMs are external processes specialized per language; the master talks to them over FIP messages (IPC / sockets)</li>
<li><strong>Extensible by language</strong>: Each IM knows its language. <code>fip-c</code> is the C IM; other IMs can be added for other languages</li>
<li><strong>Config-driven</strong>: Each IM is configured by its own TOML file (e.g. <code>fip-c.toml</code>) and the project-level <code>.fip</code> directory stores cache and metadata.</li>
<li><strong>Object outputs</strong>: IMs can compile sources code and return object files that the compiler links into the final binary. This keeps debug info intact and makes stepping into native code possible from a debugger.</li>
<li><strong>Binding-less usage</strong>: Because IMs can parse headers and produce objects, you can call C code from Flint without ever hand-writing bindings.</li>
</ul>
<p>In this chapter you will learn how to configure and use the FIP effectively. So, let's dive straight in, shall we?</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="defining-external-functions"><a class="header" href="#defining-external-functions">Defining External Functions</a></h1>
<p>First of all, we need to actually define a function we want to use from the extern code. Let's start with the C code for this example. Create a file named <code>hello.h</code> in the root directory of your project, it should contain this code:</p>
<pre><code>#include &lt;stdio.h&gt;

void hello() {
    printf("Hello from C!\n");
}
</code></pre>
<p>Then you need to write the following code into your <code>main.ft</code> file:</p>
<pre><code class="language-ft">extern def hello();

def main():
    hello();
</code></pre>
<p>As you can see, we can define <code>extern</code> functions simply by adding the <code>extern</code> keyword in front of the function definition. What you also can see is that the function does not have a body. Adding a body to extern functions is actually not allowed, and it will result in a compile error.</p>
<p>You can now try to compile the Flint file using the command</p>
<pre><code class="language-sh">flintc --file main.ft
</code></pre>
<p>You should see a output like the following:</p>
<blockquote>
<pre><code>Parse Error at main.ft:1:1
└─┬┤E0000│
1 │ extern def hello();
┌─┴─┘
├─ Defined 'extern' function without the FIP running and active
└─ Check your configs in '.fip/config/' to see if there are any problems with it
</code></pre>
</blockquote>
<p>This tells us that FIP is not active in the compiler yet, but how comes that? FIP is only active and activated when there exists a <code>.fip</code> directory containing a <code>config</code> directory containing a <code>fip.toml</code> configuration file. If the configuration file is faulty or nonexistent, FIP will not launch, so calling external functions will not work. To resolve this, you need to create a <code>.fip</code> directory in your source directory and in that create a <code>config</code> directory and put a <code>fip.toml</code> file in there. The <code>fip.toml</code> should look like this:</p>
<pre><code class="language-toml">[fip-c]
enable = true
</code></pre>
<p>We also need to create a <code>fip-c.toml</code> configuration file to be able to use the extern defined <code>.h</code> header file. Create a <code>fip-c.toml</code> file in the config directory, it should look like this:</p>
<pre><code class="language-toml">compiler = "gcc"
sources = ["hello.h"]
compile_flags = []
</code></pre>
<p>The resulting file structure should look like this:</p>
<pre><code>.fip/
 └─ config/
     ├─ fip.toml
     └─ fip-c.toml
hello.h
main.ft
</code></pre>
<p>With these configuration files added, let's try to compile the program again:</p>
<pre><code class="language-sh">flintc --file main.ft
</code></pre>
<p>And now we... still see the same error? Yes. FIP is based on the concept of Interop Modules, and we will fix our problem in the next chapter!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="interop-modules"><a class="header" href="#interop-modules">Interop Modules</a></h1>
<p>Interop Modules (IMs) are the small individual pieces which are repsponsible for external languages. For this chapter we will focus on the <code>fip-c</code> IM. So, the project from the previous page is still broken and results in a compilation error, and we now want to fix that situation. FIP is based on the idea of IMs, and which IMs are available is entirely project-dependent, not system-dependent. The IMs are generally pretty small, the <code>fip-c</code> module, for example, is only <code>170 KB</code> in size.</p>
<p>Based on the fact that IMs are very small, the decision has been made to make IMs entirely project-dependant. This means that IMs cannot be installed system-wide, but need to be provided in every project that uses them. So, let's go about fixing the problem from the last chapter. You need to crate yet another directory withing the <code>.fip</code> directory: <code>modules</code>. You then need to go to the fip releases page <a href="https://github.com/flint-lang/fip/releases">here</a> and download the <code>fip-c</code> executable. You need to put that executable into the <code>modules</code> directory. You also need to create a <code>cache</code> directory, but you can keep it empty. Your folder structure should look like this now:</p>
<pre><code>.fip/
 ├─ cache/
 ├─ config/
 │   ├─ fip.toml
 │   └─ fip-c.toml
 └─ modules/
     └─ fip-c
hello.h
main.ft
</code></pre>
<p>And now, finally, when running the command</p>
<pre><code class="language-sh">flintc --file main.ft
</code></pre>
<p>yet again. Because compilation now succeeded, you will see absolutely no output, but the <code>main</code> executable has been created. When running the compiled program you will see this line printed to the console:</p>
<pre><code>Hello from C!
</code></pre>
<p>That was a lot to do just to get interop up and running, I admit that. But this whole process can (and will) be done using tools too. The <code>flint</code> executable (or maybe the <code>flintc</code> executable should handle that, I am not sure yet) will contain the capability to set up FIP for us. But, let's talk about all those directories, what they do and why they exist. First, let's talk about the <code>modules</code> directory and what the content in the <code>fip.toml</code> <em>actually</em> means. The <code>fip.toml</code> file has a very simple content, it's just these two lines:</p>
<pre><code class="language-toml">[fip-c]
enable = true
</code></pre>
<p>This essentially tells the compiler to search for the <code>fip-c</code> module in the <code>.fip/modules/</code> directory and to start it when the compiler starts up. It essentially tells the compiler that the module exists and should be used by it. And then we have the <code>fip-c.toml</code> file. It only contains three entires, which are all not special at all:</p>
<pre><code class="language-toml">compiler = "gcc"
sources = ["hello.h"]
compile_flags = []
</code></pre>
<p>The <code>compiler</code> field tells the <code>fip-c</code> module which compiler to use to compile the C source file(s), in our case it's <code>gcc</code>. And then we have the <code>sources</code> field. It's an array of filepaths to all the header or source files we interact with and we want to call into. You may noticed that we have not written any bindings or wrappers for the C functions at all, we just declared a function to be extern and then used it inside of Flint, and FIP figured out the rest for us. Okay, let's edit our header file and add another function to it, this time adding two numbers together:</p>
<pre><code>#include &lt;stdio.h&gt;

void hello() {
    printf("Hello from C!\n");
}

int add(int x, int y) {
    return x + y;
}
</code></pre>
<p>And then we also need to update the <code>main.ft</code> file:</p>
<pre><code class="language-ft">use Core.print

extern def hello();
extern def add(i32 x, i32 y) -&gt; i32;

def main():
    hello();
    print($"add(1, 8) = {add(1, 8)}\n");
</code></pre>
<p>And when we then try to compile this program we get yet another error:</p>
<pre><code>[Master]:  The function 'add' could not be resolved
Error: Failed to parse file "main.ft"
</code></pre>
<div class="warning">
<p>This error message is not final, since it does not contain any information to <em>what</em> actually failed.</p>
<p>You need to use <code>flintc-debug</code> for the time being to actually find out what went wrong. When looking at the FIP logs, which start with <code>[Master]:</code> or <code>[Slave N]:</code> you can find out which symbols the <code>fip-c</code> module found and which symbol the Flint Compiler is searching for. You can find these lines in the output of the <code>flintc-debug</code> build:</p>
<pre><code>[Slave 1]: Found extern function: 'hello' at line 3
[Slave 1]:   Function Signature:
[Slave 1]:     name: hello
[Slave 1]: Found extern function: 'add' at line 7
[Slave 1]:   Function Signature:
[Slave 1]:     name: add
[Slave 1]:     arg[0]: mut i32
[Slave 1]:     arg[1]: mut i32
[Slave 1]:     ret[0]: mut i32
[Slave 1]: Found 2 extern functions in hello.h
</code></pre>
<p>And later on</p>
<pre><code>[Slave 1]: Symbol Request Recieved
[Slave 1]:   Function Signature:
[Slave 1]:     name: add
[Slave 1]:     arg[0]: const i32
[Slave 1]:     arg[1]: const i32
[Slave 1]:     ret[0]: mut i32
</code></pre>
<p>And here you can actually see what the problem is. It's a signature mismatch.</p>
</div>
<p>Remember that all function parameters of Flint are implicitely <code>const</code> except marked as <code>mut</code> explicitely, and that's exactly the mismatch happening here. The <code>fip-c</code> module found the function <code>int add(int x, int y)</code> which has the signature <code>add(mut i32, mut i32) -&gt; i32</code> in C, and we expected to find a function <code>add(const i32, const i32) -&gt; i32</code> defined in Flint. To resolve this problem we either need to edit the C code or edit the signature of our Flint function. Often times you will deal with C libraries you will not be able to change, so changing the Flint function signature would be the "correct" thing to do in such cases, so we now simply change this line:</p>
<pre><code class="language-ft">extern def add(i32 x, i32 y) -&gt; i32;
</code></pre>
<p>to this line:</p>
<pre><code class="language-ft">extern def add(mut i32 x, mut i32 y) -&gt; i32;
</code></pre>
<p>And now when we compile and run the program we will get this output:</p>
<blockquote>
<pre><code>Hello from C!
add(1, 8) = 9
</code></pre>
</blockquote>
<p>As you can see, it is very important that signatures match exactly when calling extern functions. Matching signatures is the basis of FIP, and we will talk more about which Flint types relate to which C types so that you do not need to wonder what went wrong.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="signatures"><a class="header" href="#signatures">Signatures</a></h1>
<p>First, we need to get a basic fact about FIP out of the way. Because C has evolved more or less into an interop standard over the years, nearly all types of all languages are somewhat translatable to C types, and the FIP is definitely based on that. FIP can <em>only</em> express types which are also present in C, which means it <em>could</em> essentially represent <em>every</em> possible type of a language. But for simplicity and other reasons (like memory safety), interoperability of a few types is prohibited. These are the prohibited types, which you <strong>cannot</strong> have contained inside of extern definitions:</p>
<ul>
<li><code>entity</code> types</li>
<li><code>func</code> types</li>
<li><code>optional</code> types</li>
<li><code>variant</code> types</li>
<li><code>fn</code> types</li>
<li><code>bp</code> types</li>
</ul>
<p>These types are prohibited because other languages may define them in a different way, so when you call a function from Rust which has an <code>Option&lt;T&gt;</code> argument type and you set the extern signature in Flint to <code>T?</code> we cannot guarantee that both ends convey to the same type under the hood, as C has no concept of optionals.</p>
<p>Many of those types will be introduced in later chapters, don't worry about them for now. But let's get into the topic of this chapter now and let's discuss how each Flint type will translate into C types. This is done through tables, it's just the most convenient and efficient this way.</p>
<h2 id="primitives"><a class="header" href="#primitives">Primitives</a></h2>
<p>The first and most logical beginning point are primitive types. The only outlier are strings essentially, but let's look at each type.</p>
<div class="table-wrapper"><table><thead><tr><th>Flint Type</th><th>C Eqivalent</th></tr></thead><tbody>
<tr><td>bool</td><td>bool</td></tr>
<tr><td>u8</td><td>unsigned char</td></tr>
<tr><td>u32</td><td>unsigned int</td></tr>
<tr><td>u64</td><td>unsigned long</td></tr>
<tr><td>i32</td><td>int</td></tr>
<tr><td>i64</td><td>long</td></tr>
<tr><td>f32</td><td>float</td></tr>
<tr><td>f64</td><td>double</td></tr>
<tr><td>str</td><td>char*</td></tr>
</tbody></table>
</div>
<p>Of course, all the types on the left and right do not match in their mutability, as of the last example. To change the C mutability you can simply put <code>const</code> in front, and on Flint you can put <code>mut</code> or <code>const</code> in front.</p>
<p>Re-sizing and relocating the string inside of C will result in a crash inside of Flint, as the string it pointed to is no longer valid, so be aware that interoping with C could very well break stuff in wonky ways.</p>
<h2 id="data-1"><a class="header" href="#data-1">Data</a></h2>
<p>Flint's data is essentially a struct annyway, so interop with C is very easy. This following data type:</p>
<pre><code class="language-ft">use Core.print

data MyData:
    i32 x;
    i32 y;
    f32 speed;
    bool is_something;
    MyData(x, y, speed, is_something);

extern def do_something(MyData md) -&gt; MyData;

def main():
    md := MyData(10, 10, 3.2, false);
    print($"md.(x, y, s, i) = ({md.x}, {md.y}, {md.speed}, {md.is_something})\n");
    md = do_something(md);
    print($"md.(x, y, s, i) = ({md.x}, {md.y}, {md.speed}, {md.is_something})\n");
</code></pre>
<p>is directly translatable to this C struct type:</p>
<pre><code>typedef struct {
    int x, y;
    float speed;
    bool is_something;
} MyData;

MyData do_something(const MyData md) {
    MyData result = {0};
    result.x = md.x + 2;
    result.y = md.y + 5;
    result.speed = md.speed / 2;
    result.is_something = true;
    return result;
}
</code></pre>
<p>This code will produce this output:</p>
<blockquote>
<pre><code>md.(x, y, s, i) = (10, 10, 3.2, false)
md.(x, y, s, i) = (12, 15, 1.6, true)
</code></pre>
</blockquote>
<p>So, a function expecting a struct as it's parameter in C can be called like above directly. Note that there exists a specific chapter talking about pointer types, so the C function <code>MyData do_something(const MyData *md)</code> will have a different Flint signature, but you will learn about this later.</p>
<p>FIP handles all the ABI-specifics for you, so you can call into C functions and pass structs to them without ever writing any bindings yourself.</p>
<p>But there is more to talk about. First of all, FIP absolutely does not care what <em>names</em> you gave your structs. The <code>MyData</code> type will look like this for FIP: <code>{ i32, i32, f32, bool }</code>. The <code>{</code> and <code>}</code> are the structure symbols, all types within these are members of the struct FIP handles. So, this means that you can do something like this without a problem:</p>
<pre><code class="language-ft">use Core.print

data MyData:
    i32 x;
    i32 y;
    f32 speed;
    bool is_something;
    MyData(x, y, speed, is_something);

data SomeData:
    i32 x;
    i32 y;
    f32 z;
    bool w;
    SomeData(x, y, z, w);

extern def do_something(MyData md) -&gt; MyData;
extern def do_something(SomeData md) -&gt; SomeData;

def main():
    md := MyData(10, 10, 3.2, false);
    print($"md.(x, y, s, i) = ({md.x}, {md.y}, {md.speed}, {md.is_something})\n");
    md = do_something(md);
    print($"md.(x, y, s, i) = ({md.x}, {md.y}, {md.speed}, {md.is_something})\n");

    sd := SomeData(10, 10, 3.2, false);
    print($"sd.(x, y, s, i) = ({sd.x}, {sd.y}, {sd.z}, {sd.w})\n");
    sd = do_something(sd);
    print($"sd.(x, y, s, i) = ({sd.x}, {sd.y}, {sd.z}, {sd.w})\n");
</code></pre>
<p>Note that the C header file stayed exactly the same, it did not change. We actually call <strong>the same</strong> C function twice, just with "different" data. They are different data types in Flint, but what FIP is concerned, they are both just <code>{ i32, i32, f32, bool }</code> without any name. Conceptually this should work, but we have decided to not let this code be valid, because the moment you try to reference the same external C function twice through different code paths, the codebase becomes <em>really</em> messy <em>really</em> quick. So, this example should work conceptually, but it will result in this compile error:</p>
<blockquote>
<pre><code>Generation Error at main.ft:18:1
└──┬┤E0000│
18 │ extern def do_something(SomeData md) -&gt; SomeData;
┌──┴─┘
├─ Defined extern function 'do_something' twice
└─ It was first defined at main.ft:17:1
</code></pre>
</blockquote>
<p>There is no reason to why it could not work, other than compiler internal complexity and resulting code complexity. If you want to call the same underlying external functions from two different types, you have done something wrong when designing your code, so this definitely is not the fault of FIP or the Flint Compiler.</p>
<h2 id="multi-types-1"><a class="header" href="#multi-types-1">Multi-Types</a></h2>
<p>Flint has builtin vector types, the multi-types, as you know. These types are actually represented as true vector types inside of LLVM IR code, nut just structs, but C does not have true vector types (native to the language, without compiler extensions). So we cannot add vector types to FIP since C does not have them, and FIP has to be C-compatible with it's internal types, as discussed earlier. Which type should multi-types be converted to, then? Well, they are just converted to simple structs before passing them to C. The multi-type <code>f32x3</code> becomes <code>{ f32, f32, f32 }</code> for example, or <code>i64x2</code> becomes <code>{ i64, i64 }</code>. There really is nothing special about it at all, but the complications of this design are very nice.</p>
<p>You see, A LOT of different libraries, especially those related to math, rendering or something vector-related provide their own types, like raylib's <code>Vector3</code> struct, for example. So, this allows us to write something like the following:</p>
<pre><code>typedef struct {
    float x, y, z;
} Vector3;

Vector3 add(const Vector3 v1, const Vector3 v2) {
    return Vector3{v1.x + v2.x, v1.y + v2.y, v1.z + v2.z};
}
</code></pre>
<pre><code class="language-ft">use Core.print

extern def add(f32x3 v1, f32x3 v2) -&gt; f32x3;

def main():
    f32x3 v1 = (1.2, 2.3, 4.5);
    f32x3 v2 = (12.5, 66.8, 35.98);
    f32x3 res = add(v1, v2);
    print($"res = {res}\n");
</code></pre>
<p>Which will print this line to the console:</p>
<blockquote>
<pre><code>res = (13.7, 69.100006, 40.48)
</code></pre>
</blockquote>
<p>So, what does this mean for Flint? Because multi-types are lowered to structs when calling extern functions, you can absolutely interacti with C functions and directly pass in your multi-type vectors to them or recieve them from the C functions. You could for example do all vector operations within Flint, since all multi-types utilize SIMD instructions under the hood, and then just pass them to the C code for rendering etc.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="from-intermediate-to-expert"><a class="header" href="#from-intermediate-to-expert">From Intermediate to Expert</a></h1>
<p>Welcome to the Intermediates guide! In this guide you will learn new and bigger concepts of Flint and also become more familiar with how Flint handles various systems and <em>stuff</em> under the hood. Being great in a language does not necessarily only mean knowing all it's syntax, but clearly understanding <em>what</em> the language does under the hood for you and then choosing the right feature for the job, based on this holistic knowledge of the language. While you will not learn <strong>everything</strong> that's going on under Flint's hood in this guide (Thats more for the expert's guide), you will learn quite a lot of new concepts and features which make your life using Flint much easier.</p>
<p>The goal of this guide is not only to teach the <em>how</em> but also the <em>why</em>, which is equally as important. Flint is open source, so the more you understand about the language itself the more you essentially understand about it's compiler, as the compiler is just a "mapper" which maps semantic concepts to machine code, and if you know exactly which behaviour it needs to map you essentially understand the compiler as well.</p>
<p>So, let's get started!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="optionals"><a class="header" href="#optionals">Optionals</a></h1>
<p>Welcome to the first chapter of the intermediates guide. In this first chapter we look at the optional type and what you can do with it. Other languages don't necessarily "need" an optional type because of other designs like Java's <code>null</code>, C's <code>NULL</code> or C++'s <code>nullptr</code>. In Flint, however, not every varaible or "object" can be "null" or "empty" implicitely.</p>
<h2 id="what-are-optionals"><a class="header" href="#what-are-optionals">What are Optionals?</a></h2>
<p>An optional is essentially just a struct under the hood, composed of a boolean value whether the optional has a value followed by the actual data of the optional. So an optional looks like <code>{ i1, T }</code> in memory. Optionals are crucial to be able to build up "possible" values (or possible absence of values) which is the basis of linked lists, for example, and much much more.</p>
<h2 id="why-are-optionals-important"><a class="header" href="#why-are-optionals-important">Why are Optionals Important?</a></h2>
<p>Optionals are an essential part of Flint because they allow you to:</p>
<ul>
<li>Describe the possibility of a value's absence</li>
<li>Make initialization able to be "lazy"</li>
</ul>
<h2 id="what-to-expect-4"><a class="header" href="#what-to-expect-4">What to Expect</a></h2>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Declaring and using optional variables</li>
<li>Unwrapping and force-unwrapping of optional variables</li>
<li>Comparing optional values with one another</li>
<li>Providing default values through the null coalescence operator</li>
<li>Switching on optional values</li>
<li>Building optional chains through the optional chaining operator</li>
<li>Using optionals for references</li>
<li>Building linked lists through optionals</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h1>
<p>In Flint, we need to explicitely define which values possibly have no value. There is no implicit nullability like in other languages, nullability is very explicit in Flint, and that's a good thing. This means that we do not check everywhere if our object maybe is null, because when it's not an optional type it is <strong>required</strong> to be initialized, as there <em>is no uninitialized state in Flint</em>.</p>
<p>We do this through the optional type. Optional values can either have a value or they can be "empty". This "empty" state is achieved through the <code>none</code> literal. If an optional variable is set to <code>none</code> it effectively has no longer any value stored on it. But let's look at optionals in an example, they are best understood through examples:</p>
<pre><code class="language-ft">def main():
    i32? maybe = none;
</code></pre>
<p>This program will not print anything to the console, but we can see quite some things already. As you can see, an optional type is defined directly inline by just slapping a question mark at the end of the type. This makes the whole type optional, which means it now can be "nothing". You can see this through us assigning <code>none</code> to the <code>maybe</code> variable.</p>
<p>Let's discuss what actually happens here under the hood within the compiler and within Flint itself. You already know what a <code>struct</code> is in other languages, and in Flint thats either an anonymous tuple or <code>data</code>. So, an optional is essentially nothing else than a small struct containing of a <code>bool</code> value together with the <em>actual</em> value of the optional. In the case of our optional, this means that <code>maybe</code> is essentially the same as if we would write:</p>
<pre><code class="language-ft">def main():
    data&lt;bool, i32&gt; maybe = (false, 0);
</code></pre>
<p>A boolean <code>false</code> is simply <code>0</code> in memory, as you already know. The <code>none</code> literal literally just stores zeroes on the entire optional structure. It's a <code>zeroinitializer</code> if you know this from C, its a <code>{0}</code>. Because the flag is 0 when false we can set all values to zeroes through the <code>none</code> type. This means that the <code>value</code> field of the optional structure will also be set to zeroes when storing a <code>none</code> literal on it. But here, when using the tuple, we need to specify the <code>value</code> we want to store in it, even if we want to store <code>none</code> (<code>(false, 0)</code>) on it.</p>
<p>Because we store all-zeroes on the optional when storing <code>none</code> on it, you now may be able to see that accessing the value of an optional when there is nothing stored in it can be considered as an error, as it's all just zeroes. But how do we even access the value of an optional variable in the first place? You will learn this in the next chapter!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="unwrapping"><a class="header" href="#unwrapping">Unwrapping</a></h1>
<p>Unwrapping is the act of recieving / reading the value of an optional variable. When there is nothing stored in the optional, however, it is considered an error to access it's value, as this could lead to wrong and potentially harmful behaviour (like undefined behaviour, nullpointers or many other things that could go wrong).</p>
<p>Because of this very reason Flint decides that accessing the value of an <code>none</code> optional is an error, and the program will crash with a simple message to the console stating that we tried to access the value of an empty optional. But enough talk, here is a small example showcasing exactly that:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32? maybe = 10;
    print($"maybe = {maybe!}\n");

    maybe = none;
    print($"mabye = {maybe!}\n");
    print("after access\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>maybe = 10
Bad optional access occurred
</code></pre>
</blockquote>
<p>Currently, this does not <code>throw</code> an error (like <code>asssert</code> would, for example) but it hard-crashes the program instad. This is open for debate whether it should throw an error and be catchable instead (like an assertion error we then would have a bad optional access error). For now, hard-crashing is fine and works, because accessing an optional which has no value is considered a programmer error, not a user error. But how do we check if the variable has a value, to prevent this crash from happening? You will learn about this in the next chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="comparing-optionals"><a class="header" href="#comparing-optionals">Comparing Optionals</a></h1>
<p>We now know how to access the value of an optional variable, but how do we check if the variable <em>actually</em> holds a valid value at all? It's pretty simple, actually. <strong>Any</strong> optional value can bo compared with the <code>none</code> literal, so we can compare for equality / inequality extremely easily. Here is an example of that:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32? maybe = none;
    if maybe == none:
        print("has no value\n");

    maybe = 69;
    if maybe != none:
        print($"has value: {maybe!}\n");
</code></pre>
<p>This program prints these lines to the console:</p>
<blockquote>
<pre><code>has no value
has value: 69
</code></pre>
</blockquote>
<p>But why can we compare any optional variable with <code>none</code> (including <code>none</code> itself)? Here is a small fun fact on how this is within the compiler: The <code>none</code> literal actually has the type <code>void?</code>, so its either <em>nothing</em> or <em>nothing</em>, so it's really <em>nothing</em> after all!</p>
<p>But we cannot only compare optional values to the <code>none</code> literal, but to other optional values too:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32? maybe_1 = none;
    i32? maybe_2 = none;
    if maybe_1 == maybe_2:
        print("are equal\n");

    maybe_1 = 69;
    if maybe_1 != maybe_2:
        print($"are inequal, maybe_1 = {maybe_1!}, maybe_2 = 'none'\n");

    maybe_2 = 420;
    if maybe_1 != maybe_2:
        print($"are inequal, maybe_1 = {maybe_1!}, maybe_2 = {maybe_2!}\n");

    maybe_2 = 69;
    if maybe_1 == maybe_2:
        print($"are equal, maybe_1 = {maybe_1!}, maybe_2 = {maybe_2!}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>are equal
are inequal, maybe_1 = 69, maybe_2 = 'none'
are inequal, maybe_1 = 69, maybe_2 = 420
are equal, maybe_1 = 69, maybe_2 = 69
</code></pre>
</blockquote>
<p>So, you can see that two variables of type <code>i32?</code> match if either they are both <code>none</code> or their <em>actual</em> values match. If one of them is <code>none</code> but the other one is not, they do not match, and same goes when both have a value but that value differs, then they also do not match. As you can see, we have used quite a bit of unwrapping (<code>!</code>) in this example and the program <em>would</em> definitely crash if we would set both variables to <code>none</code> before the last <code>if</code> statement. So, you still need to use the unwrapping with caution.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="null-coalescing-operator"><a class="header" href="#null-coalescing-operator">Null Coalescing Operator</a></h1>
<p>The Null Coalescing Operator <code>??</code> is a pretty interesting operator in the sense that it "removes" the need for the optional unwrapping operator (in certain scenarios). It is used to provide a "default" value of an optional for the case that the optional is empty. It is a binary operator, like arithmetic operators, but has a very distinct purpose. It is called like that for historical reasons as it is called like that in every other language that has it, alltough we should rather call it the <code>Optional Coalescing Operator</code> in Flint, but that's besids the point.</p>
<p>If we take a varaible <code>x</code> and it is of type <code>i32?</code>, then a binary operator expression using the <code>??</code> operator would return a value of type <code>i32</code>. But let's look at an example maybe, then everything should be more clear:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32? maybe = none;

    i32 x = maybe ?? 0;
    print($"x = {x}\n");

    maybe = 69;
    x = maybe ?? 0;
    print($"x = {x}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>x = 0
x = 69
</code></pre>
</blockquote>
<p>But why? And how does this even work? The null coalescing operator operates on an optional-typed value as it's <code>lhs</code> which is of type <code>T?</code>, where <code>T</code> stands as a "placeholder" type, you can put any type you want in there. If the <code>lhs</code> of the <code>??</code> operator is of type <code>T?</code> then the <code>rhs</code> of the operator <strong>must be</strong> of type <code>T</code> and the result of the null coalescing expression will <strong>always</strong> be of type <code>T</code>.</p>
<p>In our case this means that the <code>lhs</code> has the type <code>i32?</code> and the <code>rhs</code> has the type <code>i32</code> and the result of the coalescing operation is of type <code>i32</code> as well. The operator essentailly just does these things:</p>
<ul>
<li>Does the <code>lhs</code> have a value?</li>
<li>If yes, take that value and unwrap it</li>
<li>Else, take the provided default-value from the <code>rhs</code></li>
</ul>
<p>So, it is simply impossible to get an hard crash with the null coalescing operator, unlike the unwrap operator which crashes when the optional is empty. But, it is not possible to provide default values in all cases. The null coalescing operator will become extremely important in the area of <code>linearization</code> in a much later chapter when we come around to <code>Blueprints</code> but it's still a long journey until then.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="switching-on-optionals"><a class="header" href="#switching-on-optionals">Switching on Optionals</a></h1>
<p>We can also switch on optional values to gain access to their stored value as well. The syntax for switching on optionals is a bit different than the syntax on switching on enums. The <code>switch</code> statement and expression have different syntax based on the type they switch on, it is the only statement in Flint where this is true (except for the pipe operator <code>|&gt;</code>). But let's have a look at a simple example:</p>
<pre><code class="language-ft">use Core.print

def main():
	i32? maybe = none;

	switch maybe:
		none: print("none\n");
		v: print($"value = {v}\n");

	maybe = 69;
	switch maybe:
		none: print("none\n");
		v: print($"value = {v}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>none
value = 69
</code></pre>
</blockquote>
<p>As you can see, we have one switch branch for the <code>none</code> case, where there isn't anything stored in the optional value at all, and we have one case for the value case. But what is that <code>v</code> there? <code>v</code> is like a "variable declaration" here, it's just a name we give to access the value field of the optional directly. Note that the type of the <code>v</code> "variable" is <code>i32</code> here, so we can not set the variable <code>maybe</code> to be <code>none</code> through the <code>v</code> variable.</p>
<p>But what we can do is do a little "trick". You see, the variable <code>v</code> gives us a direct mutable reference to the value field of <code>maybe</code>, it's not simply a <em>copy</em> of the value field, it's a <em>reference</em> to it, as seen in the next code example:</p>
<pre><code class="language-ft">use Core.print

def main():
    i32? maybe = 30;
    print($"value = {maybe!}\n");

    switch maybe:
        none: print("none\n");
        v: v = 10;
    print($"value = {maybe!}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>value = 30
value = 10
</code></pre>
</blockquote>
<p>So, this mutability actually allows us to circumvent Flint's safety mechanisms around accessing the value field of an empty optional variable, which is rather interesting:</p>
<pre><code class="language-ft">use Core.print

def main():
	i32? maybe = 30;

	switch maybe:
		none: print("none\n");
		v:
			print($"v = {v}\n");
			maybe = none;
			print($"v = {v}\n");
</code></pre>
<p>This code will print these lines to the console:</p>
<blockquote>
<pre><code>v = 30
v = 0
</code></pre>
</blockquote>
<p>So, you are not allowed to access the value when there is nothing stored on it but if there <em>was</em> something stored on it and you <em>still</em> have the reference to the value field you can actually still modify it. Maybe we will add a system to detect and prevent this behaviour, but it's very funny in my opinion that you can do it at all.
Also, this is a great example to showcase the behaviour of the <code>none</code> assignment we have talked about earlier, that the <code>none</code> literal is literally a zeroinitializer of the given type it is meant to be stored at. In our <code>i32?</code> example that's not a big deal, the value is just set to 0, but think about what happens if that would have been a <code>str?</code>. Strings are not "stack"-allocated in Flint, so they are pointers under the hood. And all values set to 0 interpreted as a pointer is a <code>nullptr</code>, so accessing the value would crash our program, but with a mysterious <code>Segmentation Fault</code> instead.</p>
<p>So, keep your eyes open for this "bug" (or "feature" if you will) as it could be not what you would want. In this simple example it is clear that we should not do <code>maybe = none</code>, but what if that would be a function call instead and somewhere down the line the optional is set to <code>none</code> and then we try to use the value <code>v</code> after the call? That's where the problems start to happen. So, as a general rule of thumb: Try avoiding the variable which is switched on within the value block of the switch entirely, you should <em>only</em> access the value field directly, not the switched-on variable. (Maybe we could make this into a compiler-rule, as this then would not be a runtime-check but a compile-time check to see if the variable that's switched on is accessed in the value-block).</p>
<p>We can also put the switch statement in a separate function entirely and pass the optional value to said function. The optional value will be passed by reference, not by value, so this means that any modifications to the optional will be visible at the callers side as well:</p>
<pre><code class="language-ft">use Core.print

def print_opt(i32? value):
	switch value:
		none: print("none\n");
		v: print($"value = {v}\n");

def set_value(mut i32? opt, i32 value):
	opt = value;

def main():
	i32? maybe = none;
	print_opt(maybe);

	maybe = 69;
	print_opt(maybe);

	set_value(maybe, 20);
	print_opt(maybe);
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>none
value = 69
value = 20
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="optional-chaining"><a class="header" href="#optional-chaining">Optional Chaining</a></h1>
<p>Optional chaining is quite interesting in Flint. You already have seen the <code>!</code> operator. You have been told until now that this operator is an <em>unary</em> operator, but that was not quite correct, actually. It's one of Flint's few "in-between operators" (There is no industry standard name for them, actually). One "in-between operator" is the dot <code>.</code>, actually. When you do a <code>var.field</code> the <code>.</code> is an operator itself. This operator has no clear name either, as it is used quite often in quite a lot of places. But, similar to how you can write the dot <code>.</code> "in-between" two identifiers to <strong>form</strong> an expression, the optional chaining operators <code>!</code> and <code>?</code> are used to <strong>form</strong> an expression too.</p>
<h2 id="foce-unwrapping-operator"><a class="header" href="#foce-unwrapping-operator">Foce-Unwrapping Operator</a></h2>
<p>Let's look at a very simple example with the unwrapping-operator, as you already know that one:</p>
<pre><code class="language-ft">use Core.print

data Vec2:
	i32 x;
	i32 y,
	Vec2(x, y);

def main():
	Vec2 v2 = Vec2(10, 20);
	Vec2? v2m = v2;

	i32 x = v2m!.x;
	print($"x = {x}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>x = 10
</code></pre>
</blockquote>
<p>As you can see, the optional force-unwrap operator <code>!</code> can not only be used as an unary operator (at the end of an expression) but as an "in-between operator" (i will call them <em>innies</em> from now on) as well. The above code showcases exactly what that operator does. It, again, force-unwraps the lhs and allows us to access it as if it was no optional. But, it will still hard-crash if there is no value stored in the unwrapped optional. We can also unwrap multiple fields of the vector at once:</p>
<pre><code class="language-ft">use Core.print

data Vec2:
	i32 x;
	i32 y,
	Vec2(x, y);

def main():
	Vec2 v2 = Vec2(10, 20);
	Vec2? v2m = v2;

	(x, y) := v2m!.(x, y);
	print($"(x, y) = ({x}, {y})\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>(x, y) = (10, 20)
</code></pre>
</blockquote>
<p>And we can do array-accesses as well:</p>
<pre><code class="language-ft">use Core.print

def main():
	i32[]? arr = i32[10](9);
	print($"arr[4] = {arr![4]}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>arr[4] = 9
</code></pre>
</blockquote>
<p>In general, the optional force-unwrap operator can be used <strong>exactly</strong> the same way as if the variable would not be an optional at all. A normal array access would be <code>arr[4]</code>, optional it's <code>arr![4]</code>, so it's only the single operator added in between the "normal" operation on the variable.</p>
<h2 id="optional-chaining-operator"><a class="header" href="#optional-chaining-operator">Optional Chaining Operator</a></h2>
<p>The Optional Chaining Operator <code>?</code>, however, is quite a bit more complex to use and understand, but you will get the hang of it pretty quickly for sure. It is used <em>exactly</em> like the optional force-unwrapping operator <code>!</code> but it has a bit different semantics. When you force-unwrap an optional of type <code>T?</code> the result will be of type <code>T</code>. But, the optional chaining operator works a bit different. Here is an example:</p>
<pre><code class="language-ft">use Core.print

data Vec2:
	i32 x;
	i32 y,
	Vec2(x, y);

def main():
	Vec2 v2 = Vec2(10, 20);
	Vec2? v2m = v2;

	i32? x = v2m?.x;
	if x == none:
		print("has no value!\n");
	else:
		print($"x! = {x!}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>x! = 10
</code></pre>
</blockquote>
<p>As you can see, the optional chaining operator does <em>not</em> "remove" the optionality entirely, as now the variable <code>v2m</code> still <em>could</em> be <code>none</code>. If the "base expression" of an optional chain is <code>none</code> the whole optional chain will resolve to <code>none</code>, no matter how long that chain may be. The above example is not quite useful, as we could just check for the presence of a value in <code>v2m</code> directly here, but think about nested optionals and you want to access a field deep inside the structure, you then could stack optional chains together and get <em>one</em> value in <em>one</em> expression. Here is a small example of that:</p>
<div class="warning">
<p>Nested optional chains do not work properly yet</p>
<p>I am working on getting them up and running, but they do not work yet. The semantics and syntax of them is already fixed, though, so what you see below will not change much in the future.</p>
</div>
<pre><code class="language-ft">use Core.print

data Vec2:
	i32 x;
	i32 y,
	Vec2(x, y);

data Nested:
	Vec2? v2m;
	Nested(v2m);

def main():
	Vec2 v2 = Vec2(10, 20);
	Vec2? v2m = v2;
	Nested n = Nested(v2m);
	Nested? nm = n;

	i32? x = nm?.v2m?.x;
	if x == none:
		print("one value in the chain has has no value!\n");
	else:
		print($"x! = {x!}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>x! = 10
</code></pre>
</blockquote>
<p>As you can see, optional chains allow you to access fields deep inside optional chains. And now we can also talk about what type an optional chain has. The whole chain does <strong>always</strong> have the type of the rightmost operation wrapped in an optional. An operation could be a call, an access, or anything else, realistically. But it's important to know that <strong>the whole chain has either the value as it's end or it had a <code>none</code> value somewhere in between thus resulting in <code>none</code> itself</strong>.</p>
<p>You can also mix and match optional chains with optional force-unwrapping. In the above example, we can for example write <code>nm!.v2m?.x</code> and have a force-unwrap on the nested but a optional chain on the vec itself. This style also <strong>clearly communicates intent</strong>. From this small snippet you can directly see the assertions of the programmer: The programmer asserts that <code>nm</code> will <em>always</em> have a value, whereas <code>v2m</code> within <code>nm</code> could <em>potentially</em> be <code>none</code>, so you need to handle that <em>potential</em> case of the value's absence. It's not only a nicee QOL improvement, but it also very clearly communicates intent, without a single comment written. Also, the <code>!</code> and <code>?</code> are unique to optionals, so whenever you find one of those operators you can be <em>sure</em> that there is an optional in play. Well, that operator exists in a different form for variants as well, namely the <code>!(T)</code> and <code>?(T)</code> operator, but you will learn about variants in the next chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="optionals-as-references"><a class="header" href="#optionals-as-references">Optionals as References</a></h1>
<p>Flint does not have pointer or reference types, as you know. But optionals <strong>are</strong> implicitely this missing reference-type piece. For all complex data types, which are stored in DIMA slots, optionals become reference types to other data. You will learn why this is like it is much much later when we actually talk about DIMA, but for now just remember that optional complex data types are references. Let's look at a small example to showcase this:</p>
<pre><code class="language-ft">use Core.print

data MyData:
	i32 x;
	f32 y;
	str v;
	MyData(x, y, v);

def main():
	MyData md = MyData(-5, 3.14, "Hello There");
	MyData? ref = md;

	ref!.(x, y) = (7, 6.28);

	print($"md.(x, y, v) = ({md.x}, {md.y}, \"{md.v}\")\n");
</code></pre>
<p>This example will print this line to the console:</p>
<blockquote>
<pre><code>md.(x, y, v) = (7, 6.28, "Hello There")
</code></pre>
</blockquote>
<p>As you can see, we do not modify <code>md</code> directly. We only modify the optional <code>ref</code>, but the optional <code>ref</code> internally is a reference to the data of <code>md</code>.</p>
<div class="warning">
<p>Because DIMA does not exist yet, be cautious with references.</p>
<p>DIMA will include ARC and will handle the case when the "owner" of the data (in our case <code>md</code>) goes out of scope but the optional does not. Because DIMA is not implemented yet, this code:</p>
<pre><code class="language-ft">MyData? ref = none;
if true:
	MyData val = MyData(10, 3.14, "segfault");
	ref = val;
print($"ref.x = {ref!.x}\n");
</code></pre>
<p>will cause a segmentation fault of the program. You <em>need</em> to be aware of this current limitation when using optionals.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="list-example"><a class="header" href="#list-example">List Example</a></h1>
<p>Now that we have optionals at our disposal and we know that optionals are references to actual values, we can build our first liked list in Flint! If you want to learn more about what a linked list actually is, i recommend you to look <a href="https://www.w3schools.com/dsa/dsa_theory_linkedlists.php">here</a>. Let's look at how a linked list looks in Flint:</p>
<pre><code class="language-ft">use Core.print

data IntList:
	i32 value;
	IntList? next;
	IntList(value, next);

def append(mut IntList list, i32 value):
	if list.next == none:
		list.next = IntList(value, none);
	else:
		append(list.next!, value);

def print_list(IntList list):
	print($"{list.value}");
	if list.next != none:
		print(" -&gt; ");
		print_list(list.next!);
	else:
		print("\n");

def main():
	IntList list = IntList(10, none);
	print_list(list);
	append(list, 20);
	print_list(list);
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>10
10 -&gt; 20
</code></pre>
</blockquote>
<p>The program might seem intimidating at first, but let's unpack it bit by bit. First, we defined our <code>IntList</code> data type with a body representing it's value and an optional next element in the list. We have gone through the fact that optionals which hold complex data types actually hold references to data internally. So, we use the <code>IntList?</code> typed field for the next element in the linked list. We could put anything and any field inside our <code>IntList</code> definition. This also is the absolute most basic form of a linked list there is. When entities work eventually, we will learn quite a lot of more complex list examples.</p>
<p>You can try around a bit. Write a <code>prepend</code> function, or write a function which prints the list in reverse order. Try around a bit in the list example. If you can fully create, understand and extend the list example you will get a feeling for optionals in Flint quicker than you might think.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="variants"><a class="header" href="#variants">Variants</a></h1>
<p>Welcome to the second chapter of the intermediates guide. In this chapter we look at the variant type and what you can do with it. The <code>variant</code> type is used to define a type that could be <strong>one of</strong> a given collection of other types. Where optionalls allowed us to define <strong>emptiness</strong>, the <code>variant</code> type allows us to define <em>variation</em> in types.</p>
<h2 id="what-are-variants"><a class="header" href="#what-are-variants">What are Variants?</a></h2>
<p>A variant is, once again, essentially just a struct under the hood. It is composed of a 1 Byte flag value to determine which type it holds followed by the actual type of the variant. This "type" as the second value is just <strong>N</strong> bytes of storage, where <code>N</code> is the number of bytes needed to store the <strong>biggest</strong> of all possible types.</p>
<h2 id="why-are-variants-important"><a class="header" href="#why-are-variants-important">Why are Variants Important?</a></h2>
<p>Variants are an essential part of Flint because they allow you to:</p>
<ul>
<li>Describe the possibility that a value might be one of a given kind</li>
<li>Store multiple different "data" in a very small space, as the variant does not occupy space for <em>each</em> value it could be</li>
</ul>
<h2 id="what-to-expect-5"><a class="header" href="#what-to-expect-5">What to Expect</a></h2>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Declaring and using variant types</li>
<li>Tagging variants</li>
<li>Variant Comparison</li>
<li>Force-unwrapping a variant variable</li>
<li>Switching on variant values</li>
<li>Building optional chains through the variant extraction operator</li>
<li>Making variants optional and how variants interact with optionals</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="introduction-3"><a class="header" href="#introduction-3">Introduction</a></h1>
<p>When we want to express the probability that a value could have one of a given collection of types we need to use <code>variant</code>s for it. You may have heard the term <code>tagged union</code> or <code>union</code> in other languages, like C, before. Flint's variants are exactly that.</p>
<p>A Variant in Flint, is defined like this:</p>
<pre><code class="language-ft">variant MyVariant:
	i32, f32, u64;

def main():
	MyVariant var = 5;
</code></pre>
<p>This program will compile fine, and will have no output when being run. But before we can go deeper into variants we first need to look how they are <em>actually</em> stored in memory and how they work under the hood.</p>
<p>First, let's recap the structure of optionals for a second. An optional <code>i32?</code> looks like this in memory roughly:</p>
<pre><code class="language-c">struct {
    bool has_value;
    i32 value;
}
</code></pre>
<p>Note that this is not valid C code, it's just for demonstation purposes. Okay, but how does the <code>MyVariant</code> look like? It surely doesn't look like this:</p>
<pre><code class="language-c">struct {
    u8 type;
    i32 t0;
    f32 t1;
    u64 t2;
}
</code></pre>
<p>right? Yeah it <strong>definitely</strong> does not look like that above, because the struct above would actually be <code>17</code> bytes big (ignoring padding and alignment for a second here). That's way to big for our types. So, what do we do then? Well, we know at compile-time what's the <strong>maximum</strong> space our <code>value</code> needs, we just need to look at all possible types the variant could have: <code>4</code> bytes for <code>i32</code>, <code>4</code> bytes for <code>f32</code> and <code>8</code> bytes for <code>u64</code>. We then just ask "what's the biggest value i possibly need to store?" and the answer to that would definitely be <code>u64</code> with <code>8</code> bytes.</p>
<p>So, we need atmost 8 bytes to store our value, so what do we do? It's pretty simple, we just do:</p>
<pre><code class="language-c">struct {
    u8 type;
    u8[8] value;
}
</code></pre>
<p>We reserve <code>8</code> bytes for our value field of the struct. If we will now store an <code>i32</code> in the <code>value</code> the first 4 bytes will be used for that value and the other 4 bytes just stay empty. This means that our whole <code>variant</code> now uses exactly <code>9</code> bytes of memory, and if we would add another 10 possible types it would still only use the maximum size of them.</p>
<p>Okay and now let's talk about the <code>type</code> flag, because it's pretty interesting as well... When we define our variant from left to right we actually assign type IDs to each possible type of our variant. In our case the type <code>i32</code> will have the ID of <code>1</code>, <code>f32</code> will have <code>2</code> and <code>u64</code> will have <code>3</code>. But where is the <code>0</code>, you may ask. This will be explained in a <a href="intermediates_guide/2_variants/">later</a> chapter, but for now just know that it's reserved for the absence of values (optionals).</p>
<p>Okay, now you can define <code>variant</code> types and know how they look like under the hood, but how do you use them? We will learn this in the next chapter!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="switching-on-variants"><a class="header" href="#switching-on-variants">Switching on Variants</a></h1>
<p>In the last chapter we have looked at how to define variant types, but now we come to the fun part of variants, actually using them. You see, because a variant <em>can</em> be one of our defined types we also need to check which one it actually <em>is</em> before we can safely access the data that's stored within that variant. The easiest apporach to extract a variant's value is through a switch statement. Here is a small example of that:</p>
<pre><code class="language-ft">use Core.print

variant MyVariant:
	i32, f32, u64;

def print_var(MyVariant var):
	switch var:
		i32(i): print($"holds i32 value of {i}\n");
		f32(f): print($"holds f32 value of {f}\n");
		u64(u): print($"holds u64 value of {u}\n");

def main():
	MyVariant var = -5;
	print_var(var);

	var = 3.4;
	print_var(var);

	var = u64(55);
	print_var(var);
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>holds i32 value of -5
holds f32 value of 3.4
holds u64 value of 55
</code></pre>
</blockquote>
<p>There is quite a lot to unpack here. First, we pass the variant to the function. Variants are considere complex data types in Flint, this means they are passed by <strong>reference</strong>, <em>not</em> by <strong>value</strong>. This also means that changes to the variant within a function would result in these changes taking effect over at the callside of the function as well. You can see this behaviour in this example here:</p>
<pre><code class="language-ft">use Core.print

variant MyVariant:
	i32, f32, u64;

def print_var(MyVariant var):
	switch var:
		i32(i): print($"holds i32 value of {i}\n");
		f32(f): print($"holds f32 value of {f}\n");
		u64(u): print($"holds u64 value of {u}\n");

def set_i32(mut MyVariant var, i32 value):
	var = value;

def set_f32(mut MyVariant var, f32 value):
	var = value;

def set_u64(mut MyVariant var, u64 value):
	var = value;

def main():
	MyVariant var = -5;
	set_i32(var, -10);
	print_var(var);

	set_f32(var, 3.4);
	print_var(var);

	set_u64(var, u64(55));
	print_var(var);
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>holds i32 value of -10
holds f32 value of 3.4
holds u64 value of 55
</code></pre>
</blockquote>
<p>But we need to discuss one more thing here and now: naming. You see that the accessor-variables of the variant have been named <code>i</code>, <code>f</code> and <code>u</code>. You actually do not need to give them separate accessing-names, because these "variables" will only be accessible within their respective switch branch:</p>
<pre><code class="language-ft">use Core.print

variant MyVariant:
	i32, f32, u64;

def main():
	MyVariant var = -10;
	switch var:
		i32(v): print($"holds i32 value of {v}\n");
		f32(v): print($"holds f32 value of {v}\n");
		u64(v): print($"holds u64 value of {v}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>holds i32 value of -10
</code></pre>
</blockquote>
<p>As you can see, you can name your value references however you like and their names will not collide. Again, just like with the value reference for optionals, you can mess up everything by setting the variant value you are switching on while you are still on one branch. This will be resolved eventually, but it also works at this point in time for variants:</p>
<pre><code class="language-ft">use Core.print

variant MyVariant:
	bool8, u8, i32;

def main():
	bool8 b8 = 'A';
	MyVariant var = b8;
	switch var:
		bool8(v):
			print($"holds bool8 value of {v}\n");
			var = 47;
			print($"holds bool8 value of {v}\n");
		u8(v): print($"holds u8 value of {v}\n");
		i32(v): print($"holds i32 value of {v}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>holds bool8 value of 01000001
holds bool8 value of 00101111
</code></pre>
</blockquote>
<p>This is actually a bit more dangerous than the same behaviour with optionals. In optionals, the value is just set to <code>0</code> through and thgough, leading to nullpointers etc. But here we could have a variant that can hold both an <code>u64</code> and a <code>str</code>, but the <code>str</code> is a pointer under the hood. This means that we can store a <code>u64</code> value in the variant inside the <code>str</code> branch and then we could point to <em>any</em> memory address and possibly read strings from it. So, while this problem seemed to be only a small one for optionals, it's actually quite a large problem for variants, so this definitely needs to be fixed at some point.</p>
<p>I need to pre-empt this here, but currently through this we are also allowed to do some shenanigans, like native bitmasking for example. But for the following example i pre-empt tagged variants a bit, just bare with me for a second, you will understand what's going on down here by the next chapter!</p>
<pre><code class="language-ft">use Core.print

variant BitMask:
	Bits(bool8, bool8, bool8, bool8), Value(u32);

def main():
	bool8 empty = '0';
	data&lt;bool8, bool8, bool8, bool8&gt; b8 = (empty, empty, empty, empty);
	BitMask var = b8;
	switch var:
		BitMask.Bits(b):
			print($"BitMask: {b.$0} {b.$1} {b.$2} {b.$3}\n");
			var = u32(1665025);
			print($"BitMask: {b.$0} {b.$1} {b.$2} {b.$3}\n");
		BitMask.Value(v): print($"holds u64 value of {v}\n");
</code></pre>
<p>This program prints these lines to the console:</p>
<blockquote>
<pre><code>BitMask: 00110000 00110000 00110000 00110000
BitMask: 00000001 01101000 00011001 00000000
</code></pre>
</blockquote>
<p>And as you can see, the above mentioned problem can also be a feature. It's quite a lot more nuanced than just saying it's just bad, because now we can do bitmasking with it, without any temporaries, as the accessors are references to the same value. So, if the bitmask and the actual value have the same width, like in our case, both are <code>4</code> bytes in size, we can do pretty cool stuff with variants, as we can directly modify the memory in the <code>value</code> field and interpret it as a whole number or a mask where we can access each individual element.</p>
<p>So, whether this is a bug or a feature is open to debate, but in my opinion it could be a feature <em>if</em> <strong>none</strong> of the possible types are complex and thus are pointers under the hood. If all values are <em>real</em> values and not pointers under the hood i can't see why this should not be allowed for variants, as it's a pretty exploitable system for sure. And if no pointer can be stored in the variant, nothing can be accessed or written to at an arbitrary point in memory, which means the program will definitely not crash, it could only happen that you will get the wrong or unexpected values if you do exploit this. I think there should be a warning that mutating the variable inside the branch could lead to problems, but there should only be a compile-error if one of the variant's types is complex.</p>
<p>I cannot really think of a practical use case of this implication, honestly, especially since Flint will support shift operators <code>&lt;&lt;</code>, <code>&gt;&gt;</code> and bitwise operators like <code>|</code>, <code>&amp;</code> and <code>!</code> as well in the future, so bitmasking for example is not really needed and useful when we have access to direct bit-manipulation as well.</p>
<p>And switch expressions work exactly the same way, just with a <code>-&gt;</code> instead of the <code>:</code> and with no scope but a single expression after the arrow, as usual. But now let's move on to the next chapter of tagging.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="tagged-variants"><a class="header" href="#tagged-variants">Tagged Variants</a></h1>
<p>Until now we have learned how to declare variants and how to extract values of a certain type as well. But you may have noticed that all types we have used in the variant have been simple types like <code>i32</code>, <code>f32</code> etc. Let's look at a bit more complicated example then and it's implications on extracting the right type in a switch:</p>
<pre><code class="language-ft">use Core.print

variant MyVariant:
	i32, f32, data&lt;i32, f32, bool8&gt;;

def print_var(MyVariant var):
	switch var:
		i32(i): print($"holds i32 value of {i}\n");
		f32(f): print($"holds f32 value of {f}\n");
		data&lt;i32, f32, bool8&gt;(t): print($"holds tuple value of ({t.$0}, {t.$1}, {t.$2})\n");

def main():
	MyVariant var = -5;
	print_var(var);

	var = 3.4;
	print_var(var);

	// Flint currently has no way of using a group as the rhs of a variant assignment
	// when a tuple needs to be stored in the variant, but it will have it *eventually*
	data&lt;i32, f32, bool8&gt; tuple = (5, 6.9, bool8(u8(33)));
	var = tuple;
	print_var(var);
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>holds i32 value of -5
holds f32 value of 3.4
holds tuple value of (5, 6.9, 00100001)
</code></pre>
</blockquote>
<p>As you can see it is very very tedious to write the type <code>data&lt;i32, f32, bool8</code> <strong>every single time</strong> you want to use a variation of that type. And we actually have a solution for that: <em>Tags</em>. A Tag is nothing else than a "name" you give to a variation of a variant. This name can be any identifier, actually. Here is the exact same program as above, but re-written using Tags:</p>
<pre><code class="language-ft">use Core.print

variant MyVariant:
	Int(i32), Float(f32), Tuple(i32, f32, bool8);

def print_var(MyVariant var):
	switch var:
		MyVariant.Int(i): print($"holds i32 value of {i}\n");
		MyVariant.Float(f): print($"holds f32 value of {f}\n");
		MyVariant.Tuple(t): print($"holds tuple value of ({t.$0}, {t.$1}, {t.$2})\n");

def main():
	MyVariant var = -5;
	print_var(var);

	var = 3.4;
	print_var(var);

	// Flint currently has no way of using a group as the rhs of a variant assignment
	// when a tuple needs to be stored in the variant, but it will have it *eventually*
	data&lt;i32, f32, bool8&gt; tuple = (5, 6.9, bool8(u8(33)));
	var = tuple;
	print_var(var);
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>holds i32 value of -5
holds f32 value of 3.4
holds tuple value of (5, 6.9, 00100001)
</code></pre>
</blockquote>
<p>You may notice that we have removed the <code>data&lt; .. &gt;</code> part of the tuple definition in the variant, but why? Well, because nothing else than tuples can hold multiple data at once and is anonymous as well. If we would have a <code>data</code> module defined somewhere, we would write the type of said module in between the parenthesis too. Parenthesis are not part of any type definition and this is the reason to why we can have the syntax <code>NAME(TYPE)</code> for variant tagging(Well, they actually are used to define <code>fn</code> typed variables which take no arguments, but you will learn about them later on). Comma-separated values in between the parenthesis define a tuple type as one possible variation of that variant.</p>
<p>When accessing / extracting the actual value of a tagged variant, we <strong>need</strong> to prefix the extraction with the type of the variant to signify we actually want to get a tag, not a type. Here is an example:</p>
<pre><code class="language-ft">use Core.print

data Tuple:
	i32 x;
	f32 y;
	bool8 z;
	Tuple(x, y, z);

variant MyVariant:
	Tuple, Tuple(u64, f64), i32;

def main():
	MyVariant var = 10;
	switch var:
		Tuple(t): print($"Is Tuple: ({t.x}, {t.y}, {t.z})\n");
		MyVariant.Tuple(t): print($"Is MyVariant.Tuple: ({t.$0}, {t.$1})\n");
		i32(i): print($"Is i32: {i}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>Is i32: 10
</code></pre>
</blockquote>
<p>There is, again, quite a lot to go through. First of all, the Type is absolutely needed for tagged accesses to be able to differentiate between a tagged access and an access of that type. This also prevents future collisions if you would, for example, later define a type with the same name as your variant tag. If we would not do this differentiation, you would then later on need to change your tag and change it everywhere you have used it or you would need to change your created type's name to something different to prevent collisions. Both would be a horrible experience. So, this is the reason to why it is <strong>required</strong> to explicitely state the type of the variant before the tag, if the variant's type is missing the "tag" is interpreted as a type and compilation will fail!</p>
<p>This decision might annoy you at first, but we hope that you will be able to see the reasons behind it and why it's so important to have this rule in place, as it also completely removes any ambuguity from the programmer itself.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="inline-variants"><a class="header" href="#inline-variants">Inline Variants</a></h1>
<p>Variants can not only be defined explicitely but also, like <code>data</code>, inline too. For <code>data</code> this inline definition then is a <code>tuple</code>, but for varaints this inline-definition is, well, an inline-defined variant.</p>
<p>Here is a small example of just that:</p>
<pre><code class="language-ft">use Core.print

def print_var(variant&lt;i32, f32, str&gt; var):
	switch var:
		i32(i): print($"i = {i}\n");
		f32(f): print($"f = {f}\n");
		str(s): print($"s = {s}\n");

def main():
	variant&lt;i32, f32, str&gt; var = -55;
	print_var(var);

	var = 3.14;
	print_var(var);

	var = str("Hello There");
	print_var(var);
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>i = -55
f = 3.14
s = Hello There
</code></pre>
</blockquote>
<p>There are a few differences of inline-defined variants and "properly" defined variants. Inline-defined variants <strong>cannot</strong> be tagged, because the varaint type itself does not even have a name, so tagging is impossible. This means that the type of an inline-variant needs to be specified when we want to unwrap the value a variant currently holds, which can be seen in the <code>print_var</code> function. But other than this fact, that tagging is impossible, inline-defined variants behave exactly the same as normally defined variants.</p>
<p>Inline-defined variants become useful when we do not want to pullute our global namespace with yet another symbol name for yet another variant type, for example when a field in custom-defined <code>data</code> can be either <code>i32</code> or <code>f32</code>:</p>
<div class="warning">
<p>The below example does not work yet because of several reasons</p>
<p>Firstly, it is not possible to switch on a non-variable expression at the moment. It will take some time until Flint is robust enough to support switching on more things when switching on optionals and varaints. This is due to the references, in our case <code>i</code> and <code>f</code> which at the moment only work properly with varaible expressions, so everything that isn't a variable in the switch statement will throw an compile error.
And secondly, some other things regarding how the variants are defined in data is horribly wrong too, which leads to all sorts of unexpected code generation output. So, it is best to avoid using variants within data for now.</p>
</div>
<pre><code class="language-ft">use Core.print

data MyData:
	bool8 flags;
	variant&lt;i32, f32&gt; value;
	MyData(flags, value);

def main():
	variant&lt;i32, f32&gt; var = -10;
	MyData md = MyData(u8(0), var);
	print($"flags = {md.flags}\n");
	switch md.value:
		i32(i): print($"i = {i}\n");
		f32(f): print($"f = {f}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>flags = 00000000
i = -10
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="variant-comparison"><a class="header" href="#variant-comparison">Variant Comparison</a></h1>
<p>We can compare variants with quite a few of different things. <em>Comparing</em> means the equals and not-equals operations <code>==</code> and <code>!=</code>, nothing else. We cannot see if one variant is bigger than another variant, for example, but we can definitely see if they are equal to one another. We can also compare variants to types to see if they contain a value of that type. But, let's look at all different cases in isolation.</p>
<h2 id="comparing-types"><a class="header" href="#comparing-types">Comparing Types</a></h2>
<p>We can compare a variant to a type to do a quick "does it hold that value" check:</p>
<pre><code class="language-ft">use Core.print

variant MyVar:
	i32, f32, bool;

def main():
	MyVar var = 3.14;

	if var == i32:
		print("holds i32 value\n");
	else if var == f32:
		print("holds f32 value\n");
	else if var == bool:
		print("holds bool value\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>holds f32 value
</code></pre>
</blockquote>
<p>The <code>== T</code> check actually is semantically more of a <em>Does it hold a value of type <code>T</code>?</em> check. If you look closely, you can see the similarity of the above code with a switch statement:</p>
<pre><code class="language-ft">use Core.print

variant MyVar:
	i32, f32, bool;

def main():
	MyVar var = 3.14;

	switch var:
		i32(v):  print("holds i32 value\n");
		f32(v):  print("holds f32 value\n");
		bool(v): print("holds bool value\n");
</code></pre>
<p>with the same output as the other program. But in a switch we direclty gain an additional reference to the inner value of the variant we are working with. But, if we only want to do an action on only one type of the variant and do <em>nothing</em> on all other types, we can't really express this through a switch statement. Because how do we define doing "nothing" in a switches branch? That simply isn't possible in Flint.</p>
<p>So, for that reason we can compare variants to types to see if it holds a value of that type. Note that <code>T</code> must be a valid type of the variant. If <code>T</code> is not a valid type of the variant, you will get a compile error stating that the type you try to compare the variant with is not a part of the variant's possible types.</p>
<h2 id="comparing-tags"><a class="header" href="#comparing-tags">Comparing Tags</a></h2>
<p>Just like we can compare a variant to it's type, we can compare a variant to it's tag to see if it holds a value of that type. As described in the chapter abour tagged variants, a variation with a tag <strong>must</strong> be accessed and checked through this tag.</p>
<pre><code class="language-ft">use Core.print

variant MyVar:
	Int(i32), Float(f32), bool;

def main():
	MyVar var = -7;

	if var == MyVar.Int:
		print("holds Int value\n");
	else if var == MyVar.Float:
		print("holds Float value\n");
	else if var == bool:
		print("holds bool value\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>holds Int value
</code></pre>
</blockquote>
<p>Just like in the last example, the similarity to the switch statement is pretty easy to spot:</p>
<pre><code class="language-ft">use Core.print

variant MyVar:
	Int(i32), Float(f32), bool;

def main():
	MyVar var = 3.14;

	switch var:
		MyVar.Int(v):   print("holds Int value\n");
		MyVar.Float(v): print("holds Float value\n");
		bool(v):        print("holds bool value\n");
</code></pre>
<p>which will have the same output once again. So, as you can see we can compare a variant value with one of it's possible tags in addition to comparing it with it's possible types. But, just like described in the chapter about tagged variants, we cannot do <code>var == i32</code>, even though <code>i32</code> is a valid type of the variant. We <strong>must</strong> check against it's tag when comparing and are not allowed to compare it to the underlying type directly if a tag is provided.</p>
<h2 id="comparing-variants"><a class="header" href="#comparing-variants">Comparing Variants</a></h2>
<p>Comparing two variants is pretty straight forward. Two variant's are considered to be equal if both their types as well as their values match up. You already know that the underlying structure of a variant is a <code>{ u8, byte[N] }</code>. Given this information you could quickly see that we cannot just compare the whole structure of a variant to another structure and if they are equal the variants are considered equal. It is a bit more nuanced than that. Let's say that we have the variant <code>variant&lt;i32, f32, i64&gt;</code>. In that case the variant has space for <code>8</code> bytes. So, if we have two variables and store <code>-1</code> and <code>1</code> as an <code>i64</code> in both of them all 8 bytes of the variant structure will be set. But if we then store the <code>i32</code> value of <code>7</code> in both of them, only the fist 4 bytes are overwritten and the last 4 bytes stay the same as they were before.
This means that comparing variants through their whole structure would not only compare what <strong>is</strong> stored in the variants but also what <strong>was</strong> stored in them, and this is semantically very incorrect. When we compare both variants and both hold an <code>i32</code> value and that <code>i32</code> value matches, they should be considered equal. Relying on the whole structure would actually be undefined behaviour, and we don't want that. So, that's why we only compare the first <code>N</code> bytes depending on the active type of the variant. That's more work internally, but it results in deterministic and defined behaviour.</p>
<p>So, here is a small example of comparing variants to one another:</p>
<pre><code class="language-ft">use Core.print

variant MyVar:
	i32, i64, i32x3;

def main():
	MyVar var_1 = i64(-5);
	MyVar var_2 = i64(6);

	if var_1 == var_2:
		print("are equal\n");
	else:
		print("differ\n");

	var_1 = 5;
	var_2 = 5;
	if var_1 == var_2:
		print("are equal\n");
	else:
		print("differ\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>differ
are equal
</code></pre>
</blockquote>
<p>This output is expected. When we store different <code>i64</code> values in the variant they obviously do not match and then we store two equal <code>i32</code> values in the variant, so the variants should equal each other. If we would compare the whole structures of the variant to one another the second comparison of the two <code>i32</code> values would yield <code>false</code> which would be extremely counter-intuitive.</p>
<h2 id="the-active_type-field"><a class="header" href="#the-active_type-field">The <code>active_type</code> field</a></h2>
<p>Next we look at accessing the <code>active_type</code> field of the variant. You know the strucutre of the variant is <code>{ u8, byte[N] }</code> and the <code>active_type</code> field of a variant is the first field of that struct. We can access this value (readonly) by just doing <code>var.active_type</code> on an variant. This will return a <code>u8</code> value. And because we can compare <code>u8</code> values we can actually check whether two variant variables hold <strong>the same type</strong>. This is especially useful for situations where we just want to know whether two variants hold the same type, independent from <em>which</em> type that is.</p>
<pre><code class="language-ft">use Core.print

variant MyVar:
	i32, i64, i32x3;

def main():
	MyVar var_1 = i64(-5);
	MyVar var_2 = i64(6);

	if var_1.active_type == var_2.active_type:
		print("hold the same type\n");
	else:
		print("hold different types\n");

	var_1 = 5;
	if var_1.active_type == var_2.active_type:
		print("hold the same type\n");
	else:
		print("hold different types\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>hold the same type
hold different types
are equal
</code></pre>
</blockquote>
<p>You will see in the next big chapter about <a href="intermediates_guide/2_variants//intermediates_guide/3_error_sets.html">Error Sets</a> and you actually have seen it before for getting the <a href="intermediates_guide/2_variants//beginners_guide/6_arrays/3_strings.html#getting-a-strings-length">length of strings</a> that you can access fields of primitive types or builtin types, fields which you normally do not see.</p>
<p>Note that the <code>active_type</code> indices start at <code>1</code>. This means that <code>i32</code> has the value <code>1</code>, <code>i64</code> the value <code>2</code> and <code>i32x3</code> the value <code>3</code>. Why the value <code>0</code> is not used here and why we have a one-based indexing in this case will be explained in a <a href="intermediates_guide/2_variants//intermediates_guide/2_variants/8_optional_variants.html">later</a> chapter, stay tuned for that!</p>
<h2 id="comparing-values"><a class="header" href="#comparing-values">Comparing Values</a></h2>
<div class="warning">
<p>It is not yet entirely clear whether this feature will be implemented at all</p>
<p>While useful, this feature would make comparing variants ambiguous. When comparing a variant to a type or another variant of the same type it can be clearly seen what's actually happening. But in the example below, doing <code>var == ten</code> brings a bit of ambiguity with it, as now <code>ten</code> could be of type <code>MyVar</code>, <code>i32</code>, <code>i64</code> or <code>i32x3</code>. All types are entirely possible. For the parser this is no problem whatsoever, but for the person actually <em>reading</em> the Flint code this leads to additional cognitive load, whereas when <em>not</em> having this feature you can be sure that when you see <code>var == ten</code> that <code>ten</code> is definitely of type <code>MyVar</code> and can't be of any other type.
So, it is still thought about whether to actually implement this feature. It is not implemented for now, as it's just syntactic sugar and doing that comparison coould be done through other ways as well. We will reconsider adding this feature at a later point in time, when time has shown that we actually want and need it. But it is most likely for this feature to stay pretty uncommon.</p>
</div>
<p>Lastly, we can also compare variants to variables and literals of a given type directly. Just like we can do <code>var == i32</code> we can also do <code>var == 5</code> and this will do two checks for us: Is <code>var</code> of type <code>i32</code>? If yes, does it's value match the value we compare it to? It's the same as if we would write <code>var?(i32) != none and var!(i32) == 5</code> but we look at that syntax in the next chapter. Just be assured: It would be pretty hard to check if the variant matches a given value if this feature would not exist. This feature is something we would call syntactic sugar. It is not necessarily <em>required</em> to be implemented, but it makes our lives quite a lot easier.</p>
<pre><code class="language-ft">use Core.print

variant MyVar:
	i32, i64, i32x3;

def main():
	MyVar var = i64(-5);

	if var == i64(-5):
		print("equals i64(-5)\n");

	i32 ten = 10;
	var = 10;
	if var == 7:
		print("equals 7\n");
	else if var == ten:
		print("equals ten\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>equals i64(-5)
equals ten
</code></pre>
</blockquote>
<p>As you can see it makes our lives quite a lot easier.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="unwrapping-variants"><a class="header" href="#unwrapping-variants">Unwrapping Variants</a></h1>
<p>Okay now let's move on to variant unwrapping. In the last chapter you have learned how to check if a variant holds a given type and much more about comparing variants. But, in those if branches, when we <em>know</em> the variant holds the given type we actually want to get that value from the variant somehow. If you think back about optionals we had the <code>!</code> operator for forceful unwrapping and the <code>?</code> operator for optional chaining. For variants, this actually is quite similar. To unwrap a variant we use the <code>!(T)</code> syntax. In between the parenthesis we write which type we want to force-unwrap from the variant. Similar to how the force-unwrap operator <code>!</code> worked for optionals, this will print a small error message and crash the program if the variant does not hold the requested type.
Let's actually look at a modified version of one of the last chapter's examples:</p>
<pre><code class="language-ft">use Core.print

variant MyVar:
	i32, f32, bool;

def main():
	MyVar var = 3.14;

	if var == i32:
		print($"holds i32 value: {var!(i32)}\n");
	else if var == f32:
		print($"holds f32 value: {var!(f32)}\n");
	else if var == bool:
		print($"holds bool value: {var!(bool)}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>holds f32 value: 3.14
</code></pre>
</blockquote>
<p>It actually is semantically quite similar to the force-unwrap operator for optionals, and this is intended. Whenever you see the <code>!</code> symbol you should know that <em>"Okay the programmer asserted that this will always have a value (of that type)."</em>. This forms confidence over time. The more you see the same symbols used in the same context and same semantics the more you familiarize with them, just like how the <code>_</code> default expression works.</p>
<p>The above example is not really useful, though, as in this case the switch statement would be a much better fit. But the variant unwrapping operator is a very powerful tool for handling variants.</p>
<p>Also, we can of course provide a tag instead of the type <code>T</code> for variant unwrapping too, as always. So, if <code>i32</code> had a tag <code>Int</code> we must write <code>var!(MyVar.Int)</code> as usual, but that should be clear by now.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="variant-extraction"><a class="header" href="#variant-extraction">Variant Extraction</a></h1>
<p>Similar to how the variant unwrapping operator <code>!(T)</code> had similarities to the optional force-unwrap operator <code>!</code>, the variant extraction operator <code>?(T)</code> has equally as much similarities to the optional chaining operator <code>?</code>. As a quick reminder, the optional chaining operator was used to, well, form chained expressions from optionals like <code>maybe?.field_maybe?.field</code> where the result of the whole chain always was <code>T?</code>, either the chain succeeded or it failed.</p>
<p>The variant extraction operator <code>?(T)</code> slots right into that same machinery and it pretty much works identiacally to the optional chaining operator. Where for optional chaining you either <em>have</em> a value or you <em>don't</em>, for variants it's more nuanced as you could have one of many types. But you either <em>have</em> a value of a given type or you <em>don't</em>. So, we van use the variant extraction operator <code>?(T)</code> <em>within</em> optional chains and mix and match them as we wish, and the result of that optional chain has the type <code>T?</code>, because either all parts of the chain succeeded or <em>any</em> part of the chain returned <code>none</code> as result.</p>
<p>Let's look at a more simple case for the extraction operator before moving on to the more complicated chaining approach.</p>
<pre><code class="language-ft">use Core.print

variant MyVar:
	i32, f32, str;

def main():
	MyVar var = -5;

	i32? i = var?(i32);
	f32? f = var?(f32);

	if i != none:
		print($"i == {i!}\n");
	else:
		print("i == none\n");

	if f != none:
		print($"f == {f!}\n");
	else:
		print("f == none\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>i == -5
f == none
</code></pre>
</blockquote>
<p>As you can see, the variant extraction operator <code>?(T)</code> has quite a few similarities to the optional chaining operator <code>?</code>, so much that it can be used within optional chains too. Let's look at the more complicated example now:</p>
<div class="warning">
<p>This example does not work yet</p>
<p>Flint does not yet support stacking variant extractions with optional chains. It will be supported eventually, but the compiler is currently unable to compile the program below.</p>
</div>
<pre><code class="language-ft">use Core.print
use Core.assert

data MyData:
	i32 x;
	f32 y;
	MyData? next;
	MyData(x, y, next);

variant MyVar:
	i32, Data(MyData?), str;

def main():
	MyData? md = MyData(10, 20, MyData(30, 40, none));
	MyVar var = md;

	i32? x = var?(MyVar.Data).x;
	assert(x != none);
	i32? x2 = var?(MyVar.Data).next?.x;
	assert(x2 != none):
	print($"x = {x!}\n");
	print($"x2 = {x2!}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>x = 10
x2 = 30
</code></pre>
</blockquote>
<p>You can see quite a lot of information packed into that little program above, actually. First of all we must extract the tagged variation through it's tag again. Also, <code>MyData</code> is a linked list in this example containing an optional next field. This example was chosen to showcase the ability to mix and match variant extractions with optional chains. Because the variant extraction essentially works exactly the same as the optional chaining operator we will not go i depth here, it should be clear how it works by now.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="error-sets-6"><a class="header" href="#error-sets-6">Error Sets</a></h1>
<p>Welcome to the third chapter of the intermediates guide. In this chapter we look at the error set type and what you can do with it. The <code>error</code> type is used to define error sets which we can use in Flint's error handling system through the <code>throw</code> and <code>catch</code> keywords respectively.</p>
<h2 id="what-are-error-sets"><a class="header" href="#what-are-error-sets">What are Error Sets?</a></h2>
<p>Errors sets are collections of possible throwable error values. Error sets are sets in the mathematical sense in the aspect of superset / subset relationships.</p>
<h2 id="why-are-error-sets-important"><a class="header" href="#why-are-error-sets-important">Why are Error Sets Important?</a></h2>
<p>Errors are an integral part of programming because sometimes things dont work as expected, but through errors we can "expect the unexpected" and handle cases in which our program would fail otherwise. So, using errors we can:</p>
<ul>
<li>Describe the possibility that something fails</li>
<li>Describe what to do in the event of such a failure</li>
<li>Continue execution after a failure safely</li>
</ul>
<h2 id="what-to-expect-6"><a class="header" href="#what-to-expect-6">What to Expect</a></h2>
<p>In this chapter, we will ocver the following topics:</p>
<ul>
<li>Declaring and using error set types</li>
<li>How to throw and catch errors</li>
<li>The concept of error set refinement through superset relationships through the <code>anyerror</code> nullset</li>
<li>Specifying possible error sets in the signatures of functions</li>
<li>Switching on error set variants</li>
<li>Switching on error sets</li>
<li>Adding context to thrown errors</li>
<li>Throwing anonymous errors</li>
<li>Internals of the error set system</li>
<li>Best practices when using error sets</li>
<li>Error Switch Inlining</li>
<li>Linearization</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="introduction-4"><a class="header" href="#introduction-4">Introduction</a></h1>
<p>Flint's error system is quite unique. <strong>Every</strong> function can fail. Absolutely every single function a user defines in his code <em>can</em> fail. Because <em>every</em> function can fail, Flint can deeply integrate error handling into the language. A function returning a <code>str</code> value, for example, actually returns a <code>(err, str)</code> value. The first <em>implicit</em> return type of <strong>any</strong> Flint function is the error value of said function. This error value, however, is completely hidden from the user outside of Flint's error handling syntax.</p>
<p>Flint has two keywords for error handling: <code>throw</code> and <code>catch</code>. But, unlike Java or C++, where the error handling happens outside the normal execution path ("happy path" / "unhappy path") which completely breaks execution consistency and results in lots of context switching for the CPU, Flint has it's error handling system built directly into the calling / returning code of every function, which makes it much faster than traditional exception-based error handling.</p>
<p>Flint's error handling system, however, is based around the idea of <code>Error Sets</code>. An error set is basically just a type, a set type, consisting of every possible value the error could have. Here is a small example of that:</p>
<pre><code class="language-ft">use Core.print

error ErrorSet:
	Value1, Value2;

def main():
	print("Hello, World!\n");
</code></pre>
<p>This program will just print this line to the console:</p>
<blockquote>
<pre><code>Hello, World
</code></pre>
</blockquote>
<h2 id="throwing-errors"><a class="header" href="#throwing-errors">Throwing errors</a></h2>
<p>But here you can directly see how to define a new error set. We use the <code>error</code> keyword for that. And an error set looks pretty similar to an <code>enum</code> defiition, actually, but they are vastly different from one another. Let's look into how to throw an eror next.</p>
<pre><code class="language-ft">use Core.print

error ErrorSet:
	Value1, Value2;

def fail():
	throw ErrorSet.Value1;

def main():
	fail();
	print("Normal execution continues\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>ERROR: main function returned error
 - type_id: 4008229038
 - value_id: 0
 - message: ""
</code></pre>
</blockquote>
<div class="warning">
<p>This error message will change in the future</p>
<p>In the future the message should look more like</p>
<blockquote>
<pre><code>ERROR: main function returned error
 - ErrorSet.Value1: ""
</code></pre>
<p>but it will take more time and developement effort until this message can actually be printed. It will take a while until we can print the error set names and values because we first need a way to create hash-tables to map the type ids to the type names. So, this will be implemented <em>eventually</em>.</p>
</blockquote>
</div>
<h2 id="catching-errors"><a class="header" href="#catching-errors">Catching errors</a></h2>
<p>But what would an error be used for if we would not have a way to catch it? Here is how we catch errors in Flint:</p>
<pre><code class="language-ft">use Core.print

error ErrorSet:
	Value1, Value2;

def fail():
	throw ErrorSet.Value1;

def main():
	fail() catch err:
		print("Error catched!\n");
	print("Normal execution continues\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>Error catched!
Normal execution continues
</code></pre>
</blockquote>
<p>The program now does no longer print the <code>ERROR: ...</code> message, as no error was thrown from the main function. This is a core concept of Flint: When an error is catched and it is handled it is consiered that the error is "no longer a problem" and execution will continue as if there was no error at all. But there is still a lot more to cover before we are able to completely understand what errors really are and how to effectively use them.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="error-set-refinement"><a class="header" href="#error-set-refinement">Error Set Refinement</a></h1>
<p>Error set refinement, what a beautiful name for a very simple concept. You have learned in the last chapter how to create a new error set type using the <code>error</code> keyword. Now you will learn another important concept of how Flint's errors work under the hood. A set is a collection of values, both in set theory in mathematics and in Flint that's also true. So, the error set from the last chapter, <code>error ErrorSet: Value1, Value2;</code> contains exactly two values: <code>Value1</code> and <code>Value2</code>.
We can define set-relationships in Flint. One Error set could "extend" a base error set, and becomes a more specialized error by doing so. Here is a small example of that:</p>
<pre><code class="language-ft">error ErrBase:
	B1, B2;

error ErrSpecial(ErrBase):
	S1, S2;

def main():
	throw ErrSpecial.B1;
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>ERROR: main function returned error
 - type_id: 803109534
 - value_id: 0
 - message: ""
</code></pre>
</blockquote>
<div class="warning">
<p>This error message will change in the future</p>
<p>In the future the message should look more like</p>
<blockquote>
<pre><code>ERROR: main function returned error
 - ErrSpecial.B1: ""
</code></pre>
<p>but it will take more time and developement effort until this message can actually be printed. It will take a while until we can print the error set names and values because we first need a way to create hash-tables to map the type ids to the type names. So, this will be implemented <em>eventually</em>.</p>
</blockquote>
</div>
<p>The error set <code>ErrSpecial</code> is an extension of the error set <code>ErrBase</code>, thus contains all values of it's base set. The error set <code>ErrBase</code> contains the values <code>[B1, B2]</code> and the error set <code>ErrSpecial</code> contains the values <code>[B1, B2, S1, S2]</code>. This is a very important concept in Flint. The more "special" an erro becomes the <strong>bigger</strong> does it's set become. This might seem counter-intuitive but when looked at it from the mathematical standpoint this is just how it works.</p>
<h2 id="the-null-set"><a class="header" href="#the-null-set">The null-set</a></h2>
<p>Mathematical sets all have a null-set, a set which contains no value and as a result is the "base" set of <strong>every</strong> other set. Because <strong>every</strong> set contains the null-set and is a superset of it. In Flint, this "null-set" for errors is represented as the type <code>anyerror</code>. The <code>anyerror</code> "set" is a true null-set meaning it does not "contain" any values. This is only true semantically, of course, as under the hood the <code>anyerror</code> is actually the same structure as any other error too. But this allows us to "cast" every error to an <code>anyerror</code>, because every error set <strong>is</strong> (contains) an <code>anyerror</code>. So, when we now look at this example here:</p>
<pre><code class="language-ft">use Core.print

error ErrBase:
	B1, B2;

error ErrSpecial(ErrBase):
	S1, S2;

def crash():
	throw ErrSpecial.B1;

def main():
	crash() catch err:
		print("Error catched\n");
</code></pre>
<p>which prints this line to the console:</p>
<blockquote>
<pre><code>Error catched
</code></pre>
</blockquote>
<p>we can look at the function <code>crash</code> and look at the type of the returned error. In our case, the type of the returned error is <code>anyerror?</code>, it is <code>none</code> if there was no error. If there was an error, however, we directly unwrap it and put the error accessible into the <code>err</code> variable. So, in this above case the <code>err</code> variable is of type <code>anyerror</code>. The type anyerror however is, like said before, not really "nothing", it still contains the thrown error, but this error just could be <em>any</em> error, hence the name.
Also, what was not told until now is that even the <code>ErrBase</code> extends a set, the <code>anyerror</code> null-set! So, the error definition from above actually looks more like that:</p>
<pre><code class="language-ft">error ErrBase(anyerror):
	B1, B2;
</code></pre>
<p>But the <code>anyerror</code> set contains no values, so the <code>ErrBase</code> set still only contains the values <code>[B1, B2]</code> but now it formally extends from the error set of <code>anyerror</code> and thus is "castable" to that set.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="function-signatures"><a class="header" href="#function-signatures">Function Signatures</a></h1>
<p>So far we have learned how we can define errors, extend from other errors to form bigger and more specialized sets and how to throw and catch errors, but on the catching side we have not yet done anything with the catched <code>err</code> variable. This will change in this chapter, as we dive deeper into how to specify the possible errors a function could throw directly in it's signature. Let's look at a very simple example for this at first:</p>
<pre><code class="language-ft">use Core.print

error ErrArithmetic:
	NullDivision, Negative;

def divide(i32 x, i32 y) -&gt; i32 {ErrArithmetic}:
	if y == 0:
		throw ErrArithmetic.NullDivision;
	if x &lt; 0 or y &lt; 0:
		// We just made up that error just to have a second error case
		throw ErrArithmetic.Negative;
	return x / y;

def main():
	i32 res = divide(10, 0) catch err:
		print("Error happened\n");
	print($"res = {res}\n");
</code></pre>
<p>This program will simply print these lines to the console:</p>
<blockquote>
<pre><code>Error happened
res = 0
</code></pre>
</blockquote>
<p>There is quite a lot going on here, so let's unpack it bit by bit. First, as you can see we have declared which error the function <code>divide</code> is able to throw in it's signature. Through the <code>{ErrArithmetic}</code> syntax we specify all possible errors the function could throw. It's only allowed to put error set types in between the <code>{}</code> symbols. We can put more than one error type in them to signify that the function is capable of throwing these errors. Normally a function would return an error of type <code>anyerror?</code> if we do not specify any error here. But by defining the errors we directly change the functions error return type to now be a <code>variant&lt;anyerror, ErrArithmetic&gt;?</code>. So, the error this function could throw is now either an <code>ErrArithmetic</code> or <em>something else</em>. If we specify more than one error type in the signature the variant will become bigger. It's still an optional, but that optional will disappear when catching the error, so the <code>err</code> variable is only of type <code>variant&lt;anyerror, ErrArithmetic&gt;</code>.</p>
<p>And this is the secret of how to tell which error actually was returned from a function, because now we can simply switch on the <code>err</code> variable and handle the error depending on which error it was.</p>
<pre><code class="language-ft">use Core.print

error ErrArithmetic:
	NullDivision, Negative;

def divide(i32 x, i32 y) -&gt; i32 {ErrArithmetic}:
	if y == 0:
		throw ErrArithmetic.NullDivision;
	if x &lt; 0 or y &lt; 0:
		// We just made up that error just to have a second error case
		throw ErrArithmetic.Negative;
	return x / y;

def main():
	i32 res = divide(10, 0) catch err:
		switch err:
			ErrArithmetic(e):
				print("Is ErrArithmetic\n");
			anyerror(e):
				print("Is anyerror\n");
	print($"res = {res}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>Is ErrArithmetic
res = 0
</code></pre>
</blockquote>
<p>Okay and next up we look at switching on the error set directly. It works just like when switching on enums:</p>
<pre><code class="language-ft">use Core.print

error ErrArithmetic:
	NullDivision, Negative;

def divide(i32 x, i32 y) -&gt; i32 {ErrArithmetic}:
	if y == 0:
		throw ErrArithmetic.NullDivision;
	if x &lt; 0 or y &lt; 0:
		// We just made up that error just to have a second error case
		throw ErrArithmetic.Negative;
	return x / y;

def main():
	i32 res = divide(10, 0) catch err:
		switch err:
			ErrArithmetic(e):
				print("Is ErrArithmetic\n");
				switch e:
					NullDivision: print("Is NullDivision\n");
					Negative: print("Is Negative\n");
			anyerror(e):
				print("Is anyerror\n");
	print($"res = {res}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>Is ErrArithmetic
Is NullDivision
res = 0
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="the-error-structure"><a class="header" href="#the-error-structure">The Error Structure</a></h1>
<p><strong>Every</strong> error is represented the exact same way in memory:</p>
<pre><code class="language-c">struct {
	u32 type_id;
	u32 value_id;
	str message;
}
</code></pre>
<p>The <code>type_id</code> is a unique id of the error set type. It is the result of a hashing function, where the name of the error set type is being hashed. This means that the same error set will <em>always</em> result in the same type id. The <code>value_id</code> is the index of the actual thrown value. Given these error sets:</p>
<pre><code class="language-ft">error ErrBase:
	B1, // value 0
	B2; // Value 1

error ErrSpecial1(ErrBase):
	S1, // value 2
	S2; // value 3

error ErrSpecial2(ErrBase):
	S1, // value 2
	S2; // value 3

error ErrSuperSpecial(ErrSpecail1):
	SS1, // value 4
	SS2; // value 5
</code></pre>
<p>you can cleary see in the example how the values directly correlate to which error it is. For example when writing <code>ErrSuperSpecial.S1</code> the error set type is of type <code>ErrSuperSpecial</code> but the <code>value_id</code> is value <code>2</code>.</p>
<p>When we have a variable which is a error set type, we can directly access those fields through their names through <code>type_id</code>, <code>value_id</code> and <code>message</code>. Here is a small example showcasing this:</p>
<pre><code class="language-ft">use Core.print

error ErrArithmetic:
	NullDivision, Negative;

def divide(i32 x, i32 y) -&gt; i32 {ErrArithmetic}:
	if y == 0:
		throw ErrArithmetic.NullDivision;
	if x &lt; 0 or y &lt; 0:
		// We just made up that error just to have a second error case
		throw ErrArithmetic.Negative;
	return x / y;

def main():
	i32 res = divide(10, 0) catch err:
		switch err:
			ErrArithmetic(e):
				print($"type_id = {e.type_id}\n");
				print($"value_id = {e.value_id}\n");
				print($"message = {e.message}\n");
				switch e:
					NullDivision: print("Is NullDivision\n");
					Negative: print("Is Negative\n");
			anyerror(e):
				print("Is anyerror\n");
	print($"res = {res}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>type_id = 1484029712
value_id = 0
message =
Is NullDivision
res = 0
</code></pre>
</blockquote>
<p>As you can see, the <code>NullDivision</code> is value <code>0</code> and the hashing function outputs the <code>u32</code> hash of <code>1484029712</code> for the type <code>ErrArithmetic</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="error-context"><a class="header" href="#error-context">Error Context</a></h1>
<p>Next up will be the topic of error context. The error context is a simple string message which will be passed alongside / inside the error structure. We already have talked about the error structure itself, so now we can talk about what that <code>message</code> field really is. With every error you throw you have the additional ability to pass in a string message, the context of the thrown error. You can also define default messages for the case that no message is added in the throw. Below is an example of it all:</p>
<pre><code class="language-ft">use Core.print

error ErrBase:
	B1("Base Error 1"),
	B2("Base Error 2");

error ErrSpecial(ErrBase):
	S1("Special Error 1"),
	S2("Special Error 2");

def throw_error(bool override) {ErrSpecial}:
	if override:
		throw ErrSpecial.S2($"Overwritten message: {override}");
	else:
		throw ErrSpecial.S1;

def print_err(bool override):
	throw_error(override) catch err:
		switch err:
			ErrSpecial(e):
				print($"type_id = {e.type_id}\n");
				print($"value_id = {e.value_id}\n");
				print($"message = {e.message}\n");
			anyerror(e): print("is anyerror\n");

def main():
	print_err(false);
	print("\n");
	print_err(true);
</code></pre>
<p>This program prints these lines to the console:</p>
<blockquote>
<pre><code>type_id = 803109534
value_id = 2
message = Special Error 1

type_id = 803109534
value_id = 3
message = Overwritten message: true
</code></pre>
</blockquote>
<p>As you can see, the default message from the error set definition is being stored in the returned error by default, but when providing a custom message the provided message is passed within the thrown error structure instead. You may also be able to recognize that <strong>any</strong> expression can be put in between the parenthesis of the throw. So, even calls or variables or string interpolation, it really just does not matter, the result just has to be of type <code>str</code>. You can use the <code>message</code> field to pass in an error context in the thrown error.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="throwing-anonymous-errors"><a class="header" href="#throwing-anonymous-errors">Throwing Anonymous Errors</a></h1>
<div class="warning">
<p>Anonymous errors do not work yet</p>
<p>While the design around anonymous errors is finished for the compiler already, they have not been implemented yet. So, this section will become important eventually, but not yet.</p>
</div>
<p>Having to define an error set first and then choose when throwing an error which value from the error set to throw is tedious and quite a lot of work when just prototyping stuff, or when throwing special-case errors which are not really part of a broader error set at all for example. This happens quite often, actually, so for this very own reason Flint supports anonymous errors. But what even <em>are</em> anonymous errors?</p>
<p>Lets look at an actual example first before continuing with the theory:</p>
<pre><code class="language-ft">use Core.print

def crash():
	throw error.Crash("Custom Message");

def main():
	crash() catch err:
		print($"err.type_id = {err.type_id}\n");
		print($"err.value_id = {err.value_id}\n");
		print($"err.message = {err.message}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>err.type_id = 0123456789 // FIX THE ID WITH THE CORRECT ID EVENTUALLY
err.value_id = 0
err.message = Custom Message
</code></pre>
</blockquote>
<p>But how do anonymous errors even work? Well, firstly anonymous errors have no underlying error set type visible to the programmer, like when defining your own error set types. This means that it is not possible to tell which error was thrown when throwing anonymous errors, only <strong>that</strong> an error has happened. Also note that we can still access the fields <code>type_id</code>, <code>value_id</code> and <code>message</code> on an error of type <code>anyerror</code>. The error structure did not change at all, as you know already. When using anonymous errors, the compiler will just "make up" a name for an error set on a per-function basis. This means that, if you would throw a few anonymous errors within the same function, all those anonymous errors would actually end up in the same internal error set type:</p>
<pre><code class="language-ft">use Core.print

def crash(i32 v):
	switch v:
		0: throw error.Crash("Custom Message");
		1: throw error.CrashOther;
		else: throw error.CrashLast("LAST");

def print_crash(i32 v):
	crash(v) catch err:
		print($"err.type_id = {err.type_id}\n");
		print($"err.value_id = {err.value_id}\n");
		print($"err.message = {err.message}\n");

def main():
	print_crash(0);
	print("\n");
	print_crash(1);
	print("\n");
	print_crash(2);
	print("\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>err.type_id = 0
err.value_id = 0
err.message = Custom Message

err.type_id = 0
err.value_id = 1
err.message =

err.type_id = 0
err.value_id = 2
err.message = LAST
</code></pre>
</blockquote>
<p>As you can clearly see in the output of this example, the <code>type_id</code> is identical, but the <code>value_id</code> differs, because all those error values <code>[Crash, CrashOther, CrashLast]</code> are paret of the same error set. It would be called: <code>__flint_type_anonymous_err__print_crash__i32__void</code>. That's quite a long name, I know, but it's just internal annyway. It starts with <code>__flint</code> because <em>nothing</em> user-defined is allowed to start with this. All Flint-internal things start with this prefix, actually. Then there is <code>type</code> to signify it's a type and then <code>anonymous_err</code>. Then comes the name of the function in which to create the anonymous error in followed by all return types, separated by one <code>_</code> and then followed by all return types of the function. So, we have the full function singature encoded in the type, and we need that actually for overloading. So, under the hood the error set:</p>
<pre><code class="language-ft">error __flint_type_anonymous_err__print_crash__i32__void:
	Crash, CrashOther, CrashLast;
</code></pre>
<p>is created. So, there is actually nothing "magical" about anonymous errors whatsoever.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="internals"><a class="header" href="#internals">Internals</a></h1>
<p>There are still some things to cover, especially around the internals of the error handling system. You have seen the <code>variant&lt;anyerror, ErrSpecial&gt;?</code> type earlier and you surely have wondered how this type looks under the hood. If it would be <em>any</em> other type it would look something like this:</p>
<pre><code class="language-c">struct {
	bool has_value;
	struct {
		u8 variation;
		byte[16] data;
	} value;
}
</code></pre>
<p>But i think it is needless to say how inefficient and utterly stupid this all would be. Lets look at it in detail. Let's unpack it from inside out, so lets actually start at the variant first. In a variant we have a 8 bit number determining which variation it actually is. In our case this would mean <code>0</code> for <code>anyerror</code> and <code>1</code> for the <code>ErrSpecial</code> case. However, we have the <code>type_id</code> field of our error structure. This field directly encapsulates all the needed information, as it contains the information which error set <strong>type</strong> it is. This means that we can completely erase the whole "variant" part entirely. Good, then what does a switch on an error variant actually do? It just switches on the <code>type_id</code> field of the error value directly.
So, when we write</p>
<pre><code class="language-ft">switch err:
	ErrSpecial(e): ...
	anyerror(e): ...
</code></pre>
<p>all type IDs are known at compile-time so the type ids are directly inlined. But what does the <code>anyerror</code> branch become? The <code>anyerror</code> has no distinct type ID, the <code>anyerror</code> just means any error. When switching on an error variant this becomes <em>any other error</em>... so, the <code>anyerror</code> case is actually the <code>else</code> case of the switch!</p>
<p>And now let's move on to the outer part of the <code>variant&lt;anyerror, ErrSpecial&gt;?</code> type, the optional. The hashing function of Flint's errors is written in a way to make it <strong>impossible</strong> to have a result type id of <code>0</code>. This works by actually calculating a <code>31</code> bit hash and then just shifting all bits of the result hash one to the left. If the result would happen to be <code>0</code> it becomes <code>1</code>. This way it is <strong>guaranteed</strong> for the <code>type_id</code> to be inequal to 0. This was not implemented this way by accident or anything, but by design. Because now we can use the <code>type_id == 0</code> to represent the "no error" case, the <code>none</code> case of the optional!</p>
<p>So, as you might have guessed by now: The type <code>variant&lt;anyerror, ErrSpecial&gt;?</code> actually boils down to be <strong>just the simple 16 Byte error structure that we already know about</strong>. So, everything from the error value itself to the set to the variant to the optional variant is <strong>all</strong> the same structure under the hood, which makes it very efficient.</p>
<p>This also imposes a unique side effect... we can not mix error types in variants of "normal" types. I think that this is a good thing, as this means that we are <em>only</em> allowed to define variants which contain <em>either</em> only error set types <em>or</em> "normal" types and we are not allowed to mix and match them as we whish. That's a trade-off for sure, but the gains are a vastly simpler and more efficient error handling system, which is always a good thing.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h1>
<p>Let's discuss best practices regarding error handling in Flint next.</p>
<h2 id="naming"><a class="header" href="#naming">Naming</a></h2>
<p>Let's start with naming and with how Flint names it's errors internally. All Errors inside Flint start with <code>Err...</code> followed by the actual are of error, like <code>ErrNetwork</code>, <code>ErrSystem</code>, <code>ErrAssert</code>, <code>ErrEnv</code>, <code>ErrFS</code> and so on. Then, unlike enums where the values are prefered to be written in <code>SCREAMING_SNAKE_CASE</code>, the error values are written in <code>PascalCase</code>, just like errors. Also, error values may not start with the <code>Error</code> prefix, as this is handled by the <code>Err</code> prefix on the error set type. So you would end up writing <code>ErrName.ValueName</code> instead of <code>Something.ErrorName</code>. This recommendation exists to prevent collisions with other definitions, as there exist quite a few of definitions in Flint: <code>data</code>, <code>enum</code>, <code>variant</code>, <code>func</code>, <code>entity</code> and <code>error</code>. So, having clear naming for all of them keeps your code visually pleasing and easy to follow.</p>
<h2 id="throwing-errors-and-signatures"><a class="header" href="#throwing-errors-and-signatures">Throwing Errors and Signatures</a></h2>
<p>With great power comes great responsibility. With the power of extending error sets also come unique challenges not found in other languages. Here is an example of a 4-deep error set extension chain:</p>
<pre><code class="language-ft">error ErrBase:
	Critical, Abortion;

error ErrParsing(ErrBase):
	UnexpectedToken, MissingToken, DuplicateDefinition;

error ErrStatement(ErrParsing):
	MissingSemicolon, EmptyScope, TypeMismatch;

error ErrExpression(ErrStatement):
	MissingOperator, UnknownType;


def parse_expression() {ErrExpression}:
	// Do some work and possibly throw an ErrExpression
	// This means it could be *any* from the above errors
	// because they all end up in the 'ErrExpression' set

def parse_statement() {ErrStatement}:
	parse_expression() catch err:
		ErrExpression(e):
			// Handle all expression-specific errors
			switch e:
				MissingOperator: // handle case
				UnknownType:     // handle case
				else:
					// The rest are all errors from base error sets
					// This means that we simply "recast" the error
					// and return it as a statement error
					ErrStatement es = e;
					throw es;
		// Just rethrow any other errors
		anyerror(e): throw e;

def parse_file() {ErrParsing}:
	parse_expression() catch err:
		ErrStatement(e):
			// Handle all statement-specific errors
			switch e:
				MissingSemicolon: // handle case
				EmptyScope:       // handle case
				TypeMismatch:     // handle case
				else:
					// The rest are all errors from base error sets
					// This means that we simply "recast" the error
					// and return it as a parsing error
					ErrParsing ep = e;
					throw ep;
		// Just rethrow any other errors
		anyerror(e): throw e;

def main():
	parse_file() catch err:
		// Now we can handle the parsing and check for all potential
		// general parsing errors.
</code></pre>
<p>This is what I would consider a true "separation of concerns". Through the error set extension system we not only are able to specialize our errors but also keep the actual handling of those errors to higher levels while only focusing on the lower levels for the specialized sets. This is still a quite simple example. Just imagine having a dozen error set types where the most special error would have a hundred possible values it could be. Imagine writing a 100-branch switch in the specialized function, a 80 branch switch in the one above etc. That would be insane... this is why I would consider it best practice to keep only handling the "added" special errors in the error set at the deepest level, and just re-throwing the error as the more general value if it is not any of the specialized ones, because in that case it is <em>guaranteed</em> to be a value from the base sets instead.</p>
<p>There does not exist a way to make this all safe, though. Because if you would now add a new error to the error set <code>ErrExpression</code> for example you would not get a compiler error that you have not checked for that value in the switch, and the branch where you try to cast the error value to the base set type would be executed. As "workaroun" (or actual solution, we will see), casting a specialized error to it's base error while that specialized value holds an actual value greater than it's base type's capacity will crash the program loud and clear. We know at compile-time how big the set <code>ErrStatement</code> is, for example. It's exactly <code>8</code> values big currently. So, if we would try to cast a value with a <code>value_id &gt;= 8</code> to that type it would just crash. It will be just a simple condition under the hood, but this condition prevents errors bubbling up to the main level (which would crash the program annyway most of times).</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="error-switch-inlining"><a class="header" href="#error-switch-inlining">Error Switch Inlining</a></h1>
<p>In Flint, the pattern to write</p>
<pre><code class="language-ft">call() catch err:
	switch err:
		...
</code></pre>
<p>is very very common. And you may notice that the indentation level of the actual switch is 2 in our case. But because this pattern is so common, and because we actually do not further access <code>err</code> at all outside of the <code>switch</code> and we most likely do not write anything else in the catch scope other than the <code>switch</code>, we have developed a special case syntax for this case:</p>
<pre><code class="language-ft">use Core.print

error ErrInline:
	Throwing;

def will_throw() {ErrInline}:
	throw ErrInline.Throwing("Wahu");

def main():
	will_throw() catch:
		ErrInline(b): print("is inline thrown\n");
		anyerror(a): print("is anyerror\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>is inline thrown
</code></pre>
</blockquote>
<p>As you notice, we implicitely switch on the error value, which means that the whole <code>catch:</code> body becomes the body of the <code>switch</code>. The main reason to why we added this is to reduce the nesting level of the code when catching errors. Catching errors is already verbose enough, so reducing the visual clutter to keep you focused on the actual errors you want to catch is important for readability.</p>
<p>Because we switch on the possible error set types (the returned variant) we are actually only able to inline-switch on a function which returns at least one known error type. If the function would only return an <code>anyerror</code> as it's error return, then we would not be able to switch on it. Inline-switching is explicitely meant for switching on the <code>variant&lt;anyerror, ErrInline, ...&gt;</code> error variant.</p>
<p>So, this code:</p>
<pre><code class="language-ft">use Core.print

error ErrInline:
	Throwing;

def will_throw():
	throw ErrInline.Throwing("Wahu");

def main():
	will_throw() catch:
		ErrInline(b): print("is inline thrown\n");
		anyerror(a): print("is anyerror\n");
</code></pre>
<p>will not compile, at all. Because now we switch on the error which is of type <code>anyerror</code>, and we <strong>cannot</strong> switch on the <code>anyerror</code> type. So, inline-switching is only possible on functions which explicitely name their potential errors they might throw.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="inferring-the-error-variant"><a class="header" href="#inferring-the-error-variant">Inferring the Error Variant</a></h1>
<div class="warning">
<p>Inferring the error variant return type is not yet implemented.</p>
<p>This feature, while <em>defintely</em> planned, is not implemented yet. This feature becomes <em>extremely</em> useful in the context of function composition and blueprints, so it's considered a "must-have" feature for Flint.</p>
</div>
<p>You have already seen how we explicitely define which possible error sets a function might throw using the <code>{..}</code> syntax. To this already known syntax now comes a small inferring-tool. When we write a function it always implicitely returns an <code>anyerror</code> if we define nothing else. But, what if we could add a small set of symbols to tell the compiler "put all possible throwing error sets in the return type of the function"? Thats exactly why this chapter exists.</p>
<p>We tell a function to infer all possible error set types through the <code>{_}</code> syntax. The <code>_</code>, as you already know does <strong>always</strong> mean <em>default</em>, <em>infer</em> or <em>unused</em>, and it <strong>never</strong> means anything else in Flint. So, it is only logical to use it to infer the possible error set types of a function. Here is a small example showcasing it:</p>
<pre><code class="language-ft">use Core.print
use Core.assert

error ErrBase:
	Base1, Base2;

error ErrSpecial(ErrBase):
	Special1, Special2;

def do_base(i32 x) {_}:
	if x &gt; 7:
		throw ErrBase.Base2;

def do_something(i32 x) {_}:
	assert(x &gt; 0);
	for i32 i = 0; i &lt; x; i++:
		do_base(i);
		if i &gt; 10:
			throw ErrSpecial.Special1;

def main():
	do_something(13) catch:
		ErrAssert(e):
			print("assertion error thrown\n");
		ErrBase(e):
			print("base error thrown\n");
		ErrSpecial(e):
			print("special error thrown\n");
		anyerror(e):
			print("anyerror thrown\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>special error thrown
</code></pre>
</blockquote>
<p>Well the example isn't as small as i said. Let's go through all functions bit by bit. First, let's talk about the <code>do_base</code> function. It only throws the <code>ErrBase</code> error set, so it's possible error set types are <code>{ErrBase}</code>, nothing more.</p>
<p>The <code>do_something</code> function is a bit more complicated. When we look at the function we first come across the <code>assert</code> call. The <code>Core.assert</code> module provides the <code>ErrAssert</code> error set, which will be thrown by the <code>assert</code> function. So, the <code>do_something</code> function contains at least the <code>{ErrAssert, ...}</code> sets. But let's continue reading through the <code>do_something</code> function. The next call we can see is <code>do_base</code> without any catch on it. The <code>do_base</code> function can throw the <code>{ErrBase}</code> error set. So, the <code>do_something</code> function will inherit this possible error too, so it now has the possible error sets of <code>{ErrAssert, ErrBase, ...}</code>.
When we continue reading through the <code>do_something</code> function we can also find the <code>throw ErrSpecial...</code> line. So, the <code>do_something</code> function also may throw the <code>ErrSpecail</code> error set, and we have reached the end of the function now. This means that the <code>do_something</code> function has the possible error set definition of <code>{ErrAssert, ErrBase, ErrSpecial}</code>. These are the three possible errors the function could throw. So, when we inline-switch the error of the function we switch on the error variable which is of type <code>variant&lt;anyerror, ErrAssert, ErrBase, ErrSpecial&gt;</code>.</p>
<p>When inferring the error set types there is a general rule of thumb: Every <strong>non-catched</strong> call will directly add it's possible errors to the error set of the function, just like every <code>throw</code> statement will, of course. If you would catch an error the possible errors of that call will no longer be part of the error set type. Here is a example of that:</p>
<pre><code class="language-ft">use Core.print
use Core.assert

error ErrBase:
	Base1, Base2;

error ErrSpecial(ErrBase):
	Special1, Special2;

def do_base(i32 x) {_}:
	if x &gt; 7:
		throw ErrBase.Base2;

def do_something(i32 x) {_}:
	assert(x &gt; 0);
	for i32 i = 0; i &lt; x; i++:
		do_base(i) catch err:
			print("doing nothing\n");
		if i &gt; 10:
			throw ErrSpecial.Special1;

def main():
	do_something(13) catch:
		ErrAssert(e):
			print("assertion error thrown\n");
		ErrSpecial(e):
			print("special error thrown\n");
		anyerror(e):
			print("anyerror thrown\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>doing nothing
doing nothing
doing nothing
doing nothing
special error thrown
</code></pre>
</blockquote>
<p>As you can see, the <code>ErrBase</code> from the <code>do_base</code> function call is no longer part of the possible error sets of the <code>do_something</code> function. This feature of inferring the error set types is very powerful, but use it with caution. You should not add it to <em>every</em> function of your codebase and "call it a day". You will learn how to effectively use this feature in later chapters, especially when we take a closer look at Flint's Blueprint system later.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="version_select.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
