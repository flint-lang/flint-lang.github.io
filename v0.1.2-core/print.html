<!DOCTYPE HTML>
<html lang="en" class="flint sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Flint Wiki</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/flint.css">
        <link rel="stylesheet" href="theme/flint-highlight.css">
        <link rel="stylesheet" href="version_select.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "flint";
            const default_dark_theme = "flint";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('flint')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Flint Wiki</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This is the Flint Wiki. You will be able to find anything regarding Flint in this Wiki. It's primary focus is the syntax of Flint, how it works and how to use the language effectively. All features of Flint and how to use them are explained in this Wiki. All chapters are structured in a way where later chapters build on the lessions of earlier chapters, so you will naturally have the best experience with Flint if you follow the guide closely from front to end.</p>
<p>Flint is a high‐level, statically‐typed language designed to deliver maximum power in the most approachable way. Its core philosophy is the Data-Object Convergence Paradigm — an ECS-inspired model where data is separated from behavior and then composed deterministically into class-like entities. Every function in Flint is pure (no side effects), and functions themselves are data that can be passed around or even hot-reloaded — thanks to the Thread Stack, which eliminates the possibility of race conditions by design. Write fast, predictable code without hidden complexity.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>Installing Flint is really easy. Just download the <code>flintc</code> binary for your given platform from the <a href="https://github.com/flint-lang/flintc/releases">Releases</a> page of the <code>flintc</code> repository.</p>
<h2 id="linux"><a class="header" href="#linux">Linux</a></h2>
<p>To make the Flint compiler available from any path in your terminal, and to make it executable through just calling <code>flintc</code> in your terminal, you need to copy the <code>flintc</code> executable into the <code>$HOME/.local/bin/</code> directory and you need to ensure it is marked as executable with this command:</p>
<pre><code class="language-sh">chmod +x $HOME/.local/bin/flintc
</code></pre>
<p>You need <code>base-devel</code> (Arch) or <code>build-essential</code> (Ubuntu) in order for the Flint compiler to be able to compile any program. It needs the <code>crt1.o</code>, <code>crti.o</code> and <code>crtn.o</code> files available to it.</p>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<p>It is actively worked on an installer (<code>.msi</code> file) which will download the compiler for you and will set the <code>PATH</code> variable accordingly. Until then, the path to the executable (<code>flintc.exe</code>) needs to be specified manually when compiling a Flint program.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="from-beginner-to-intermediate"><a class="header" href="#from-beginner-to-intermediate">From Beginner To Intermediate</a></h1>
<p>In this guide, you will learn all the basics of Flint. For easier chapter management, the whole journey of "From Beginner to Master" is split into three parts:</p>
<ul>
<li>"From Beginner to Intermediate" which handles all basics of Flint</li>
<li>"From Intermediate to Expert" which goes more in depth into advanced Flint features</li>
<li>"From Expert to Master" which tries to explain <em>everything</em> Flint has to offer</li>
</ul>
<p>With each chapter, you will learn more and more about the Flint language and its inner workings. At the end of this guide, you will know absolutely everything there is to know about the Flint language. No hidden features, no "never ending learning" of the language itself. Flint is made to be finite. Thats also the reason to why Flint does not ship a built-in standard library (stl).</p>
<p>Flint is meant to be a language framework, which aims to be as easy as possible while being as powerful as possible. We aim to provide you with a box full of little LEGOs. At the end of this guide series, you will know every LEGO block that exists.</p>
<p>Flint is sometimes limited on purpose. It has no manual memory management capabilities, for example, but these limitations all serve a singular purpose: Making Flint easier and quicker to work with, but not letting it feel like magic. Every design choise of Flint has a purpose. At the end of this full guide, you will understand every single design decision we took and why it was made.</p>
<p>But enough talking, lets jump right into it, lets turn you into a Flint master, shall we?</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>In this chapter you will learn the absolute basics of Flint. These basics are very important and you need to keep then in mind from now on.</p>
<p>The basics of every simple program is <code>printing</code>. Any program needs to display information to the user of the program in one form or another. It does not matter if its a GUI (Graphical User Interface) or a CLI (Command Line Interface), the user of a program will almost certainly always need information to reed when executing a program.</p>
<p>So, printing to the console is, in a sense, the most minimal thing a program should do. So lets start the basics with exactly that, and lets print to the console!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="the-hello-world-program"><a class="header" href="#the-hello-world-program">The Hello World Program</a></h1>
<p>Lets create a simple <code>Hello World!</code> program which just prints the text <code>Hello, World!</code> to the CLI. But before we can do that we need to create an entry point for our Flint program.</p>
<p>The entry point of every Flint program is the <code>main</code> function. This function is reserved for the programs entry point, so no other function is allowed to be called <code>main</code>. The entry point of any program is the point where the program starts its execution. Any program works from top to bottom, and everything within the <code>main</code> function is executed first. You dont need to worry about <code>functions</code> yet, they are explained in a later chapter.</p>
<p>But, lets create the example first and then explain what actually happens afterwards:</p>
<pre><code class="language-rs">use Core.print

def main():
    print("Hello, World!\n");
</code></pre>
<p>There is a lot to unpack here. You can safely ignore the <code>use Core.print</code> line for now. Just remember that this line needs to be written in order for the <code>print</code> function to be accessible. But what that line actually does will be described in a <a href="beginners_guide/1_basics/wiki/src/beginners_guide/5_functions.html">later</a> chapter.</p>
<p>The <code>def main():</code> line is the definition of the main function, but functions are described in a <a href="beginners_guide/1_basics/wiki/src/beginners_guide/5_functions.html">later</a> chapter too.</p>
<p>Now we come to the interesting line. <code>print("Hello, World!\n");</code>. <code>print</code> is a function call. A function call is like an instruction to execute. In this case we tell the Flint program to print the text to the console thats written in between the <code>"</code> symbols. This text between the <code>"</code> symbols is called a <strong>string</strong>. Here, we tell the <code>print</code> function to print the string <code>Hello, World!\n</code>. But what is this <code>\n</code> character? Its an escaped character for a new line. The <code>print</code> function does not print a new line after the string, so we need to provide a newline character manually.</p>
<p>The output of the above program would look like this:</p>
<blockquote>
<p>Hello, World!</p>
</blockquote>
<p>Try to remove the <code>\n</code> character and see what it does for yourself!</p>
<p>Always remember: The best way to learn is to try new things. Your computer won't explode if you make mistakes in a program, so just try out a few things and see for yourself what works and what doesn't!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="compiling-the-program"><a class="header" href="#compiling-the-program">Compiling the Program</a></h1>
<p>Save the code from the previous chapter into a file named <code>hello.ft</code>. <code>ft</code> is the file extension for <code>Flint</code> source files. They only contain code in written form. Its then the resposibility of the Flint compiler to take a file containing its source code and creating an executable from it.</p>
<p>To compile the <code>.ft</code> file to an executable file, we call</p>
<pre><code class="language-sh">flintc --file hello.ft --out hello
</code></pre>
<p>This will output the executable in the current working directory. It can be exexuted with the command</p>
<pre><code class="language-sh">./hello
</code></pre>
<p>And now you should see the output of the previous chapter in the console!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="comments-in-flint"><a class="header" href="#comments-in-flint">Comments in Flint</a></h1>
<p>In Flint, comments are used to explain code or temporarily disable parts of it during debugging. Flint supports two types of comments:</p>
<ol>
<li><strong>Single-line comments</strong>: Start with // and continue until the end of the line.</li>
<li><strong>Multi-line comments</strong>: Start with /* and end with */.</li>
</ol>
<p><strong>Here’s how you use comments:</strong></p>
<pre><code class="language-rs">use Core.print

def main():
    // This is a single-line comment explaining the print statement below
    print("Hello, Flint!"\n);

    /*
     This is a multi-line comment.
     You can use it for detailed explanations
     or temporarily disabling multiple lines of code.
    */
    // print("This line is commented out and won't run.");
</code></pre>
<p>Comments are essential for writing clear, understandable, and maintainable code. Use them to explain your logic to others (or to yourself when revisiting code later).</p>
<p>Try to copy the code above into your <code>hello.ft</code> file and try to compile and run it.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="indentation-in-flint"><a class="header" href="#indentation-in-flint">Indentation in Flint</a></h1>
<p>Flint enforces <strong>strict indentation rules</strong> to ensure clean and readable code. Also, indentation is needed for <em>scoping</em>. Everything writen within the <code>main</code> functions is "inside" that function. If you don't indent instructions that are meant to be placed within the main function, for example, Flint will try to see if the line you wrote is a function or something else, like the <code>use Core.print</code> line.</p>
<p>Lets look at it in action:</p>
<pre><code class="language-rs">use Core.print

def main():
print("This is not indented correctly.\n");
</code></pre>
<p>When you run the above code, you’ll see an error message:</p>
<blockquote>
<pre><code>Parse Error at hello.ft:4:1
 -- Expected a body, but got:
print("This is not indented correctly.");
</code></pre>
</blockquote>
<p>This happens because Flint expects all code inside main to be indented. Here’s the correct way to write it:</p>
<pre><code class="language-rs">def main():
	print("This is correctly indented.\n"); // Properly indented
</code></pre>
<p>Proper indentation is not just a stylistic choice in Flint – it’s a fundamental part of the syntax. You do not need to indent using hard tabs (<code>\t</code>), <strong>4 spaces</strong> are interpreted as tabs by the Flint compiler.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="variables-and-types"><a class="header" href="#variables-and-types">Variables and Types</a></h1>
<p>In the previous chapter, we learned the basics of printing to the console in Flint. Now that we have a way to display information, let's talk about how to store and manipulate that information. In this chapter, we will explore the fundamental concepts of variables and types in Flint.</p>
<h2 id="what-are-variables"><a class="header" href="#what-are-variables">What are Variables?</a></h2>
<p>A variable is a named storage location that holds a value. Think of it as a labeled box where you can store a value. You can then use the variable name to refer to the value stored in the box.</p>
<h2 id="what-are-types"><a class="header" href="#what-are-types">What are Types?</a></h2>
<p>A type is a classification of data that determines the type of value a variable can hold. In Flint, every variable has a specific type, which determines the kind of value it can store. For example, a variable of type <code>i32</code> can only store integer values, while a variable of type <code>str</code> can only store text.</p>
<h2 id="why-are-variables-and-types-important"><a class="header" href="#why-are-variables-and-types-important">Why are Variables and Types Important?</a></h2>
<p>Variables and types are essential concepts in programming because they allow you to:</p>
<ul>
<li>Store and manipulate data in a program</li>
<li>Write more efficient and readable code</li>
<li>Avoid errors by ensuring that the correct type of data is used</li>
</ul>
<p>In this chapter, we will delve deeper into the world of variables and types in Flint. We will learn how to declare variables, assign values to them, and use them in our programs. We will also explore the different types of data that Flint supports, including integers, strings, and more.</p>
<h2 id="what-to-expect"><a class="header" href="#what-to-expect">What to Expect</a></h2>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Declaring variables and assigning values to them</li>
<li>Understanding the different types of data in Flint</li>
<li>Using variables and types in our programs</li>
<li>Best practices for working with variables and types</li>
</ul>
<p>By the end of this chapter, you will have a solid understanding of variables and types in Flint, and you will be able to use them to write more effective and efficient programs. Let's get started!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h1>
<p>Primitive types are Flint's fundamental building blocks for representing data. They are the simplest forms of values you can use in your programs. Flint has the following primitive types:</p>
<ol>
<li><code>i32</code>
Represents whole numbers, both positive and negative. Use <code>i32</code> for counting, indexing, or whenever you need discrete values.</li>
</ol>
<pre><code class="language-rs">i32 x = 42; // A positive integer
i32 y = -15; // A negative integer
i32 z = 0; // Zero is also an integer
</code></pre>
<ol start="2">
<li><code>u32</code>
Represents whole numbers, but only positive ones. Use <code>u32</code> for IDs.</li>
</ol>
<pre><code class="language-rs">u32 id_1 = 1;
u32 id_0 = 0:
</code></pre>
<ol start="3">
<li><code>f32</code>
Represents floating-point numbers (decimal numbers). Use <code>f32</code> for measurements, precise calculations, or any value that requires a fractional component.</li>
</ol>
<pre><code class="language-rs">f32 pi = 3.14; // Approximation of π
f32 zero_kelvin = -273.15; // Negative floating point values are valid
f32 zero = 0.0; // Zero with a decimal
</code></pre>
<ol start="4">
<li><code>str</code>
Represents a sequence of characters or text, as already described in the printing chapter. Use <code>str</code> for names, messages, or any textual data. Strings must be enclosed in double quotes (<code>"</code>).</li>
</ol>
<pre><code class="language-rs">str name = "Flint"; // A simple string
str empty = ""; // An empty string
str greeting = "Hello, World!"; // A common example
</code></pre>
<p>These types are the foundation of Flint's data handling. As you write more complex programs, you'll combine them in creative ways to represent and manipulate information. But these are not the only primitive types there are available for Flint, they are just the most frequently used ones.</p>
<h2 id="bit-width"><a class="header" href="#bit-width">Bit-Width</a></h2>
<p>Now lets talk a bit about bit-width. You surely have seen the number after <code>i</code>, <code>u</code> and <code>f</code>. This is the <strong>bit-width</strong>. Computers work with bits, in this case it means that the integer and floating point types are 32 bits long. Here is a full list of all primitive types in Flint and their minimum and maximum values:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Type</th><th>Description</th><th style="text-align: center">Min</th><th style="text-align: center">Max</th><th>Precision</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>u8</code></td><td>unsigned 8 bit integer</td><td style="text-align: center"><code>0</code></td><td style="text-align: center"><code>255</code></td><td>Whole numbers</td></tr>
<tr><td style="text-align: center"><code>u32</code></td><td>unsigned 32 bit integer</td><td style="text-align: center"><code>0</code></td><td style="text-align: center"><code>4,294,967,295</code></td><td>Whole numbers</td></tr>
<tr><td style="text-align: center"><code>u64</code></td><td>unsigned 64 bit integer</td><td style="text-align: center"><code>0</code></td><td style="text-align: center">≈ <code>1.844 × 10^19</code></td><td>Whole numbers</td></tr>
<tr><td style="text-align: center"><code>i32</code></td><td>signed 32 bit integer</td><td style="text-align: center"><code>-2,147,486,648</code></td><td style="text-align: center"><code>2,147,486,647</code></td><td>Whole numbers</td></tr>
<tr><td style="text-align: center"><code>i64</code></td><td>signed 64 bit integer</td><td style="text-align: center">≈ <code>-1.844 × 10^19</code></td><td style="text-align: center">≈ <code>1.844 × 10^19</code></td><td>Whole numbers</td></tr>
<tr><td style="text-align: center"><code>f32</code></td><td>32 bit floating point number</td><td style="text-align: center">≈ <code>±1.175 × 10^-38</code></td><td style="text-align: center">≈ <code>±1.701 × 10^38</code></td><td>≈ 6 - 9 digits</td></tr>
<tr><td style="text-align: center"><code>f64</code></td><td>64 bit floating point number</td><td style="text-align: center">≈ <code>±1 × 10^-383</code></td><td style="text-align: center">≈ <code>±9.999 × 10^384</code></td><td>≈ 16 digits</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>Let's talk about variables and what they really are. A <em>variable</em> is an element of data that can be modified during the execution of a program, this can be an integer value, for example, or a string value. Variables are one of, if not even <em>the</em> most important part of a program.</p>
<p>Every variable needs to have a fixed <em>type</em> assigned to it. There are much more types than only the primitive types of the last chapter, but everything in this chapter will apply to other types as well. First, we need to define a variable. This is done like this:</p>
<pre><code class="language-rs">def main():
    i32 x = 5;
</code></pre>
<p>You have already seen this in the last chapter, so lets unpack it now. <code>i32</code> is the type of the variable. <code>x</code> is the name (<em>identifier</em>) of the variable we just created, and we <em>declare</em> the variable <code>x</code> to be the value of <code>5</code>. This whole line you see above is called a <code>declaration</code>, because we declare a new variable.
Now lets look at how to assign new values to the variable:</p>
<pre><code class="language-rs">def main():
    i32 x = 5; // The declaration
    x = 7; // The assignment
</code></pre>
<p>We now store the value of <code>7</code> in the previously declared variable <code>x</code>. The variable <code>x</code> still has the type of <code>i32</code>. Types of variables cannot change after we declared a variable. This whole characteristic, that the type cannot change after the creation of a variable, and that the type of a variable is fixed, is called <strong>static typing</strong>.</p>
<h2 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h2>
<p>But what if we write something like this?</p>
<pre><code class="language-rs">def main():
    i32 x = 7;
    i32 x = 8;
</code></pre>
<p>You can try to compile this program yourself and see what you get. But to make things a bit easier i show you. You will get this error:</p>
<blockquote>
<p>Parse Error at main.ft:3:9
-- Variable 'x' already exists</p>
</blockquote>
<p>As you can see, Flint only allows one single variable with the identifier <code>x</code> to exist within the main function, even if its type differs:</p>
<pre><code class="language-rs">def main():
    i32 x = 7;
    f32 x = 3.3;
</code></pre>
<p>This fails with the same error. Some languages support that a variable is "redefined" with another type, and from this new declaration onwards the variable has a different type. This is called <em>shadowing</em>, and Flint does not support this intentionally. Every variable can only exist once within a scope (we talk about scopes later on).</p>
<p>So, remember: The same identifier can only used once for variables!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="inferred-typing"><a class="header" href="#inferred-typing">Inferred Typing</a></h1>
<p>Flint allows for inferred typing, meaning you don't always need to explicitly state the type of a variable. The compiler can infer the type based on the assigned value.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<pre><code class="language-rs">x := 42; // The compiler infers that x is an i32
pi := 3.14; // The compiler infers that pi is a f32
greeting := "Hello, Flint!"; // The compiler infers that greeting is a str
</code></pre>
<p>While inferred typing is convenient and makes code concise, explicit typing can improve readability in more complex programs. You can always use explicit typing if you prefer its clarity:</p>
<pre><code class="language-rs">i32 x = 42; // Explicitly declare x as an i32
f32 pi = 3.14; // Explicitly declare pi as a f32
str greeting = "Hello, Flint!"; // Explicitly declare greeting as a str
</code></pre>
<p>Use inferred typing for shorter, simpler programs and explicit typing when clarity is crucial.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="operators"><a class="header" href="#operators">Operators</a></h1>
<p>Flint has quite a few operators in its disposal. The most common and most simple ones, however, are <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code>. The <code>+</code> and <code>-</code> operators dont need much explaination, really.</p>
<h2 id="integer-arithmetic"><a class="header" href="#integer-arithmetic">Integer Arithmetic</a></h2>
<p>Lets start with the most obvious example first: integer types and lets go through all operations one by one:</p>
<h3 id="the--operator"><a class="header" href="#the--operator">The <code>+</code> Operator</a></h3>
<p>The <code>+</code> operator is very easy, it is used to add two numbers together. But there is a catch... do you remember the <a href="beginners_guide/2_variables_and_types/./1_primitive_types.html#bit-width">Bit-Width</a> table from <a href="beginners_guide/2_variables_and_types/./1_primitive_types.html">this</a> chapter? This now becomes important, more specifically the <strong>Min</strong> and <strong>Max</strong> value columns. For example, if you add two <code>u32</code> typed variables together, like so:</p>
<pre><code class="language-rs">def main():
    u32 n1 = 4_294_967_290;
    u32 n2 = 10;
    u32 n3 = n1 + n2;
</code></pre>
<p>what value should <code>n3</code> then have? Oh, and dont get confused by the <code>_</code> values in the number. Flint will ignore these and it will read the number as <code>4294967290</code> just fine, but they make the number <em>much</em> more readable!</p>
<p>If you execute the built binary you will see this message printed to your console:</p>
<blockquote>
<pre><code>u32 add overflow caught
</code></pre>
</blockquote>
<p>This happens, because the maximum value of an <code>u32</code> is <code>4.294.967.295</code> and <code>4.294.967.290 + 10 = 4.294.967.300</code>, which is greater than the maximum value of the <code>u32</code> type. In any computers, the numbers are represented as binaries (<code>0</code> and <code>1</code>) and any number uses the <code>binary</code> number system. If you are interested in this topic you can search for <strong>Integer Overflow</strong>.</p>
<p>In Flint, however, the <code>u32</code> value is just capped to the maximum value of <code>u32</code>. So, <code>n3</code> will have the value <code>4.294.967.295</code> saved in it after the addition.</p>
<h3 id="the---operator"><a class="header" href="#the---operator">The <code>-</code> Operator</a></h3>
<p>The same as above applies here. The minimum value for <code>u32</code> values is <code>0</code>, so if we try to run this program:</p>
<pre><code class="language-rs">def main():
    u32 ten = 10;
    u32 twenty = 20;
    u32 result = ten - twenty;
</code></pre>
<p>we get a similar message as before:</p>
<blockquote>
<pre><code>u32 sub underflow caught
</code></pre>
</blockquote>
<p>A <code>underflow</code> is the same as an <code>overflow</code> but for the minimum value instead of the maximum value. Just like with the overflows, Flint clamps the value at <code>0</code> here too.</p>
<h3 id="the--operator-1"><a class="header" href="#the--operator-1">The <code>/</code> Operator</a></h3>
<p>Because integer types (<code>i32</code>, <code>u32</code>, ...) don't have a fractional part like floating point types (<code>f32</code>, ...) they cannot preserve their fractional information when dividing. This means that in this function here:</p>
<pre><code class="language-rs">def main():
    i32 n1 = 100;
    i32 n2 = 30;
    i32 n3 = n1 / n2;
</code></pre>
<p>The varaible <code>n3</code> will have the value <code>3</code> saved in it, even though the value actually would be <code>3,333..</code>. This is a characteristic of <strong>integer division</strong>. The fractional part is <em>always</em> cut off. If you program a bit you will actually find out that this behaviour can work to your advantage. So, this also means that the result of <code>100 / 60</code> is <code>1,666..</code> with the fractional, but for integer divisions its just <code>1</code>.</p>
<p>The <code>*</code> Operator is pretty easy to understand, actually. There aren't much things to consider when using it ecept for a possible <em>integer overflow</em> if the result becomes too large and order of operation.</p>
<p>Order of Operation (or better said the <em>wrong</em> order of operation) is a very common mistake regarding integer arithmetic. It is commonly overlooked that a division can lead to a <code>0</code>, for example with the calculation of <code>10 / 8 * 16</code>, we would expect the result to be <code>20</code>. But the calculation is evaluated as follows: <code>(10 / 8) * 16</code> which expands to <code>10 / 8</code> which is <code>0</code>.</p>
<p>So, mathematically we would expect the result to be <code>20</code> but because of the order of operations it has become <code>0</code> instead. This can only be fixed by applying the correct oder, in our case this would be <code>10 * 16 / 8</code> which gets evaluated to <code>(10 * 16) / 8</code> which will result in the expected result of <code>20</code>.
Note that you can also use parenthesis to explicitely state the order of operation you want to have: <code>10 / (8 * 16)</code> (this will still result in <code>0</code> but its evaluated differently).</p>
<h3 id="the--and--operators"><a class="header" href="#the--and--operators">The <code>==</code> and <code>!=</code> Operators</a></h3>
<p>One can also <em>compare</em> two integer values with one another. The comparison returns a boolean (<code>bool</code> type) which is used for comparisons, but you will learn more about what a <code>bool</code> is in the upcoming chapter <a href="beginners_guide/2_variables_and_types//wiki/src/beginners_guide/3_control_flow.html">here</a>. For now, just note that the operator exists.</p>
<h2 id="floating-point-arithmetic"><a class="header" href="#floating-point-arithmetic">Floating Point Arithmetic</a></h2>
<p>Floating Point Arithmetic can be pretty tricky at times. Flint's floating points use the IEEE-754 standard. If you don't know what this means, dont worry, we will talk about it here, as easy as possible. If you want to know more about the standard and how floating point numbers are actually implemented, it is recommended to look <a href="https://www.geeksforgeeks.org/ieee-standard-754-floating-point-numbers/">here</a>.</p>
<p>But, in a nutshell, any floating point number comes with a specific level of <strong>inprecision</strong>. You dont need to worry about what this means for now, just remember that a number might not be <strong>exactly</strong> the number you specified, because some numbers (like <code>1 / 3</code>) cannot be stored in a number on the computer, because its result is <code>0.333...</code> and it cannot be stored and compared reliably. Also, some numbers just cannot be stored fully in floating point numbers. Here is a small example showing floating point arithmetic inprecision in action:</p>
<pre><code class="language-rs">use Core.print

def main():
    f64 val = 0.05;
    val += 0.3;
    print($"0.05 + 0.3 = {val}\n");
    print($"{val} == 0.35 ? {val == 0.35}\n");
</code></pre>
<p>From this small program, you will see the output</p>
<blockquote>
<pre><code>0.05 + 0.3 = 0.350000012665987

0.350000012665987 == 0.35 ? false
</code></pre>
</blockquote>
<p>Don't worry about that <code>$"{..}"</code> thing, its called <em>string interpolation</em> and you will learn about it <a href="beginners_guide/2_variables_and_types/./6_string_interpolation.html">shortly</a>.</p>
<p>But, as you can see the condition is <code>false</code>, thats because <code>val</code> is not <strong>exactly</strong> the same as <code>0.35</code> in this case, because their bits differ. So, use the <code>==</code> and <code>!=</code> operators with caution when dealing with floating point variables.</p>
<h2 id="strings"><a class="header" href="#strings">Strings</a></h2>
<p>Strings (<code>str</code> type) do not support the <code>-</code>, <code>*</code> or <code>/</code> operators. <em>But</em> you can use the <code>+</code> operator to add (concatenate) two strings:</p>
<pre><code class="language-rs">use Core.print

def main():
    str hello = "Hello, ";
    str world = "World!\n";
    str hello_world = hello + world;
    print(hello_world);
</code></pre>
<p>If you run this program, you will see this output in your console:</p>
<blockquote>
<pre><code>Hello, World!
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="typecasting"><a class="header" href="#typecasting">Typecasting</a></h1>
<p>First of all, what is typecasting? We know what a <code>type</code> is, but what is <code>casting</code>? Casting is the act of <em>converting</em> one type into another. Different types are incompatible with one another, even <code>i32</code> and <code>u32</code> are incompatible, even though both of them have the same bit width. For example, the <code>i32</code> value of <code>-233235653</code> would actually be <code>4061731643</code> when the bits would be interpreted as an <code>u32</code> instead. And if the 32 bits of the <code>i32</code> value would be interpreted as an <code>f32</code> value, we would end up with the number <code>-3.032584e30</code>. (The bit pattern of this example is <code>1111 0010 0001 1001 0001 1011 0011 1011</code>)</p>
<p>As you can see, just storing the bits of one number into the bits of another number is not enough. This is the reason to why we need to convert, or <strong>cast</strong> types. Try to compile this program and see what the compiler tells you:</p>
<pre><code class="language-rs">def main():
    i32 val = 3.3;
</code></pre>
<p>The compiler will throw an error like:</p>
<blockquote>
<pre><code>Parse Error at main.ft:2:15
 -- Type mismatch of expression 3.3;
 -- Expected i32 but got f32
</code></pre>
</blockquote>
<p>and it will tell you exactly what went wrong. The type of <code>i32</code> was expected, beause we want to store something of type <code>i32</code> in the variable <code>val</code>, but we provided a floating point number, which defaults to <code>f32</code>. So, we need to convert the type of <code>f32</code> to <code>i32</code> in this case.</p>
<h2 id="explicit-typecasting"><a class="header" href="#explicit-typecasting">Explicit Typecasting</a></h2>
<p>Types can be explicitely cast like this:</p>
<pre><code class="language-rs">def main():
    i32 val = i32(3.3);
</code></pre>
<p>We just write the type we want to have like <code>i32</code> in this case followed by an open paren <code>(</code> and then the <strong>expression</strong> which has a different type and then the closing paren <code>)</code>.</p>
<p>Also, every type can be cast to an <code>str</code> type! Try to run this program and see what happens:</p>
<pre><code class="language-rs">use Core.print

def main():
    f32 fval = 3.3;
    str message = "fval = ";
    message += str(fval);
    message += "\n";
    print(message);
</code></pre>
<p>You will see the message</p>
<blockquote>
<pre><code>fval = 3.3
</code></pre>
</blockquote>
<p>printed to the console.</p>
<p>Okay, and now a bit more complicated example:</p>
<pre><code class="language-rs">use Core.print

def main():
    f32 fval = 3.7;
    i32 ival = i32(fval);
    str message = "fval = ";
    message += str(fval);
    message += ", ival = ";
    message += str(ival);
    message += "\n";
    print(message);
</code></pre>
<p>This small program prints this message to the console:</p>
<blockquote>
<pre><code>fval = 3.7, ival = 3
</code></pre>
</blockquote>
<p>You maybe expected a result like</p>
<blockquote>
<pre><code>fval = 3.7, ival = 4
</code></pre>
</blockquote>
<p>but here comes some very important information about type casting: When casting floating point types to integer types the fractional part is simply <strong>cut off</strong>. Its never rounded, only cut. But that definitely can be a good thing, if used correctly. Just remember, that when casting floating point values to integer values you will simply loose the fractional information.</p>
<h2 id="implicit-typecasting"><a class="header" href="#implicit-typecasting">Implicit Typecasting</a></h2>
<p>Everything we have discussed up until now was regarding the act of <strong>explicitely casting</strong> values. But, some values can be cast <strong>implicitely</strong> by the compiler. There exists one rule of thumb in Flint: You can cast types implicitely if you <em>won't</em> loose any information through that cast. So, you can happily implicitely cast <code>i32</code> to <code>f32</code> but you <em>cannot</em> implicitely cast <code>f32</code> to <code>i32</code>. Also, pretty much <em>any</em> type can be implicitely cast to a <code>str</code> type too! Here's how this looks in action:</p>
<pre><code class="language-rs">use Core.print

def main():
    f32 fval = 3;
    str message = "fval = ";
    message += fval;
    message += "\n";
    print(message);
</code></pre>
<p>Notice how we did not write <em>any</em> explicit casting whatsoever? This program prints this message to the console:</p>
<blockquote>
<pre><code>fval = 3.0
</code></pre>
</blockquote>
<p>Note that the floating point to string conversion happened implicitely?</p>
<div class="warning">
<p>This behaves differntly in the current release of Flint</p>
<p>Currently, you won't see <code>fval = 3.0</code> printed to the console, but rather <code>fval = 3</code>. This is not a big deal, it only happens when the fractional part of the floating point value is zero, but this behaviour is a bit misleading, as you now could think that the value used to print <code>3</code> is an integer type, not a floating point type. Printing <code>3.0</code> makes this unambiguous and is considered the correct way to do it.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="string-interpolation"><a class="header" href="#string-interpolation">String Interpolation</a></h1>
<p>Until now you have seen quite often that we do something like this:</p>
<pre><code class="language-rs">use Core.print

def main():
    f32 fval = 3;
    str message = "fval = ";
    message += fval;
    message += "\n";
    print(message);
</code></pre>
<p>We create the <code>message</code> variable and then write <code>+=</code> over and over again to fill the string with values. But, there is a <strong>much</strong> simpler way of integrating variables into a string, its called <strong>string interpolation</strong>. You have already seen it once, but lets explain it now.</p>
<p>The syntax of string interpolation is quite simple. You write a normal string, like <code>"Hello Flint"</code>. Then you put a dollar sign in front of the string: <code>$"Hello, Flint"</code>. And thats (almost) it. Now, everything thats written in between curly braces <code>{}</code> is handled as an <strong>expression</strong>. Expressions are everything that you would write on the right side of the equals sign, for example. So, here an easy example:</p>
<pre><code class="language-rs">use Core.print

def main():
    str name = "Flint";
    i32 age = 1;
    print($"Hello, my name is {name} and I am {age} years old.\n");
</code></pre>
<p>Output:</p>
<blockquote>
<pre><code>Hello, my name is Flint and I am 1 years old.
</code></pre>
</blockquote>
<p>And now you see why its important that almost any type can be implicitely cast to a <code>str</code> type, because otherwise we would need to write <code>str(age)</code> here, or need to write <code>str(..)</code> any time we would want to use string interpolation.</p>
<p>You can actually interpolate any variable or expression into a string:</p>
<pre><code class="language-rs">use Core.print

def main():
    f32 pi = 3.14;
    // Inserting floating point values
    print($"The value of pi is approximately {pi}\n");
    // Inserting an arithmetic expression
    print($"2 + 2 equals {2 + 2}\n");
</code></pre>
<p>Which prints these lines to the console:</p>
<blockquote>
<pre><code>The value of pi is approximately 3.14
2 + 2 equals 4
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<p>In the previous chapters, we learned the basics of printing to the console and working with variables and types in Flint. Now that we have a way to display information and store data, let's talk about how to control the flow of our program's execution. In this chapter, we will explore the fundamental concepts of control flow in Flint.</p>
<h2 id="what-is-control-flow"><a class="header" href="#what-is-control-flow">What is Control Flow?</a></h2>
<p>Control flow refers to the order in which a program's statements are executed. In other words, it's the way a program decides what to do next. Control flow is essential in programming because it allows you to write programs that can make decisions, repeat tasks, and handle different situations.</p>
<h2 id="why-is-control-flow-important"><a class="header" href="#why-is-control-flow-important">Why is Control Flow Important?</a></h2>
<p>Control flow is crucial in programming because it enables you to:</p>
<ul>
<li>Write programs that can adapt to different inputs and situations</li>
<li>Repeat tasks without having to write the same code multiple times</li>
<li>Make decisions based on conditions and data</li>
</ul>
<p>In this chapter, we will learn about the different control flow statements in Flint, including conditional statements, loops, and functions. We will see how to use these statements to write more efficient, readable, and effective programs.</p>
<h2 id="what-to-expect-1"><a class="header" href="#what-to-expect-1">What to Expect</a></h2>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Conditional statements: if, else, and switch</li>
<li>Loops: for, while, and repeat</li>
<li>Best practices for working with control flow statements</li>
</ul>
<p>By the end of this chapter, you will have a solid understanding of control flow in Flint, and you will be able to use it to write more sophisticated and efficient programs. Let's get started!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="the-bool-type"><a class="header" href="#the-bool-type">The <code>bool</code> Type</a></h1>
<p>In Flint, the <code>bool</code> type represents truth values: <code>true</code> or <code>false</code>. Boolean values are fundamental in programming, as they enable decision-making and control flow. Boolean values are equal both in programming and in mathematics, they actually dont really differ. Here is a small example of how to declare a boolean variable and how to print its value to the console:</p>
<pre><code class="language-rs">use Core.print

def main():
    bool is_learning = true;
    bool is_hungry = false;
    print($"is_learing = {is_learning}, is_hungry = {is_hungry}\n");
</code></pre>
<p>This program prints this line to the console:</p>
<blockquote>
<pre><code>is_learing = true, is_hungry = false
</code></pre>
</blockquote>
<h2 id="checking-for-equality-and-inequality"><a class="header" href="#checking-for-equality-and-inequality">Checking for equality and inequality</a></h2>
<p>You can check if a boolean type is equal to another boolean type. The result of the <code>==</code> and <code>!=</code> operators is <em>always</em> a <code>bool</code> type, because either they are equal or not. So, if you look if two <code>i32</code> values are equal, the result of this check will be of type <code>bool</code>.</p>
<pre><code class="language-rs">use Core.print

def main():
    i32 val1 = 4;
    i32 val2 = 6;
    bool is_eq = val1 == val2;
    bool is_neq = val1 != val2;
    print($"val1 = {val1}, val2 = {val2}, is_eq = {is_eq}, is_neq = {is_neq}\n");
</code></pre>
<p>This program prints this line to the console:</p>
<blockquote>
<pre><code>val1 = 4, val2 = 6, is_eq = false, is_neq = true
</code></pre>
</blockquote>
<p>But now lets compare two boolean values with one another:</p>
<pre><code class="language-rs">use Core.print

def main():
    bool t_eq_f = true == false;
    print($"t_eq_f = {t_eq_f}\n");

    bool t_neq_f = true != false;
    print($"t_neq_f = {t_neq_f}\n");

    bool t_eq_t = true == true;
    print($"t_eq_t = {t_eq_t}\n");
    bool t_neq_t = true != true;
    print($"t_neq_t = {t_neq_t}\n");

    bool f_eq_f = false == false;
    print($"f_eq_f = {f_eq_f}\n");
    bool f_neq_f = false != false;
    print($"f_neq_f = {f_neq_f}\n");
</code></pre>
<p>This program prints these lines to the console:</p>
<blockquote>
<pre><code>t_eq_f = false
t_neq_f = true
t_eq_t = true
t_neq_t = false
f_eq_f = true
f_neq_f = false
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="boolean-operations"><a class="header" href="#boolean-operations">Boolean Operations</a></h1>
<p>Boolean operators, such as <code>and</code>, <code>or</code> and <code>not</code> combine or modify <code>bool</code> values. They’re useful for creating more complex conditions. In this chapter, you will learn how each operator works.</p>
<h2 id="and-operator"><a class="header" href="#and-operator"><code>and</code> Operator</a></h2>
<p>The <code>and</code> operator combines two conditions and evaluates to <code>true</code> only if <strong>both</strong> conditions are <code>true</code>.</p>
<pre><code class="language-rs">use Core.print

def main():
    bool is_adult = true;
    bool has_id = false;
    print($"Is adult and has an ID? {is_adult and has_id}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>Is adult and has an ID? false
</code></pre>
</blockquote>
<h2 id="or-operator"><a class="header" href="#or-operator"><code>or</code> Operator</a></h2>
<p>The <code>or</code> operator combines two conditions and evaluates to <code>true</code> if <strong>at least</strong> one condition is <code>true</code>.</p>
<pre><code class="language-rs">use Core.print

def main():
    bool is_vip = true;
    bool has_ticket = false;
    print($"Is VIP or has a ticket? {is_vip or has_ticket}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>Is VIP or has a ticket? true
</code></pre>
</blockquote>
<h2 id="not-operator"><a class="header" href="#not-operator"><code>not</code> Operator</a></h2>
<p>The <code>not</code> operator inverts the value of a boolean, so it makes <code>false</code> to <code>true</code> and vice versa.</p>
<pre><code class="language-rs">use Core.print

def main():
    bool is_raining = false;
    print($"Is it not raining? {not is_raining}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>Is it not raining? true
</code></pre>
</blockquote>
<h2 id="operator-precedence"><a class="header" href="#operator-precedence">Operator Precedence</a></h2>
<p>The precedence (default order of execution) of <code>and</code> is higher than the one of <code>or</code>, similar to how <code>*</code> has a higher precedence than <code>+</code> in arithmetics. This means that the <code>and</code> operation will always be evaluated <em>before</em> the <code>or</code> operation:</p>
<pre><code class="language-rs">use Core.print

def main():
    // Evaluates to 'true' ('and' happens first)
    bool condition = true or false and false;
    print($"condition = {condition}\n");

    // Evaluates to 'false' ('and' happens second)
    bool clarified = (true or false) and false;
    print($"clarified = {clarified}\n");
</code></pre>
<p>This program prints these lines to the console:</p>
<blockquote>
<pre><code>condition = true
clarified = false
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="branching"><a class="header" href="#branching">Branching</a></h1>
<p>Branching is the act of executing different "blocks" of code depending on conditions (booleans). But, before we can talk about branching we need to talk about what this <em>block</em> really is. Take the main function, for example:</p>
<pre><code class="language-rs">use Core.print

def main():
    f32 val = 3.3;
    i32 val_i = i32(val);
    print($"{val} = {val_i}\n");
</code></pre>
<p>In this function, everything thats indented once is considered to be "inside" the main function. But what does this "inside" really mean? There exists a formal description for this "inside", it's called a <code>Scope</code>. The Scope of the main function is everything thats written down within the main functions <em>body</em> ("inside" the function).</p>
<p>Scopes are a really important concept in programming, because there exist several consistent and deterministic rules about scopes and <em>subscopes</em>. But thats enough theory for now, lets look at the easiest example for branching, the <code>if</code> statement.</p>
<h2 id="the-if-statement"><a class="header" href="#the-if-statement">The if Statement</a></h2>
<p>The if statement lets your program execute code only when a condition evaluates to true. Here's how it works:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32 age = 18;

    if age &gt;= 18: // The condition evaluates to true
        print($"You are {age} years old, so you can vote!\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>You are 18 years old, so you can vote!
</code></pre>
</blockquote>
<p>Try changing the <code>age</code> to <code>17</code> and watch what happens.</p>
<p>If the condition evaluates to false, the program skips the block of code inside the <code>if</code> statement. We say that the <code>print</code> call here is <strong>inside the if statement's scope</strong>. But what does scope really mean? Have a look at this example:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32 age = 18;

    if age &gt;= 18:
        i32 somevalue = 22;
        print("Age is above or equal to 18!\n");

    print($"somevalue = {somevalue}\n");
</code></pre>
<p>Here, the declaration of the <code>age</code> variable is inside the <code>main</code> function's scope, while the <code>somevalue</code> declaration and the first <code>print</code> call are inside the <code>if</code> statement's scope. The second <code>print</code> call, however, is inside the <code>main</code> function's scope again. As you can see, the scope is direclty determined by the level of indentation.</p>
<p>If yout try to compile this program you will see a compilation error:</p>
<blockquote>
<pre><code>Parse Error at main.ft:10:26
 -- Use of undeclared variable 'somevalue'
</code></pre>
</blockquote>
<p>But why is that? We did define the variable <code>somevalue</code> in the if statement's scope, right? Yes, we defined the variable in the if statement's scope, but here comes one of the mentioned rules of scopes into play: Visibility.</p>
<p>But what's visibility? Visibility describes the visibility of variables within scopes and their parent or child scopes. The if statement's scope, for example, is a <code>child scope</code> of the <code>main</code> function's scope. Because its a child scope it can "see" all variables of its parent scope. <strong>But</strong> it can only see variables that have been defined up until the child scope. To illustrate what this means, look at this example:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32 val1 = 1;
    if val1 &lt; 10:
        print("val1 &lt; 10\n");
    i32 val2 = 2;
</code></pre>
<p>what i described above means nothing else than the simple fact that <code>val1</code> is <strong>visible</strong> inside the if statements scope, but <code>val2</code> is <em>not</em>, because <code>val2</code> is defined <strong>after</strong> the if statements scope. So, a child scope can only see variables of its parent scope that have been declared <strong>before</strong> it.</p>
<p>Parent scopes <strong>do not</strong> inherit <strong>any</strong> variable definitions of their child scopes. This program, for example:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32 val1 = 2;
    if val1 &lt; 10:
        i32 val2 = 44;
        print($"val1 = {val1}, val2 = {val2}\n");
    i32 val2 = 12;
    print($"val1 = {val1}, val2 = {val2}\n");
</code></pre>
<p>will compile and run fine. But lets discuss why that is. The variable <code>val2</code> is defined <em>inside</em> the if statements scope, this means that its visible for the rest of the if statements scope and all possible child scopes of it, but it is not visible for its parent scope. Because the variable <code>val2</code> does not exist in the main function's scope yet, this works fine, as no variable definition is shadowed. Because the variable <code>val2</code> never existed in the main function's scope, we can declare a new variable <code>val2</code> inside the main function.</p>
<p>This behaviour of visibility given down to children but never up to parents is the very reason why the compile error from above happened, becaue the variable <code>somevalue</code> was never defined in the main functions scope, so it simply does not exist at the position we wanted to use it.</p>
<h2 id="the-else-keyword"><a class="header" href="#the-else-keyword">The else Keyword</a></h2>
<p>Now that you know scopes and visibility, the else statement should actually be pretty easy to understand. An else statement is used whenever you want to do something if another condition failed. It is explained best through an example:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32 age = 16;

    if age &gt;= 18: // If this is false...
        print($"You are {age} years old, so you can vote!\n");
    else: // ...then this block executes
        print($"You are {age} years old, so you cannot vote.\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>You are 16 years old, so you cannot vote.
</code></pre>
</blockquote>
<p>Try changing the <code>age</code> variable to, lets say 20, and see what happens.</p>
<h2 id="the-else-if-keyword"><a class="header" href="#the-else-if-keyword">The else if Keyword</a></h2>
<p>Sometimes, you need multiple conditions. Instead of stacking multiple if statements, you can use else if to create a chain of conditions. The important thing to remember here is that <strong>only one</strong> of the branches will be executed, not multiple ones.</p>
<pre><code class="language-rs">use Core.print

def main():
    i32 age = 16;

    if age &gt;= 65:
        print("You qualify for senior discounts.\n");
    else if age &gt;= 18:
        print("You can vote but no senior discounts yet!\n");
    else:
        print("You are too young to vote.\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>You are too young to vote.
</code></pre>
</blockquote>
<p>Play around a bit. Change the value of <code>age</code> and see what happens. Try to write your own conditions and branches.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="loops"><a class="header" href="#loops">Loops</a></h1>
<p>Programming often involves repeating tasks. For example, imagine printing every number from <code>1</code> to <code>10</code>. It’s tedious to write print 10 times! Loops automate such repetition. But what even <em>is</em> a loop? Lets start with the most simple form of a loop, the <code>while</code> loop.</p>
<h2 id="the-while-loop"><a class="header" href="#the-while-loop">The <code>while</code> Loop</a></h2>
<p>The while loop is actually the more simple loop you can have. The body of the loop (its scope) is executed as long as the condition of the while loop evaluates to <code>true</code>. But be cautious, you can create <strong>infinite loops</strong> relatively easily with a <code>while</code> loop. Here is a simple example of a while loop in action:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32 num = 0;
    while num &lt; 5:
        print($"num = {num}\n");
        num++;
</code></pre>
<p>But wait! Whats this <code>num++</code>? The <code>++</code> is called an <strong>increment operator</strong> it literally just increments <code>num</code> by 1. So, <code>num++</code> is just a neat way to say <code>num += 1</code>, which is a neat way to say <code>num = num + 1</code>. The increment operator exists because its just so common to write incrementations in loops (and it looks nicer too).</p>
<p>The above program will print these lines to the console:</p>
<blockquote>
<pre><code>num = 0
num = 1
num = 2
num = 3
num = 4
</code></pre>
</blockquote>
<p>As you can see, the body of the while loop got executed <code>5</code> times. If you, for example, would forget the <code>num++</code> line, this while loop would turn into an infinite loop. Can you see why?</p>
<p>Its because the condition <code>num &lt; 5</code> will always stay <code>true</code> because <code>0 &lt; 5</code>. But the while loop is only one of the looping statements which exist in Flint, there are more.</p>
<h2 id="the-do-while-loop"><a class="header" href="#the-do-while-loop">The <code>do while</code> Loop</a></h2>
<div class="warning">
<p>The do while loop does not yet work in the compiler.</p>
<p>Do while loops do not work at the moment, as they just have not been implemented in the compiler yet. But they will work in future releases eventually.</p>
</div>
<p>The <code>do while</code> loop is actually very similar to the <code>while</code> loop. The expression of the <code>while</code> loop gets evaluated <em>before</em> the body of the loop is executed. It executes the body if the condition is true, and then jumps back to the condition and checks again and so on. In <code>do while</code> loops this is different. Here, the body is executed first and <em>then</em> the condition is checked. Similar to <code>while</code> loops, <code>do while</code> loops run as long as the condition evaluates to true. Here is a small example of a <code>do while</code> loop:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32 num = 0;
    do:
        print($"num = {num}\n");
        num++;
    while num &lt; 5;
</code></pre>
<p>This loop will have the same output as the <code>while</code> loop above. But try changing the initial value of <code>num</code> to something bigger or equal to <code>5</code>, for example setting it to <code>10</code>. Do you recognize a difference between the two loop types?</p>
<p>The <code>do while</code> loop actually always executes <strong>at least once</strong> while the <code>while</code> loop can actually skip its body entirely. Ensuring that a loop runs at least once is not as common as the "normal" while loop, but when you need it you will be greatful that it is supported, as emulating the same behaviour with "normal" while loops is pretty hard.</p>
<h2 id="the-for-loop"><a class="header" href="#the-for-loop">The <code>for</code> Loop</a></h2>
<p>A <code>for</code> loop is very interesting, and probably the loop type you will end up writing the most common in Flint. The important part of the <code>for</code> loop is, that it is composed of three main parts:</p>
<ul>
<li>The variable declaration statement</li>
<li>A condition (exactly how <code>while</code>'s condition works this condition is evaluated <em>before</em> the body runs)</li>
<li>A statement that will be executed at the end of each iteration</li>
</ul>
<p>But it is best shown how this will look:</p>
<pre><code class="language-rs">use Core.print

def main():
    for i32 i = 0; i &lt; 5; i++:
        print($"Iteration {i}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>Iteration 0
Iteration 1
Iteration 2
Iteration 3
Iteration 4
</code></pre>
</blockquote>
<p>If you look closely, its actually pretty much the same as with our while loop. Both <code>for</code> and <code>while</code> loops are actually interchangable from one another, meaning that one loop type can easily be converted to the other type. In our case, the <code>while</code> loop implementation of this very same loop would look like this:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32 i = 0;
    while i &lt; 5:
        print($"Iteration {i}\n");
        i++;
</code></pre>
<p>But there exists one rather big difference between <code>for</code> and <code>while</code> loops. While in the <code>while</code> loop, the variable <code>i</code> is now part of the main function's scope, for the <code>for</code> loop, this is not the case. The <code>i</code> variable is only contained <em>inside</em> the <code>for</code> loops scope. This is very important, because it is most common to use <code>i</code> for the <strong>i</strong>ncrementing variable of a loop:</p>
<pre><code class="language-rs">use Core.print

def main():
    for i32 i = 0; i &lt; 5; i++:
        print($"Loop 1, iteration: {i}\n");
    // 'i' cannot be used after the for loop

    // 'i' can be re-declared here, because 'i' was
    // never declared inside the main functions scope
    for u32 i = 0; i &lt; 4; i++:
        print($"Loop 2, iteration: {i}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>Loop 1, iteration: 0
Loop 1, iteration: 1
Loop 1, iteration: 2
Loop 1, iteration: 3
Loop 1, iteration: 4
Loop 2, iteration: 0
Loop 2, iteration: 1
Loop 2, iteration: 2
Loop 2, iteration: 3
</code></pre>
</blockquote>
<h2 id="remember"><a class="header" href="#remember">Remember</a></h2>
<p>The general rule of thumb is to use <code>for</code> loops when you know the bounds of your iteration (from number <code>X</code> to number <code>Y</code>, or <code>run 10 times</code>) and use <code>while</code> loops when the number of iterations of the loop is unknown to you. If you follow this rule of thumb you whould have very vew problems with loops.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<p>What is an enum? An enum essentially is just a number under the hood, but one with very interesting properties. It can be thought of as a <strong>tag</strong> which can only have one of a selected number of tags. Here is an example:</p>
<pre><code class="language-rs">use Core.print

enum MyEnum:
    TAG1, TAG2, TAG3;

def main():
    MyEnum my_enum = MyEnum.TAG1;

    if my_enum == MyEnum.TAG1:
        print("is TAG1\n");
    else if my_enum == MyEnum.TAG2:
        print("is TAG2\n");
    else if my_enum == MyEnum.TAG3:
        print("is TAG3\n");
    else:
        print("This code path is actually impossible to reach, no matter which value 'my_enum' has!\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<p>is TAG1</p>
</blockquote>
<p>As you can see, defining our own <code>enum</code> is very simple. We write the <code>enum</code> keyword followed by the name of the enum, similar how we define the name of data. As you can see, the name <code>MyEnum</code> is now a new user-defined type, which is the reason why a variable (<code>my_enum</code>) can be declared to be of type <code>MyEnum</code>. Then, we write a colon <code>:</code> to signify the "body" of the enum, where we define all the values the enum could have. And then, we define the tag names the enum could have. Each tag name has to be unique within the same enum, so we would not be allowed to define <code>TAG1</code> twice. Tags are comma-separated and Flint sees everything as a tag until it finds a semicolon <code>;</code>.</p>
<p>If you dont like the horizontal layout, you can also define an enum like so:</p>
<pre><code class="language-rs">enum MyEnum:
    TAG1, // Some description of TAG1
    TAG2, // Some description of TAG2
    TAG3; // Some description of TAG3
</code></pre>
<h2 id="comparing-enums"><a class="header" href="#comparing-enums">Comparing Enums</a></h2>
<p>Enums are considered equal if their type <em>and</em> their tag match. Here is an example of what this means:</p>
<pre><code class="language-rs">use Core.print

enum Enum1:
    TAG1, TAG2, TAG3;

enum Enum2:
    TAG1, TAG2, TAG3;

def main():
    Enum1 e1 = Enum1.TAG1;

    if e1 == Enum2.TAG1:
        print("is Enum2.TAG1!\n");
</code></pre>
<p>This program will print this error to the console:</p>
<blockquote>
<pre><code>Parse Error at main.ft:12:8
 -- Type mismatch of expression e1 == Enum2.TAG1
 -- Expected Enum1 but got Enum2
</code></pre>
</blockquote>
<div class="warning">
<p>The error message differs in the current version of the compiler.</p>
<p>The above error message is the message that <em>should</em> be displayed. But in its current form the compiler will produce this error message instead:</p>
<blockquote>
<pre><code>Parse Error at main.ft:1:1
 -- Type mismatch of expression EOF
 -- Expected Enum1 but got Enum2
</code></pre>
</blockquote>
<p>There is no information contained <em>where</em> the mismatch happened or <em>what</em> the expression the error happened in was. This will be fixed eventually, but requires some changes in unrelated areas of the compiler, so it might take a while for it to be fixed.</p>
</div>
<h2 id="enums-with-functions"><a class="header" href="#enums-with-functions">Enums with functions</a></h2>
<p>Enums are considered to be non-complex data types in Flint, even though they are user-defined. So, we can easily pass in enums to a function and return them from it:</p>
<pre><code class="language-rs">use Core.print

enum ComparisonResult:
    BIGGER, SMALLER, EQUAL;

def compare(i32 x, i32 y) -&gt; ComparisonResult:
    if x &gt; y:
        return ComparisonResult.BIGGER;
    else if y &lt; x:
        return ComparisonResult.SMALLER;
    else:
        return ComparisonResult.EQUAL;

def main():
    ComparisonResult result = compare(10, 5);
    if result == ComparisonResult.BIGGER:
        print("is bigger\n");
    else if result == ComparisonResult.SMALLER:
        print("is smaller\n");
    else if result == ComparisonResult.EQUAL:
        print("is equal\n");
    else:
        print("Impossible to reach code block\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>is bigger
</code></pre>
</blockquote>
<p>The above program is very useless, though, as it would be much more efficient to remove the enum entirely and just use the comparisons directly. But these examples are not always meant to be absolutely useful, they are there to get a point across. So, we can not only return enums from a function but also pass them to a function. Lets dive into a bit bigger example now.</p>
<pre><code class="language-rs">use Core.print

enum Operation:
    PLUS, MINUS, MULT, DIV;

data NumberContainer:
    i32 a;
    f32 b;
    u64 c;
    NumberContainer(a, b, c);

def apply_operation(mut NumberContainer container, Operation op, f32 value):
    if op == Operation.PLUS:
        container.(a, b, c) += (i32(value), value, u64(value));
    else if op == Operation.MINUS:
        container.(a, b, c) -= (i32(value), value, u64(value));
    else if op == Operation.MULT:
        container.(a, b, c) *= (i32(value), value, u64(value));
    else if op == Operation.DIV:
        container.(a, b, c) /= (i32(value), value, u64(value));

def main():
    NumberContainer container = NumberContainer(-10, 22.5, u64(889));
    print($"container.(a, b, c) = ({container.a}, {container.b}, {container.c})\n");

    apply_operation(container, Operation.PLUS, 3.4);
    print($"container.(a, b, c) = ({container.a}, {container.b}, {container.c})\n");

    apply_operation(container, Operation.MULT, 7.2);
    print($"container.(a, b, c) = ({container.a}, {container.b}, {container.c})\n");

    apply_operation(container, Operation.MINUS, 22.1);
    print($"container.(a, b, c) = ({container.a}, {container.b}, {container.c})\n");

    apply_operation(container, Operation.DIV, 6.9);
    print($"container.(a, b, c) = ({container.a}, {container.b}, {container.c})\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>container.(a, b, c) = (-10, 22.5, 889)
container.(a, b, c) = (-7, 25.9, 892)
container.(a, b, c) = (-49, 186.479996, 6244)
container.(a, b, c) = (-71, 164.37999, 6222)
container.(a, b, c) = (-11, 23.823187, 1037)
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="switch"><a class="header" href="#switch">Switch</a></h1>
<div class="warning">
<p>Switch statements and expressions do not work yet.</p>
<p>Switch statements are not yet implemented in the compiler, at all. You will get compile errors front and center if you try to use them.</p>
</div>
<h2 id="switch-statements"><a class="header" href="#switch-statements">Switch Statements</a></h2>
<p>Switch statements are actually pretty easy to understand once you grasped if chains. <code>switch</code> statements are primarily used for pattern-matching purposes or for cases where you have a limited selection of possible values, like with enums, where you only have the possibilities of each tag.</p>
<p>Let's actually re-write the same example from the previous example, but without the if chain we now use a switch statement:</p>
<pre><code class="language-rs">use Core.print

enum ComparisonResult:
    BIGGER, SMALLER, EQUAL;

def compare(i32 x, i32 y) -&gt; ComparisonResult:
    if x &gt; y:
        return ComparisonResult.BIGGER;
    else if y &lt; x:
        return ComparisonResult.SMALLER;
    else:
        return ComparisonResult.EQUAL;

def main():
    ComparisonResult result = compare(10, 5);
    switch result:
        ComparisonResult.BIGGER:
            print("is bigger\n");
        ComparisonResult.SMALLER:
            print("is smaller\n");
        ComparisonResult.EQUAL:
            print("is equal\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>is bigger
</code></pre>
</blockquote>
<p>If you know switch statements from other languages you may wonder "where are the <code>case</code> and the <code>break</code> keywords?". Flint does not have such keywords, at least in this context (<code>break</code> still exists for loops, just like <code>continue</code>). In most languages like C, switch statements undergo a default <strong>fallthrough</strong> and you must manually <strong>opt out</strong> of the fallthrough behaviour, which is extremely error prone. But if you dont know what <strong>fallthrough</strong> is, lets discuss this first.</p>
<h2 id="fallthrough"><a class="header" href="#fallthrough">Fallthrough</a></h2>
<p>Fallthrough is the act of executing multiple switch branches after another. We best look at this example from C:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

typedef enum { VAL1, VAL2, VAL3 } MyEnum;

int main() {
    MyEnum e = VAL1; // In C you dont need to write MyEnum.VAL1
    switch (e) {
        case VAL1:
            printf("is val1\n");
        case VAL2:
            printf("is val2\n");
        case VAL3:
            printf("is val3\n");
    }
}
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>is val1
is val2
is val3
</code></pre>
</blockquote>
<p>And now you might think...what? Why does this happen? This is <strong>fallthrough</strong> in action. The first case that got matched is actually the <code>case VAL1</code> line. Falltrough means that "the execution falls through (to the next branch)". So, after the <code>case VAL1</code> branch, the <code>case VAL2</code> branch got executed and the <code>case VAL3</code> branch afterwards. If we want the intuitively expected behaviour, where each branch is executed with no fallthrough, we would need to add the <code>break</code> keyword to <em>every</em> single branch:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

typedef enum { VAL1, VAL2, VAL3 } MyEnum;

int main() {
    MyEnum e = VAL1; // In C you dont need to write MyEnum.VAL1
    switch (e) {
        case VAL1:
            printf("is val1\n");
            break;
        case VAL2:
            printf("is val2\n");
            break;
        case VAL3:
            printf("is val3\n");
            break;
    }
}
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>is val1
</code></pre>
</blockquote>
<p>And this is the behaviour that Flint has by default. In Flint, falltrough is not opt-out but rather opt-in. We don't actually have a keyword for this but rather an annotation. Here is an example of it:</p>
<pre><code class="language-rs">use Core.print

enum MyEnum:
    VAL1, VAL2, VAL3;

def main():
    MyEnum e = MyEnum.VAL1;
    switch e:
        #fallthrough
        MyEnum.VAL1:
            print("is val1\n");
        MyEnum.VAL2:
            print("is val2\n");
        MyEnum.VAL3:
            print("is val3\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>is val1
is val2
</code></pre>
</blockquote>
<p>It actually is not clear yet if there will exist an explicit keyword for the fallthrough. We did not want to use the <code>continue</code> keyword for this purpose, because what happens if you have a switch statement within a for loop, would the for loop continue or would the switch branch fall through? Flint tries to avoid ambiguity at all cost at all places, so we are pretty careful with its design.</p>
<h2 id="switch-expressions"><a class="header" href="#switch-expressions">Switch Expressions</a></h2>
<p>A switch, however, can not only exist as a statement but as an expression too. Instead of executing an arbitrary block of code, each switch branch needs to be an explicit expression now, marked with the arrow <code>-&gt;</code> syntax. Have a look:</p>
<pre><code class="language-rs">use Core.print

enum MyEnum:
    VAL1, VAL2, VAL3;

def main():
    MyEnum e = MyEnum.VAL1;
    i32 result = switch e:
        MyEnum.VAL1 -&gt; 1;
        MyEnum.VAL2 -&gt; 2;
        MyEnum.VAL3 -&gt; 4;
    print("result = {result}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>result = 1
</code></pre>
</blockquote>
<p>For switch expressions, there does not exist such thing as a fallthrough, because there are no code blocks executed but only single expressions. Yes, a literal like <code>1</code> is an expression too, but you could write function calls or even another nested switch expression on the place of that literal.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>In the previous chapter, we learned the control flow to control the flow of our program's execution in Flint through conditions, if statements and loops. Now that we have a solid foundation in the basics, let's talk about how to organize and reuse code in our programs. In this chapter, we will explore the fundamental concepts of functions in Flint.</p>
<h2 id="what-are-functions"><a class="header" href="#what-are-functions">What are Functions?</a></h2>
<p>A function is a reusable block of code that performs a specific task. Functions make programs easier to read, debug, and maintain by encapsulating logic into manageable pieces. Think of a function like a recipe. You can reuse it to "cook" something multiple times without rewriting the steps every single time. Similar to how loops have made our life simpler for repetition, functions make our life easier when we want to do a similar operation at multiple places in our code.</p>
<h2 id="why-are-functions-important"><a class="header" href="#why-are-functions-important">Why are Functions Important?</a></h2>
<p>Functions are essential in programming because they allow you to:</p>
<ul>
<li>Break down complex programs into smaller, more manageable pieces</li>
<li>Reuse code to avoid duplication and reduce errors</li>
<li>Write more modular and maintainable code</li>
</ul>
<p>In this chapter, we will learn about the basics of functions in Flint, including how to declare and call functions, how to pass arguments to functions, and how to return values from functions. We will also explore how to use functions to write more efficient and effective programs.</p>
<h2 id="what-to-expect-2"><a class="header" href="#what-to-expect-2">What to Expect</a></h2>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Declaring and calling functions</li>
<li>Passing arguments to functions</li>
<li>Returning values from functions</li>
<li>Function scope and lifetime</li>
<li>Best practices for working with functions</li>
</ul>
<p>By the end of this chapter, you will have a solid understanding of functions in Flint, and you will be able to use them to write more organized and reusable code. Let's get started!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="what-is-a-function"><a class="header" href="#what-is-a-function">What is a Function?</a></h1>
<p>A function is a reusable block of code designed to perform a specific task. We have been working this entire time with a function, actually, the <code>main</code> function. No, actually we have worked with multiple functions, because we also have called the <code>print</code> function <em>a lot</em> throughout the last few chapters. Now is the time you are going to understand what a function really is and how to define your own ones!</p>
<p>Okay, lets start very simple first. We define a function with the <code>def</code> keyword (define). Following by the <code>def</code> keyword we put the name of the function and parenthesis <code>()</code>. Note that the names <code>main</code>, <code>_main</code> and all names starting with <code>__flint_</code> are disallowed by the compiler. Without these few exceptions, you can name your functions how you like.</p>
<pre><code class="language-rs">use Core.print

def say_hello():
    print("Hello, World!\n");

def main():
    say_hello();
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>Hello, World!
</code></pre>
</blockquote>
<p>There is a <strong><em>very</em></strong> important note to make here. The ordering of definition does not matter in Flint. So, you can define a function like <code>say_hello</code> <em>after</em> the <code>main</code> function and still be able to use it within the main function:</p>
<pre><code class="language-rs">use Core.print

def main():
    say_hello();

def say_hello():
    print("Hello, World!\n");
</code></pre>
<p>This is an important part of how Flint works. The reasons to why this works like this are a bit more technical, but just note that ordering of definition does not matter in Flint, which will make your life a lot easier in the future, trust me.</p>
<p>While this function is cool, its not very useful yet because it will always only print the same message to the console. To make functions more useful we will need to add ways to pass data into and recieve data from functions. So, lets jump to the next chapter and discuss arguments.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="adding-parameters"><a class="header" href="#adding-parameters">Adding Parameters</a></h1>
<p>Parameters are "variables" of functions which you can change when calling the function, enabling the function to operate on different data, making them far more versatile and useful. Lets start with an example where we add a single parameter to a function:</p>
<pre><code class="language-rs">use Core.print

def greet(str name):
    print($"Hello, {name}!\n");

def main():
    greet("Alice");
    greet("Bob");
</code></pre>
<p>Its a pretty simple example, but you can clearly see that we insert the paramter <code>name</code> into the string interpolation when calling the <code>print</code> function. So, the above example will print these lines to the console:</p>
<blockquote>
<pre><code>Hello, Alice!
Hello, Bob!
</code></pre>
</blockquote>
<h2 id="multiple-parameters"><a class="header" href="#multiple-parameters">Multiple Parameters</a></h2>
<p>Functions can have multiple parameters. To declare multiple parameters, we separate them by commas, like this:</p>
<pre><code class="language-rs">use Core.print

def add_two_numbers(i32 a, i32 b):
    print($"The sum is {a + b}.\n");

def main():
    add_two_numbers(5, 7);
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>The sum is 12.
</code></pre>
</blockquote>
<h2 id="important-notes"><a class="header" href="#important-notes">Important Notes:</a></h2>
<ol>
<li>The <strong>type</strong> of each argument matters. For example, if <code>a</code> and <code>b</code> are declared as <code>i32</code>, you cannot pass values of any other type, like <code>f32</code> or <code>u32</code>.</li>
<li>The order of arguments also matters. Always pass values in the same order as declared in the function.</li>
</ol>
<p>There is an important difference between <code>parameters</code> and <code>arguments</code>, alltough this difference is only conceptual. When we define a function the "variables" that are defined, like <code>a</code> and <code>b</code> in our <code>add_two_numbers</code> function are called <strong>parameters</strong> of the function.</p>
<p>When we call a function and pass in values, like the values <code>5</code> and <code>7</code> for the call <code>add_two_numbers(5, 7)</code>, they are called <strong>arguments</strong> of the function call. This difference is important in later chapters, as they are not interchangably used by this wiki. So, if we talk about arguments we talk about <em>calls</em> and if we talk about parameters we talk about function <em>definitions</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="returning-values"><a class="header" href="#returning-values">Returning Values</a></h1>
<p>Imagine you want a function to calculate the area of a rectangle. It’s not enough to just print the result – you may need to use the value elsewhere in your program. This is where returning values is essential to any program. Here is a small and easy example of a function which returns a value:</p>
<pre><code class="language-rs">def get_greeting() -&gt; str:
    return "Hello, Flint!\n";
</code></pre>
<p>As you can see, you need to declare a return type after the <code>-&gt;</code> symbol in the function header. Also, if you want to return a value from within the function you need to use the <code>return</code> keyword followed by the value you want to return.</p>
<p>So, here is the full example:</p>
<pre><code class="language-rs">use Core.print

def get_greeting() -&gt; str:
    return "Hello, Flint!\n"

def main():
    str greeting = get_geeting();
    print(greeting);
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>Hello, Flint!
</code></pre>
</blockquote>
<h2 id="adding-parameters-and-returning-values"><a class="header" href="#adding-parameters-and-returning-values">Adding Parameters and Returning Values</a></h2>
<p>Now let’s combine function parameters with a return value:</p>
<pre><code class="language-rs">use Core.print

def add_two_numbers(i32 a, i32 b) -&gt; i32:
    return a + b;

def main():
    i32 result = add_two_numbers(10, 20);
    print($"The result is {result}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>The result is 30
</code></pre>
</blockquote>
<p>Okay, now that you know how to pass in arguments to a function and return values from the function lets move to the next chapter, <em>recursion</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="recursion"><a class="header" href="#recursion">Recursion</a></h1>
<p>First of all, what even is recursion? Recursion is the act of calling a function from within itself forming a "chain" of calls. Lets start with the most simple example of a recursive function, calculating a fibonacci number:</p>
<pre><code class="language-rs">use Core.print

def fib(i32 n) -&gt; i32:
    if n &lt;= 1:
        return n;
    else:
        return fib(n - 1) + fib(n - 2);

def main():
    for i := 0; i &lt; 10; i++:
        i32 fib_i = fib(i);
        print($"fib({i}) = {fib_i}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>fib(0) = 0
fib(1) = 1
fib(2) = 1
fib(3) = 2
fib(4) = 3
fib(5) = 5
fib(6) = 8
fib(7) = 13
fib(8) = 21
fib(9) = 34
</code></pre>
</blockquote>
<p>If you don't know what the fibonacci sequence is, you really should look into it, its beautiful. But, back to the recursive function, as there is a <em>lot</em> to unpack here. The loop itself is <strong>not</strong> part of the recursive function, only the content of the <code>fib</code> function make it recursive, because the function calls itself through the calls <code>fib(n - 1)</code> and <code>fib(n - 2)</code>.</p>
<p>To understand the function you must first understand the fibonacci sequence itself. Basically, every number is the sum of the last two numbers that came before it with the exceptions of <code>1</code> and <code>0</code> as they are just the number itself. This exception is handled in the recursive function through the <code>if</code> branch. So, <code>fib(2)</code> is the sum of the last two numbers, <code>0</code> and <code>1</code>, so its result is <code>1</code> and so on and so forth.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="returning-multiple-values"><a class="header" href="#returning-multiple-values">Returning Multiple Values</a></h1>
<p>Sometimes, a single return value isn’t enough. For instance, a function might need to calculate both the area and perimeter of a rectangle. Flint allows functions to return multiple values at once, without limiting the number of maximum returned values.</p>
<h2 id="how-to-return-multiple-values"><a class="header" href="#how-to-return-multiple-values">How to Return Multiple Values</a></h2>
<p>To return multiple values we use parentheses <code>()</code> to group multiple values in the return statement and also use parentheses for declaring the return types:</p>
<pre><code class="language-rs">def calculate_rectangle(i32 length, i32 width) -&gt; (i32, i32):
    i32 area = length * width;
    i32 perimeter = 2 * (length + width);
    return (area, perimeter);
</code></pre>
<p>As you can see, this function now returns a <code>group</code>. Groups are a special concept of Flint, but you will learn about them more in the next chapter. Its important that you separate the values you want to return with commas inside the parenthesis like shown above.</p>
<h2 id="accessing-multiple-return-values"><a class="header" href="#accessing-multiple-return-values">Accessing Multiple Return Values</a></h2>
<p>To recieve the values from a function which returns multiple values we also need to use a group to assign them.</p>
<pre><code class="language-rs">use Core.print

def calculate_rectangle(i32 length, i32 width) -&gt; (i32, i32):
    i32 area = length * width;
    i32 perimeter = 2 * (length + width);
    return (area, perimeter);

def main():
    (area, perimeter) := calculate_rectangle(5, 3);
    print($"Area: {area}, Perimeter: {perimeter}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>Area: 15, Perimeter: 16
</code></pre>
</blockquote>
<p>As you can see, we can declare two variables at once using inferred typing (<code>:=</code>) from the call <code>calculate_rectangle</code>. Both <code>area</code> and <code>perimeter</code> are of type <code>i32</code> now and then we can print their values.</p>
<h2 id="important-note"><a class="header" href="#important-note">Important Note</a></h2>
<p>The types and order of the group must match the function’s return type.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="groups"><a class="header" href="#groups">Groups</a></h1>
<p>What are groups? Groups are a new concept of Flint which allow us to do operations on multiple variables at the same time. You will see the potential and the integration of groups into other systems of Flint in later chapters, but even now groups are very powerful.</p>
<p>You have already seen groups in action when returning multiple values from a function, but that was just the beginning. Lets kick things off with a very simple example: variable swaps.</p>
<p>Lets define a simple small program which prints the values of two <code>i32</code> variables:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32 x = 1;
    i32 y = 5;
    print($"x = {x}, y = {y}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>x = 1, y = 5
</code></pre>
</blockquote>
<p>Okay, now lets say that we want to swap the values of <code>x</code> and <code>y</code>. With most languages, better said with almost every language, you would need to create a temporary value to swap values:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32 x = 1;
    i32 y = 5;
    print($"x = {x}, y = {y}\n");

    i32 temp = x;
    x = y;
    y = temp;
    print($"x = {x}, y = {y}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>x = 1, y = 5
x = 5, y = 1
</code></pre>
</blockquote>
<p>The temp variable exists because once we store the value of <code>y</code> into <code>x</code>, everything that was stored in <code>x</code> before is lost, so we need a way to keep track of the old value of <code>x</code> to be able to store it in <code>y</code>.</p>
<p>Okay, but now do groups help us with that? Have a look at the same example, but this time utilizing groups:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32 x = 1;
    i32 y = 5;
    print($"x = {x}, y = {y}\n");

    (x, y) = (y, x);
    print($"x = {x}, y = {y}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>x = 1, y = 5
x = 5, y = 1
</code></pre>
</blockquote>
<p>Okay, lets unpack what this group even says. We know that the right hand side of any assignment is always executed before assigning the value. So, we create a group and load the values of <code>y</code> and <code>x</code> into it. Note that a group does not create any temporary values or "store" the values anywhere. When we load <code>y</code> and <code>x</code> in the group <code>(y, x)</code> these values exist only in the cache of the CPU, they are not really stored annywhere else.</p>
<p>So then, when we assign <code>(y, x)</code> which holds the values <code>(5, 1)</code> to the group of <code>(x, y)</code> this is called a <strong>grouped assignment</strong> as we assign multiple values of multiple variables at the same time. So, we store the values of <code>(5, 1)</code> on the group <code>(x, y)</code> which means that we store <code>5</code> in <code>x</code> and <code>1</code> in <code>y</code>, swapping the values of the variables.</p>
<p>It is very important to note that groups have <strong>no</strong> runtime footprint, they exist in order for us to be able to "tell" the compiler that we want stuff to happen at the same time. But groups are not limited to only 2 values, we can have as many values in a group as we would like. Here an example:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32 a = 1;
    i32 b = 2;
    i32 c = 3;
    i32 d = 4;
    print($"a = {a}, b = {b}, c = {c}, d = {d}\n");

    (a, b, c, d) = (c, d, a, b);
    print($"a = {a}, b = {b}, c = {c}, d = {d}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>a = 1, b = 2, c = 3, d = 4
a = 3, b = 4, c = 1, d = 2
</code></pre>
</blockquote>
<p>So, we assigned <code>c</code> to <code>a</code>, <code>d</code> to <code>b</code>, <code>a</code> to <code>c</code> and <code>b</code> to <code>d</code>. Try around a bit, you can also assign all values to <code>a</code> in the same group:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32 a = 1;
    i32 b = 2;
    i32 c = 3;
    i32 d = 4;
    print($"a = {a}, b = {b}, c = {c}, d = {d}\n");

    (a, b, c, d) = (a, a, a, a);
    print($"a = {a}, b = {b}, c = {c}, d = {d}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>a = 1, b = 2, c = 3, d = 4
a = 1, b = 1, c = 1, d = 1
</code></pre>
</blockquote>
<p>Funny thing is, you can also assign to the same variable twice inside a single group, because the order of operation is strictly defined. So, you can write this without a problem:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32 a = 3;
    print($"a = {a}\n");

    (a, a, a) = (a + 1, a + 2, a + 3);
    print($"a = {a}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>a = 3
a = 6
</code></pre>
</blockquote>
<p>As you can see, this does not yield to an error...why? Because there is no reason why it should. The compiler should, however, print a warning describing the behaviour in this case. The right hand side of the grouped assignment is executed before any values are stored on the left, so first the group is evalueated to be <code>(4, 5, 6)</code> and then it is assigned to the group of <code>(a, a, a)</code>. Grouped assignments work from left to right, so we first assign <code>a</code> to be <code>4</code>, then to be <code>5</code> and finally to be <code>6</code>. The evaluation of a group is completely separate from the assignment of it, so this is a well-defined situation, and <code>a</code> will have its rightmost value from the group assigned to it.</p>
<p>But groups will become very important later on, and they will become more and more powerful regarding <code>data</code> and <code>SIMD</code>. If you know what this means, great. If not, don't worry, as all of these concepts will be explained in later chapters and <code>data</code> is actually the next chapter to follow!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="data"><a class="header" href="#data">Data</a></h1>
<p>Flint brings along a completely new paradigm called <strong>Data-Object Convergence Paradigm (DOCP)</strong>. What this paradigm means and what it brings to the table will be discussed thoroughly in later chapters, but <code>data</code> is very important for it. Unlike other paradigms like OOP (Object-Oriented Programming) you cannot attach functions to data. In Flint, data is exactly just that: data. Nothing more, nothing less.</p>
<p>Data is used to "pack" values together and to make them reusable, just like functions made instructions and operations reusable, <code>data</code> modules make working with similar data much simpler.</p>
<p>But lets not focus on the theory so much but dive into declaring and using data right away.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="declaring-data-modules"><a class="header" href="#declaring-data-modules">Declaring Data Modules</a></h1>
<p>To define a new <code>data</code> module in Flint, we use the <code>data</code> keyword. A <code>data</code> module consists of <strong>fields</strong> (the pieces of information it holds) and a constructor (in which order to initialize those fields).</p>
<h2 id="basic-syntax"><a class="header" href="#basic-syntax">Basic Syntax:</a></h2>
<pre><code class="language-rs">data Vector2:
    i32 x;
    i32 y;
    Vector2(x, y);
</code></pre>
<p>As you can see, we start with the <code>data</code> keyword, followed with the name of our data module, in this case <code>Vector2</code>. Then, we start by defining the <strong>fields</strong> of the data one by one. At the end of the definition we write the <strong>Constructor</strong> of the data, which specifies in which order we need to pass in the field values when creating the data module. This might seem weird for now, but keep going, things will become more clear as we go.</p>
<p>The important thing to note is that we now have a new type at our disposal: <code>Vector2</code>. Defining data modules creates new types, so you now can create variables of type <code>Vector2</code>, just like we did before with <code>i32</code>. Here is a small example:</p>
<pre><code class="language-rs">data Vector2:
    i32 x;
    i32 y;
    Vector2(x, y);

def main():
    Vector2 v2 = Vector2(10, 20);
</code></pre>
<p>As you can see, the variable <code>v2</code> now is of type <code>Vector2</code> and we create it by calling the constructor of the data type with <code>Vector2(10, 20)</code>. This constructor sets <code>x</code> to <code>10</code> and <code>y</code> to <code>20</code>. But when we try to run this program we cannot see anything in the console, we need a way to print the values the data fields have.</p>
<h2 id="field-access"><a class="header" href="#field-access">Field Access</a></h2>
<p>When we want to access a field of our data variable, for example the <code>x</code> field of our <code>v2</code> varaible we need to do so through a <strong>field access</strong>. There exists a symbol for this very use case: The <code>.</code> (dot). It's best if you just look at the example for yourself:</p>
<pre><code class="language-rs">use Core.print

data Vector2:
    i32 x;
    i32 y;
    Vector2(x, y);

def main():
    Vector2 v2 = Vector2(10, 20);
    print($"v2.x = {v2.x}, v2.y = {v2.y}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>v2.x = 10, v2.y = 20
</code></pre>
</blockquote>
<p>As you can see, the variable of type <code>Vector2</code> now contains two fields of type <code>i32</code>, <code>x</code> and <code>y</code> and we can access and modify themthrough the <code>.</code> access.</p>
<h2 id="field-assignment"><a class="header" href="#field-assignment">Field Assignment</a></h2>
<p>In the next example we will store a new value only on the <code>x</code> field of data:</p>
<pre><code class="language-rs">use Core.print

data Vector2:
    i32 x;
    i32 y;
    Vector2(x, y);

def main():
    Vector2 v2 = Vector2(10, 20);
    print($"v2.x = {v2.x}, v2.y = {v2.y}\n");
    v2.x = 15;
    print($"v2.x = {v2.x}, v2.y = {v2.y}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>v2.x = 10, v2.y = 20
v2.x = 15, v2.y = 20
</code></pre>
</blockquote>
<p>As you can see, we can only modify a single field of data without touching the other fields. But thats not all... now let's talk about how groups can make our life with data easier.</p>
<h2 id="grouped-field-access"><a class="header" href="#grouped-field-access">Grouped Field Access</a></h2>
<p>You already know what a group is, but groups can also be extremely powerful for data manipulation. Grouped field accesses are a new concept of Flint, together with groups. The idea is simple: Access and modify multiple fields of data at the same time. Here is a small example showcasing it:</p>
<pre><code class="language-rs">use Core.print

data Vector3:
    f32 x;
    f32 y;
    f32 z;
    Vector3(x, y, z);

def main():
    Vector3 v3 = Vector3(1.0, 2.0, 3.0);
    (x, y, z) := v3.(x, y, z);
    print($"(x, y, z) = ({x}, {y}, {z})\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>(x, y, z) = (1, 2, 3)
</code></pre>
</blockquote>
<p>The syntax is pretty easy, actually. First, we say the variable we want to access the fields in: <code>v3.</code> and then we open a left paren <code>(</code> and within the parenthesis we describe the <em>names</em> of the fields we want to access and we wrap it up with the closing paren <code>)</code>. You could see that this line: <code>v3.(x, y, z)</code> is actually the same as writing this: <code>(v3.x, v3.y, v3.z)</code> but it's much neater to look at and to write. Why should we write <code>v3.</code> three times when we only want to access multiple fields of it?</p>
<h2 id="grouped-field-assignment"><a class="header" href="#grouped-field-assignment">Grouped Field Assignment</a></h2>
<p>Just like we can access mutliple fields of data at once, we can also assign multiple values of it at the same time. Here is an example of that:</p>
<pre><code class="language-rs">use Core.print

data Vector3:
    f32 x;
    f32 y;
    f32 z;
    Vector3(x, y, z);

def main():
    Vector3 v3 = Vector3(1.0, 2.0, 3.0);
    print($"v3.(x, y, z) = ({v3.x}, {v3.y}, {v3.z})\n");
    v3.(x, y, z) = v3.(z, x, y);
    print($"v3.(x, y, z) = ({v3.x}, {v3.y}, {v3.z})\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>v3.(x, y, z) = (1, 2, 3)
v3.(x, y, z) = (3, 1, 2)
</code></pre>
</blockquote>
<p>As you can see, we did the same thing as we did for variable swaps, but now on data fields. This is only possible through the concoept of groups. A very important thing is that groups themselves have a type. If you would write out the type of the access <code>v3.(x, y, z)</code> it would look like this: <code>(f32, f32, f32)</code>. As you can see, this looks exactly like the return type of a function when we would return multiple values, enforcing the connection that a function returning multiple values returns a group of values.</p>
<p>But swaps are not all we can do, we can for example calculate multiple values at once, for example incrementing all fields of the vector <code>v3</code> by one:</p>
<pre><code class="language-rs">use Core.print

data Vector3:
    f32 x;
    f32 y;
    f32 z;
    Vector3(x, y, z);

def main():
    Vector3 v3 = Vector3(1.0, 2.0, 3.0);
    print($"v3.(x, y, z) = ({v3.x}, {v3.y}, {v3.z})\n");

    v3.(x, y, z) += (1.0, 1.0, 1.0);
    print($"v3.(x, y, z) = ({v3.x}, {v3.y}, {v3.z})\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>v3.(x, y, z) = (1, 2, 3)
v3.(x, y, z) = (2, 3, 4)
</code></pre>
</blockquote>
<p>As you can clearly see, all fields of the variable <code>v3</code> have been incremented by one. By combining data with groups you can create very powerful and still compact code.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="default-values"><a class="header" href="#default-values">Default Values</a></h1>
<div class="warning">
<p>Default values do not work yet.</p>
<p>While default values are able to be parsed in the data definition itself, the constructor of data cannot be called with the <code>_</code> operator to create a default instance of the type.</p>
</div>
<p>Sometimes, you may want a field to have a <strong>default value</strong>. In Flint, this is done by assigning a value to the field directly in its declaration.</p>
<pre><code class="language-rs">data MyData:
    i32 x = 5;
    i32 y;
    MyData(x, y);
</code></pre>
<p>When instantiating this data module, you can use <code>_</code> to signify using the default value for a field. The <code>_</code> operator is <strong>only</strong> used in <em>unused</em> or <em>default</em> contexts, nowhere else. So, if you see a single <code>_</code> in Flint you can <strong>always</strong> assume that either something is unused or set to a default.</p>
<pre><code class="language-rs">use Core.print

data MyData:
    i32 x = 5;
    i32 y;
    MyData(x, y);

def main():
    MyData d = MyData(_, 20); // x uses the default value of 5
    print($"d.x = {d.x}, d.y = {d.y}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>d.(x, y) = (5, 20)
</code></pre>
</blockquote>
<p>If <strong>all</strong> fields of a given data type have default values set the constructor of the data type can be called with a single <code>_</code> operator to singify to <strong>set every field to its default value</strong>. But, note that this only works if <strong>every</strong> field in the given data type has a default value set. If one of them has no default value set this will fail.</p>
<pre><code class="language-rs">use Core.print

data MyData:
    i32 x = 5;
    i32 y = 7;
    MyData(x, y);

def main():
    MyData d = MyData(_);
    print($"d.(x, y) = ({d.x}, {d.y})\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>d.(x, y) = (5, 7)
</code></pre>
</blockquote>
<ol>
<li>Default values simplify initialization but are optional.</li>
<li>If a field doesn’t have a default value, using <code>_</code> will result in a <strong>compiler error</strong></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="nested-data"><a class="header" href="#nested-data">Nested Data</a></h1>
<p>Data modules can include other data modules as fields. This allows you to create nested structures, which are common in real-world programming. Here is an example of this concept in action:</p>
<pre><code class="language-rs">use Core.print

data Point:
    i32 x;
    i32 y;
    Point(x, y);

data Rectangle:
    Point top_left;
    Point bottom_right;
    Rectangle(top_left, bottom_right);

def main():
    Point p1 = Point(0, 0);
    Point p2 = Point(10, 10);
    Rectangle rect = Rectangle(p1, p2);
    print($"rect.top_left.(x, y) = ({rect.top_left.x}, {rect.top_left.y})\n");
    print($"rect.bottom_right.(x, y) = ({rect.bottom_right.x}, {rect.bottom_right.y})\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>rect.top_left.(x, y) = (0, 0)
rect.bottom_right.(x, y) = (10, 10)
</code></pre>
</blockquote>
<p>Note that storing the <code>Point</code> variables in the <code>rect</code> variable through its constructor creates <em>copies</em> of the points. In other languages this would need to be done manually, but in Flint its automatic. So, when changing <code>p1</code> and <code>p2</code> after the creation of <code>rect</code>, the <code>top_left</code> and <code>bottom_right</code> fields will not be changed:</p>
<pre><code class="language-rs">use Core.print

data Point:
    i32 x;
    i32 y;
    Point(x, y);

data Rectangle:
    Point top_left;
    Point bottom_right;
    Rectangle(top_left, bottom_right);

def main():
    Point p1 = Point(0, 0);
    Point p2 = Point(10, 10);
    Rectangle rect = Rectangle(p1, p2);

    print($"p1.(x, y) = ({p1.x}, {p1.y})\n");
    print($"p2.(x, y) = ({p2.x}, {p2.y})\n");
    print($"rect.top_left.(x, y) = ({rect.top_left.x}, {rect.top_left.y})\n");
    print($"rect.bottom_right.(x, y) = ({rect.bottom_right.x}, {rect.bottom_right.y})\n");

    print("\n");
    p1.(x, y) = (4, 5);
    p2.(x, y) = (22, 33);

    print($"p1.(x, y) = ({p1.x}, {p1.y})\n");
    print($"p2.(x, y) = ({p2.x}, {p2.y})\n");
    print($"rect.top_left.(x, y) = ({rect.top_left.x}, {rect.top_left.y})\n");
    print($"rect.bottom_right.(x, y) = ({rect.bottom_right.x}, {rect.bottom_right.y})\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>p1.(x, y) = (0, 0)
p2.(x, y) = (10, 10)
rect.top_left.(x, y) = (0, 0)
rect.bottom_right.(x, y) = (10, 10)

p1.(x, y) = (4, 5)
p2.(x, y) = (22, 33)
rect.top_left.(x, y) = (0, 0)
rect.bottom_right.(x, y) = (10, 10)
</code></pre>
</blockquote>
<h2 id="what-about-circular-references"><a class="header" href="#what-about-circular-references">What about Circular References?</a></h2>
<div class="warning">
<p>The below example actually compiles, but its impossible to run.</p>
<p>Data is actually allowed to contain itself, but its impossible to initialize, as Flint has noo concept of <strong>nullpointers</strong> or <strong>null</strong> like other languages have. Flint has its optionals <code>Opt&lt;T&gt;</code> instead, but they are not implemented yet. Its amusing how the below example actually compiles fine.</p>
</div>
<p>Flint does not allow a data module to reference itself directly or indirectly like showcased below:</p>
<pre><code class="language-rs">data Node:
    i32 value;
    Node next;
    Node(value, next);
</code></pre>
<p>While this may seem restrictive, it is pretty easy explained why this does not work: If you try to initialize a new variable of type <code>Node</code> you need to provide both its fields for the initializer. The <code>value</code> is fine, you can just pass in a literal, but what about the second field, <code>next</code>? To create a new variable of type <code>Node</code> you need an already existent variable of the same type to pass into, and thats impossible.</p>
<h2 id="hint"><a class="header" href="#hint">Hint:</a></h2>
<p>Flint can handle circular references with the help of the <strong>optional type (<code>Opt</code>)</strong>. These convert a reference to a wek reference in circular context's, thus enabling the use of data in of itself, for example for <strong>linked lists</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="using-data-in-functions"><a class="header" href="#using-data-in-functions">Using Data in Functions</a></h1>
<p>Data modules can be passed to and returned from functions, enabling you to manipulate them easily.</p>
<pre><code class="language-rs">use Core.print

data Point:
    i32 x;
    i32 y;
    Point(x, y);

def print_point(Point p):
    print($"Point(x: {p.x}, y: {p.y})\n");

def main():
    Point p = Point(3, 4);
    print_point(p);
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>Point(x: 3, y: 4)
</code></pre>
</blockquote>
<h2 id="mutability-and-immutability"><a class="header" href="#mutability-and-immutability">Mutability and Immutability</a></h2>
<p>Okay, but what if we want to modify the point in a function? Lets look at an example:</p>
<pre><code class="language-rs">use Core.print

data Point:
    i32 x;
    i32 y;
    Point(x, y);

def increment_by(Point p, i32 value):
    p.(x, y) += (value, value);

def main():
    Point p = Point(3, 4);
    increment_by(p, 3);
    print($"Point(x: {p.x}, y: {p.y})\n");
</code></pre>
<p>If you try to compile this program you will actually get a compile error:</p>
<blockquote>
<pre><code>Parse Error at main.ft:9:5
 -- Variable 'p' is marked as 'const' and cannot be modified!
</code></pre>
</blockquote>
<p>But why is that? For this to explain we actually need to talk about <strong>mutability</strong> for a bit. Mutability is the ability to mutate (change) variables. Up until now this has not been a problem yet, because Flint actually has clear mutability rules:</p>
<ul>
<li>Local variables declared within a scope are always <strong>mutable</strong> except explicitely made immutable</li>
<li>Function parameters are always <strong>immutable</strong> except explicitely made mutable</li>
</ul>
<p>Flint has two keywords for this very reason: <code>mut</code> and <code>const</code>. You can use <code>const</code> when declaring a variable in a scope to make the variable constant, thus not-changable after its declaration and you can use <code>mut</code> to make parameters of functions explicitely mutable. Note that putting <code>const</code> in front of a function parameter has no effect, as its const annyway, same as putting <code>mut</code> in front of a variable declaration, as variables are mutable annyway.</p>
<p>So, to fix our little compile error we need to change the signature of our function a bit:</p>
<pre><code class="language-rs">use Core.print

data Point:
    i32 x;
    i32 y;
    Point(x, y);

def increment_by(mut Point p, i32 value):
    p.(x, y) += (value, value);

def main():
    Point p = Point(3, 4);
    increment_by(p, 3);
    print($"Point(x: {p.x}, y: {p.y})\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>Point(x: 6, y: 7)
</code></pre>
</blockquote>
<p>As you can see, the functions signature of the <code>increment_by</code> function now explicitely states that its parameter is a mutable one. This means that we can only pass in mutable <code>Point</code> variables to it when calling it. So, this example:</p>
<pre><code class="language-rs">use Core.print

data Point:
    i32 x;
    i32 y;
    Point(x, y);

def increment_by(mut Point p, i32 value):
    p.(x, y) += (value, value);

def main():
    const Point p = Point(3, 4);
    increment_by(p, 3);
    print($"Point(x: {p.x}, y: {p.y})\n");
</code></pre>
<p>will not compile again. Because now we have declared <code>p</code> to be immutable, but we try to pass it to to the call <code>increment_by</code> which expects a mutable <code>Point</code> argument, so we have a type mismatch here, because when we made <code>p</code> immutable it would be wrong if it could be modified by a function. We get this compile error:</p>
<blockquote>
<pre><code>Parse Error at main.ft:13:18
 -- Variable 'p' is marked as 'const' and cannot be modified!
</code></pre>
</blockquote>
<h2 id="returning-data-from-functions"><a class="header" href="#returning-data-from-functions">Returning Data from Functions</a></h2>
<div class="warning">
<p>Returning data variables from functions does not wory yet.</p>
<p>The error lies somewhere hidden in the codebase, but its a nontrivial fix so i just did not bother for now. So, you will need to pass mutable references to functions for now, but thats fine in my view.</p>
</div>
<p>You can also return data from functions, for example when creating them inside the function.</p>
<pre><code class="language-rs">use Core.print

data Point:
    i32 x;
    i32 y;
    Point(x, y);

def create_point(i32 x, i32 y) -&gt; Point:
    return Point(x, y);

def main():
    Point p = create_point(5, 7);
    print($"Point(x: {p.x}, y: {p.y})\n");
</code></pre>
<p>By using functions with data, you can create and manipulate complex structures easily.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="tuples"><a class="header" href="#tuples">Tuples</a></h1>
<p>Tuples are a really nice concept in general and they exist in pretty much every language. But first, lets talk about what tuples even are and maybe take a closer look at <code>data</code> in general.
In Flint, <code>data</code> is essentially just a <code>struct</code> from C, if you have seen that one before. So when we write</p>
<pre><code class="language-rs">data Vector2:
    i32 x;
    i32 y;
    Vector2(x, y);
</code></pre>
<p>we could do something similar in C which would look like this:</p>
<pre><code class="language-c">typedef struct {
    int x;
    int y;
} Vector2;
</code></pre>
<p>Under the hood, both Flint's <code>data</code> module and C's <code>struct</code> are exactly the same. They are just collections of data packed into a struct. So, what are tuples then? Well, tuples are collections of data, packed into a struct too. But with one big difference: They are <strong>anonymous</strong>, meaning that they dont get a <em>type name</em>, but when looking at the lowest level, <code>data</code> and tuples are actually extremely similar.</p>
<h2 id="defining-tuples"><a class="header" href="#defining-tuples">Defining Tuples</a></h2>
<p>Because tuples are anonymous they are not defined like data modules are. They are rather defined inline, like a variable, for example. So here is the basic syntax to define a tuple in Flint:</p>
<pre><code class="language-rs">def main():
    data&lt;i32, f32, str&gt; tuple = (3, 2.2, "hello!");
</code></pre>
<p>Do you recognize the <code>data</code> keyword? This is the reason i told you earlier that tuples and data are actually pretty much the same thing, but one is named while the other one is not. This connection and the understanding of it is crucial to understand tuples, because otherwise you now would be really confused by the syntax: "Wait, what does the <code>data</code> keyword have to do with tuples here?".</p>
<p>And here we have another very nice property of Flint's groups – they enable seemless interoperability between different types! As you can see, the "initializer" for a tuple is actually a group with the same types as the tuple itself. So, the "initializer" of a tuple could also be a grouped field access (d.(a, b, c)` or a group from multiple variables or anything else you can do with groups. As you can see, groups form a whole layer of making syntax easier for a lot of systems.</p>
<h2 id="tuple-access"><a class="header" href="#tuple-access">Tuple Access</a></h2>
<p>But what about assigning and accessing the specific fields of a tuple? With <code>data</code> modules, we can access the fields directly by the name of the field (<code>v2.x</code>) but tuples are anonymous, meaning that neither the type itself has a name, nor do the fields.</p>
<p>In Flint, we access the fields of a tuple by its "index". The first field of the tuple above is of type <code>i32</code>, the second of type <code>f32</code> and the third of type <code>str</code>, so we can use the fixed ordering as our accessing syntax right away. But we cannot do <code>tuple.0</code>, <code>tuple.1</code> etc directly because that would look pretty weird to have an integer literal directly. Here is an example of how to access the single values of a tuple in Flint:</p>
<pre><code class="language-rs">use Core.print

def main():
    data&lt;i32, f32, str&gt; tuple = (3, 2.2, "hello!");

    i32 first = tuple.$0;
    f32 second = tuple.$1;
    str third = tuple.$2;

    print($"first = {first}\n");
    print($"second = {second}\n");
    print($"third = \"{third}\"\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>first = 3
second = 2.2
third = hello!
</code></pre>
</blockquote>
<p>As you can clearly see, we access the elements of the tuple with the <code>.&lt;span class="katex"&gt;&lt;span class="katex-html" aria-hidden="true"&gt;&lt;span class="base"&gt;&lt;span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"&gt;&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.10903em;"&gt;N&lt;/span&gt;&lt;span class="mord"&gt;‘&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.03588em;"&gt;sy&lt;/span&gt;&lt;span class="mord mathnormal"&gt;n&lt;/span&gt;&lt;span class="mord mathnormal"&gt;t&lt;/span&gt;&lt;span class="mord mathnormal"&gt;a&lt;/span&gt;&lt;span class="mord mathnormal"&gt;x&lt;/span&gt;&lt;span class="mpunct"&gt;,&lt;/span&gt;&lt;span class="mspace" style="margin-right:0.1667em;"&gt;&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.02691em;"&gt;w&lt;/span&gt;&lt;span class="mord mathnormal"&gt;h&lt;/span&gt;&lt;span class="mord mathnormal"&gt;ere&lt;/span&gt;&lt;span class="mord"&gt;‘&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.10903em;"&gt;N&lt;/span&gt;&lt;span class="mord"&gt;‘&lt;/span&gt;&lt;span class="mord mathnormal"&gt;i&lt;/span&gt;&lt;span class="mord mathnormal"&gt;s&lt;/span&gt;&lt;span class="mord mathnormal"&gt;t&lt;/span&gt;&lt;span class="mord mathnormal"&gt;h&lt;/span&gt;&lt;span class="mord mathnormal"&gt;e&lt;/span&gt;&lt;span class="mord mathnormal"&gt;in&lt;/span&gt;&lt;span class="mord mathnormal"&gt;d&lt;/span&gt;&lt;span class="mord mathnormal"&gt;e&lt;/span&gt;&lt;span class="mord mathnormal"&gt;x&lt;/span&gt;&lt;span class="mord mathnormal"&gt;o&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.10764em;"&gt;f&lt;/span&gt;&lt;span class="mord mathnormal"&gt;t&lt;/span&gt;&lt;span class="mord mathnormal"&gt;h&lt;/span&gt;&lt;span class="mord mathnormal"&gt;ee&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.01968em;"&gt;l&lt;/span&gt;&lt;span class="mord mathnormal"&gt;e&lt;/span&gt;&lt;span class="mord mathnormal"&gt;m&lt;/span&gt;&lt;span class="mord mathnormal"&gt;e&lt;/span&gt;&lt;span class="mord mathnormal"&gt;n&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.02691em;"&gt;tw&lt;/span&gt;&lt;span class="mord mathnormal"&gt;e&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.02691em;"&gt;w&lt;/span&gt;&lt;span class="mord mathnormal"&gt;an&lt;/span&gt;&lt;span class="mord mathnormal"&gt;tt&lt;/span&gt;&lt;span class="mord mathnormal"&gt;o&lt;/span&gt;&lt;span class="mord mathnormal"&gt;a&lt;/span&gt;&lt;span class="mord mathnormal"&gt;ccess&lt;/span&gt;&lt;span class="mord"&gt;.&lt;/span&gt;&lt;span class="mord mathnormal"&gt;L&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.03148em;"&gt;ik&lt;/span&gt;&lt;span class="mord mathnormal"&gt;e&lt;/span&gt;&lt;span class="mord mathnormal"&gt;a&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.02691em;"&gt;lw&lt;/span&gt;&lt;span class="mord mathnormal"&gt;a&lt;/span&gt;&lt;span class="mord mathnormal"&gt;ys&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.10764em;"&gt;f&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.02778em;"&gt;or&lt;/span&gt;&lt;span class="mord mathnormal"&gt;in&lt;/span&gt;&lt;span class="mord mathnormal"&gt;d&lt;/span&gt;&lt;span class="mord mathnormal"&gt;i&lt;/span&gt;&lt;span class="mord mathnormal"&gt;ces&lt;/span&gt;&lt;span class="mpunct"&gt;,&lt;/span&gt;&lt;span class="mspace" style="margin-right:0.1667em;"&gt;&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.02691em;"&gt;w&lt;/span&gt;&lt;span class="mord mathnormal"&gt;es&lt;/span&gt;&lt;span class="mord mathnormal"&gt;t&lt;/span&gt;&lt;span class="mord mathnormal"&gt;a&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.02778em;"&gt;r&lt;/span&gt;&lt;span class="mord mathnormal"&gt;t&lt;/span&gt;&lt;span class="mord mathnormal"&gt;a&lt;/span&gt;&lt;span class="mord mathnormal"&gt;t&lt;/span&gt;&lt;span class="mord"&gt;0&lt;/span&gt;&lt;span class="mord mathnormal"&gt;a&lt;/span&gt;&lt;span class="mord mathnormal"&gt;s&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.01968em;"&gt;Fl&lt;/span&gt;&lt;span class="mord mathnormal"&gt;in&lt;/span&gt;&lt;span class="mord mathnormal"&gt;t&lt;/span&gt;&lt;span class="mord mathnormal"&gt;ha&lt;/span&gt;&lt;span class="mord mathnormal"&gt;szero&lt;/span&gt;&lt;span class="mspace" style="margin-right:0.2222em;"&gt;&lt;/span&gt;&lt;span class="mbin"&gt;−&lt;/span&gt;&lt;span class="mspace" style="margin-right:0.2222em;"&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="base"&gt;&lt;span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"&gt;&lt;/span&gt;&lt;span class="mord mathnormal"&gt;ba&lt;/span&gt;&lt;span class="mord mathnormal"&gt;se&lt;/span&gt;&lt;span class="mord mathnormal"&gt;d&lt;/span&gt;&lt;span class="mord mathnormal"&gt;in&lt;/span&gt;&lt;span class="mord mathnormal"&gt;d&lt;/span&gt;&lt;span class="mord mathnormal"&gt;e&lt;/span&gt;&lt;span class="mord mathnormal"&gt;x&lt;/span&gt;&lt;span class="mord mathnormal"&gt;in&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.03588em;"&gt;g&lt;/span&gt;&lt;span class="mord"&gt;.&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.07847em;"&gt;I&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.10764em;"&gt;f&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.02691em;"&gt;w&lt;/span&gt;&lt;span class="mord mathnormal"&gt;e&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.02691em;"&gt;w&lt;/span&gt;&lt;span class="mord mathnormal"&gt;o&lt;/span&gt;&lt;span class="mord mathnormal"&gt;u&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.01968em;"&gt;l&lt;/span&gt;&lt;span class="mord mathnormal"&gt;d&lt;/span&gt;&lt;span class="mord mathnormal"&gt;t&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.03588em;"&gt;ry&lt;/span&gt;&lt;span class="mord mathnormal"&gt;t&lt;/span&gt;&lt;span class="mord mathnormal"&gt;o&lt;/span&gt;&lt;span class="mord mathnormal"&gt;a&lt;/span&gt;&lt;span class="mord mathnormal"&gt;ccess&lt;/span&gt;&lt;span class="mord mathnormal"&gt;an&lt;/span&gt;&lt;span class="mord mathnormal"&gt;e&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.01968em;"&gt;l&lt;/span&gt;&lt;span class="mord mathnormal"&gt;e&lt;/span&gt;&lt;span class="mord mathnormal"&gt;m&lt;/span&gt;&lt;span class="mord mathnormal"&gt;e&lt;/span&gt;&lt;span class="mord mathnormal"&gt;n&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.02691em;"&gt;tw&lt;/span&gt;&lt;span class="mord mathnormal"&gt;hi&lt;/span&gt;&lt;span class="mord mathnormal"&gt;c&lt;/span&gt;&lt;span class="mord mathnormal"&gt;hi&lt;/span&gt;&lt;span class="mord mathnormal"&gt;so&lt;/span&gt;&lt;span class="mord mathnormal"&gt;u&lt;/span&gt;&lt;span class="mord mathnormal"&gt;t&lt;/span&gt;&lt;span class="mord mathnormal"&gt;o&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.10764em;"&gt;f&lt;/span&gt;&lt;span class="mord mathnormal"&gt;b&lt;/span&gt;&lt;span class="mord mathnormal"&gt;o&lt;/span&gt;&lt;span class="mord mathnormal"&gt;u&lt;/span&gt;&lt;span class="mord mathnormal"&gt;n&lt;/span&gt;&lt;span class="mord mathnormal"&gt;d&lt;/span&gt;&lt;span class="mord mathnormal"&gt;s&lt;/span&gt;&lt;span class="mpunct"&gt;,&lt;/span&gt;&lt;span class="mspace" style="margin-right:0.1667em;"&gt;&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.01968em;"&gt;l&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.03148em;"&gt;ik&lt;/span&gt;&lt;span class="mord mathnormal"&gt;e&lt;/span&gt;&lt;span class="mord"&gt;‘.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;3</code> in our case we would actually get a compile error:</p>
<pre><code class="language-rs">def main():
    data&lt;i32, f32, str&gt; tuple = (3, 2.2, "hello!");
    i32 = tuple.$3;
</code></pre>
<div class="warning">
<p>The error message for this error has not been added yet.</p>
<p>Currently the error is <code>Custom Error: 2</code> without giving <em>any</em> information what error it is.</p>
</div>
<h2 id="tuple-assignment"><a class="header" href="#tuple-assignment">Tuple Assignment</a></h2>
<p>Just like we can access elements from a tuple, we can also assign new values to the elements of a tuple. Here is a simple example of this in action:</p>
<pre><code class="language-rs">use Core.print

def main():
    data&lt;i32, f32, str&gt; tuple = (3, 2.2, "hello!");

    tuple.$0 = 7;
    tuple.$1 = 4.7;
    tuple.$2 = "yes";

    print($"first = {tuple.$0}\n");
    print($"second = {tuple.$1}\n");
    print($"third = \"{tuple.$2}\"\n");
</code></pre>
<p>This program prints these lines to the console:</p>
<blockquote>
<pre><code>first = 7
second = 4.7
third = "yes"
</code></pre>
</blockquote>
<h2 id="grouped-accesses-and-assignments"><a class="header" href="#grouped-accesses-and-assignments">Grouped accesses and assignments</a></h2>
<p>Just like with "normal" data you can do grouped field accesses and assignments with tuples too. Instead of the field names you need to write the field ids again:</p>
<pre><code class="language-rs">use Core.print

def main():
    data&lt;i32, f32, str&gt; tuple = (3, 2.2, "hello!");
    tuple.($0, $1, $2) = (7, 4.7, "yes");
    print($"tuple.($0, $1, $2) = ({tuple.$0}, {tuple.$1}, \"{tuple.$2}\")\n");
</code></pre>
<p>This program prints this line to the console:</p>
<blockquote>
<pre><code>tuple.($0, $1, $2) = (7, 4.7, "yes")
</code></pre>
</blockquote>
<h2 id="addition-information"><a class="header" href="#addition-information">Addition Information</a></h2>
<h3 id="multi-type-overlap"><a class="header" href="#multi-type-overlap">Multi-Type overlap</a></h3>
<p>Tuples are not allowed to be defined as a type that can be represented with a mutli-type instead. So, this example for example:</p>
<pre><code class="language-rs">use Core.print

def main():
    data&lt;i32, i32, i32&gt; tuple = (1, 1, 1);
    tuple.($0, $1, $2) = (2, 3, 4);
    print($"tuple.($0, $1, $2) = ({tuple.$0}, {tuple.$1}, {tuple.$2})\n");
</code></pre>
<p>will throw a compilation error and tell you to use a <code>i32x3</code> type instead of the <code>data&lt;i32, i32, i32&gt;</code> type.</p>
<div class="warning">
<p>The error message for this error has not been added yet.</p>
<p>Currently the error is <code>Custom Error: 2</code> without giving <em>any</em> information what error it is.</p>
</div>
<h3 id="returning-tuples"><a class="header" href="#returning-tuples">Returning Tuples</a></h3>
<p>It is not allowed to return a tuple from a function if its the only return type of said function. You need to return a group instead and this is compile-time enforced. The exact reason to why this is required will be clarified in the chapter aboout Flint's error handling. So, this code:</p>
<pre><code class="language-rs">use Core.print

def get_tuple(i32 a, f32 b, str c) -&gt; data&lt;i32, f32, str&gt;:
    data&lt;i32, f32, str&gt; tuple = (a, b, c);
    return tuple;

def main():
    data&lt;i32, f32, str&gt; tuple = get_tuple(1, 4.7, "hello");
    print($"tuple.($0, $1, $2) = ({tuple.$0}, {tuple.$1}, {tuple.$2})\n");
</code></pre>
<p>will produce a compile error telling you to use a group of type <code>(i32, f32, str)</code> instead as the return type of the function. Because you can do this:</p>
<pre><code class="language-rs">use Core.print

def get_tuple(i32 a, f32 b, str c) -&gt; (i32, f32, str):
    return (a, b, c);

def main():
    data&lt;i32, f32, str&gt; tuple = get_tuple(1, 4.7, "hello");
    print($"tuple.($0, $1, $2) = ({tuple.$0}, {tuple.$1}, {tuple.$2})\n");
</code></pre>
<p>annyway. This program will print this line to the console:</p>
<blockquote>
<pre><code>tuple.($0, $1, $2) = (1, 4.7, hello)
</code></pre>
</blockquote>
<h3 id="passing-tuples-to-functions"><a class="header" href="#passing-tuples-to-functions">Passing Tuples to functions</a></h3>
<p>Tuples can also be passed to functions as any value can:</p>
<pre><code class="language-rs">use Core.print

def print_tuple(data&lt;i32, f32, str&gt; tuple):
    print($"tuple.(i32, f32, str) = ({tuple.$0}, {tuple.$1}, \"{tuple.$2}\")\n");

def main():
    data&lt;i32, f32, str&gt; tuple = (1, 2.2, "three");
    print_tuple(tuple);
</code></pre>
<p>This program will print this message to the console:</p>
<blockquote>
<pre><code>tuple.(i32, f32, str) = (1, 2.2, "three")
</code></pre>
</blockquote>
<p>Also, like "normal" data, tuples can be passed to functions as mutable references:</p>
<pre><code class="language-rs">use Core.print

def change_tuple(mut data&lt;i32, f32, str&gt; tuple):
    tuple.($0, $1, $2) = (2, 3.3, "four");

def main():
    data&lt;i32, f32, str&gt; tuple = (1, 2.2, "three");
    print($"tuple.(i32, f32, str) = ({tuple.$0}, {tuple.$1}, \"{tuple.$2}\")\n");

    change_tuple(tuple);
    print($"tuple.(i32, f32, str) = ({tuple.$0}, {tuple.$1}, \"{tuple.$2}\")\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>tuple.(i32, f32, str) = (1, 2.2, "three")
tuple.(i32, f32, str) = (2, 3.3, "four")
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="multi-types"><a class="header" href="#multi-types">Multi-Types</a></h1>
<p>Multi-Types are essentially vectorized variants of <em>some</em> primitive types to increase both readability, performance (SIMD) and ease of use for vectorized math operations and much more. Here is an example of how multi-types work:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32x3 v3 = (1, 2, 3);
    print($"v3.(x, y, z) = ({v3.x}, {v3.y}, {v3.z})\n");
    v3.(x, y, z) = (4, 5, 6);
    print($"v3.(x, y, z) = ({v3.x}, {v3.y}, {v3.z})\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>v3.(x, y, z) = (1, 2, 3)
v3.(x, y, z) = (4, 5, 6)
</code></pre>
</blockquote>
<p>As you can see, the 3-width i32 multi-type has the "fields" of x, y and z, each being of type <code>i32</code>. There exist several multi-types in Flint today:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Type</th><th style="text-align: center">Element Type</th><th style="text-align: center">Vector Size</th><th style="text-align: left">"Field" Names</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>i32x2</code></td><td style="text-align: center"><code>i32</code></td><td style="text-align: center">2</td><td style="text-align: left"><code>x</code>, <code>y</code></td></tr>
<tr><td style="text-align: center"><code>i32x3</code></td><td style="text-align: center"><code>i32</code></td><td style="text-align: center">3</td><td style="text-align: left"><code>x</code>, <code>y</code>, <code>z</code></td></tr>
<tr><td style="text-align: center"><code>i32x4</code></td><td style="text-align: center"><code>i32</code></td><td style="text-align: center">4</td><td style="text-align: left"><code>r</code>, <code>g</code>, <code>b</code>, <code>a</code></td></tr>
<tr><td style="text-align: center"><code>i32x8</code></td><td style="text-align: center"><code>i32</code></td><td style="text-align: center">8</td><td style="text-align: left"><code>$N</code></td></tr>
<tr><td style="text-align: center"><code>i64x2</code></td><td style="text-align: center"><code>i64</code></td><td style="text-align: center">2</td><td style="text-align: left"><code>x</code>, <code>y</code></td></tr>
<tr><td style="text-align: center"><code>i64x3</code></td><td style="text-align: center"><code>i64</code></td><td style="text-align: center">3</td><td style="text-align: left"><code>x</code>, <code>y</code>, <code>z</code></td></tr>
<tr><td style="text-align: center"><code>i64x4</code></td><td style="text-align: center"><code>i64</code></td><td style="text-align: center">4</td><td style="text-align: left"><code>r</code>, <code>g</code>, <code>b</code>, <code>a</code></td></tr>
<tr><td style="text-align: center"><code>f32x2</code></td><td style="text-align: center"><code>f32</code></td><td style="text-align: center">2</td><td style="text-align: left"><code>x</code>, <code>y</code></td></tr>
<tr><td style="text-align: center"><code>f32x3</code></td><td style="text-align: center"><code>f32</code></td><td style="text-align: center">3</td><td style="text-align: left"><code>x</code>, <code>y</code>, <code>z</code></td></tr>
<tr><td style="text-align: center"><code>f32x4</code></td><td style="text-align: center"><code>f32</code></td><td style="text-align: center">4</td><td style="text-align: left"><code>r</code>, <code>g</code>, <code>b</code>, <code>a</code></td></tr>
<tr><td style="text-align: center"><code>f32x8</code></td><td style="text-align: center"><code>f32</code></td><td style="text-align: center">8</td><td style="text-align: left"><code>$N</code></td></tr>
<tr><td style="text-align: center"><code>f64x2</code></td><td style="text-align: center"><code>f64</code></td><td style="text-align: center">2</td><td style="text-align: left"><code>x</code>, <code>y</code></td></tr>
<tr><td style="text-align: center"><code>f64x3</code></td><td style="text-align: center"><code>f64</code></td><td style="text-align: center">3</td><td style="text-align: left"><code>x</code>, <code>y</code>, <code>z</code></td></tr>
<tr><td style="text-align: center"><code>f64x4</code></td><td style="text-align: center"><code>f64</code></td><td style="text-align: center">4</td><td style="text-align: left"><code>r</code>, <code>g</code>, <code>b</code>, <code>a</code></td></tr>
<tr><td style="text-align: center"><code>bool8</code></td><td style="text-align: center"><code>bool</code></td><td style="text-align: center">8</td><td style="text-align: left"><code>$N</code></td></tr>
</tbody></table>
</div>
<p>All multi-types with less than width 4 can be accessed via the field names directly, while all multi-types which are bigger, like <code>i32x8</code> can only be accessed with the same index-based accesser like tuples through the <code>.$N</code> syntax. This is also the reason why tuples needed to be explained before multi-types.</p>
<h2 id="multi-types-with-functions"><a class="header" href="#multi-types-with-functions">Multi-Types with Functions</a></h2>
<p>But let's move on to functions, because multi-types can be returned from functions too, unlike tuples. So, we can very well define a function like this:</p>
<pre><code class="language-rs">use Core.print

def get_vec_2(i32 x, i32 y) -&gt; i32x2:
    return (x, y);

def main():
    (x, y) := get_vec_2(10, 20);
    print($"(x, y) = ({x}, {y})\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>(x, y) = (10, 20)
</code></pre>
</blockquote>
<p>As you can see, interoperability between mutli-types and groups <em>just works</em>. <strong>Groups</strong> are Flint's "type interoperability layer". You can pack multiple single values into a group, then store it in a tuple. Or access multiple fields of a tuple and store it in a multi-type etc. Groups are the real "middle-ground" of Flint's type system, because you can return a group of <code>(i32, i32)</code> and still store it in a mutli-type or you can return a <code>i32x2</code> and store it in a group. The group, however, could also be a grouped assignment of a tuple, so you could very well write <code>tuple.($0, $2) = get_vec_2(10, 20);</code> and store the <code>i32x2</code> return value on the <code>$0</code> and <code>$2</code> fields of the tuple, because its a grouped assignment and groups are natively meant to be interoperable with Flint's other types.</p>
<h2 id="multi-type-arithmetic"><a class="header" href="#multi-type-arithmetic">Multi-Type Arithmetic</a></h2>
<p>Multi-types are <strong>primitive types</strong> in Flint, which means that they have first-class arithmetic support. The mutli-type variant of any type supports the same arithmetic operations as its underlying type. Here is one example of this:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32x4 v4_1 = (1, 2, 3, 4);
    i32x4 v4_2 = (5, 6, 7, 8);
    i32x4 sum = v4_1 + v4_2;
    print($"sum = ({sum.r}, {sum.g}, {sum.b}, {sum.a})\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>sum = (6, 8, 10, 12)
</code></pre>
</blockquote>
<h2 id="important-note-1"><a class="header" href="#important-note-1">Important Note</a></h2>
<p>When using Multi-Types you gain free access to SIMD instructions. SIMD means <strong>S</strong>ingle <strong>I</strong>nstruction, <strong>M</strong>ultiple <strong>D</strong>ata and its a very optimized way of doing operations, such as additions. For example, adding two <code>i32x4</code> variables is just as fast as adding a single <code>i32</code> variable. This makes Flint's multi-types both extremely fast and extremely easy to use.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="arrays"><a class="header" href="#arrays">Arrays</a></h1>
<p>In the previous chapter we learned the importance of <code>data</code>, groups, mutli-types, tuples and how to use all of them in functions. With all these concepts we now developed a good understanding of Flint's type-system. So, its now time to move to more complex types than those of the last chapter – arrays.</p>
<h2 id="what-are-arrays"><a class="header" href="#what-are-arrays">What are Arrays?</a></h2>
<p>An array is a collection of the same data type which can be resized and filled with values. While mutli-types and tuples are great for storing a small amount of values, what if we want to store a hundred of them? Using a tuple to store 100 elements would not only be extremely tedious but also extremely verbose. Just imagine writing <code>i32, </code> a hundred times inside the <code>data&lt;..&gt;</code> definition.</p>
<p>You actually already know an array type: Strings! The <code>str</code> type is just an array of characters (<code>i8</code>) but you will also learn how strings work under the hood in this chapter!</p>
<h2 id="why-are-arrays-important"><a class="header" href="#why-are-arrays-important">Why are Arrays Important?</a></h2>
<p>Arrays are essential in programming because the allow you to:</p>
<ul>
<li>Store and manipulate large amounts of data</li>
<li>Perform operations on multiple values at once</li>
<li>Use indexing to access specific values in the array</li>
</ul>
<h2 id="what-to-expect-3"><a class="header" href="#what-to-expect-3">What to Expect</a></h2>
<p>In this chapter, we will conver the following topics:</p>
<ul>
<li>Declaring and using arrays</li>
<li>Accessing and modifying array elements</li>
<li>Using arrays in functions and data modules</li>
<li>What strings and arrays have in common with one another</li>
<li>What ranges are and how to use them</li>
<li>The enhanced for loop, what it is and how it works</li>
<li>Multi-dimensional arrays and access patterns</li>
<li>Best practices for working with arrays</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="introduction-to-arrays"><a class="header" href="#introduction-to-arrays">Introduction to Arrays</a></h1>
<p>An <strong>array</strong> is a data structure that stores a collection of elements sequentially in memory. Arrays are useful for storing multiple values of the same type, such as numbers, strings, or even custom data modules. In Flint, arrays are <strong>immutable by default</strong> in terms of references — assigning one array to another always creates a <strong>copy</strong>, not a reference.</p>
<ul>
<li>Arrays are always <strong>stored sequentially</strong> in memory, making access to their elements efficient.</li>
<li>Arrays are <strong>value types</strong> in Flint. This means copying an array creates a <strong>new, independent copy</strong> of its data.</li>
<li>If you modify an array inside a data object, you should <strong>access it directly</strong> using data.array instead of copying it out, as changes made to the copy won’t automatically reflect back in the original array.</li>
<li>They are considered complex data types, so passing them to functions passes them as a reference, not a copy.</li>
</ul>
<h2 id="creating-arrays"><a class="header" href="#creating-arrays">Creating Arrays</a></h2>
<p>To declare a one-dimensional array, we write brackets after the array type, for example <code>i32[]</code> for an array of <code>i32</code> values:</p>
<pre><code class="language-rs">def main():
    i32[] arr = i32[10](0);
</code></pre>
<p>This program does not print anything to the console, but we need to talk about it nonetheless and talk about whats happening here. So, we create an array of type <code>i32[]</code> and store it on the variable <code>arr</code>. We <strong>initialize</strong> the array quite similar to how we would initialize <code>data</code>. For <code>data</code>, we wrote the <strong>name</strong> of the data type, followed by parenthesis in which we wrote the initializer arguments. For arrays, this works a bit differently. First of all, we need to provide a <strong>size</strong> in between the squared brackets, in the above example the size will be set to <code>10</code>, which means that the array <code>arr</code> will contain <code>10</code> values of type <code>i32</code>. And lastly, the <code>(0)</code>. For arrays, we need to define a "default-value" with which all array elements are filled. In our case, this is the <code>i32</code> value of <code>0</code>, which means that every single one of the 10 elements in the array has the value <code>0</code> stored in it after the arrays creation.</p>
<h2 id="accessing-elements"><a class="header" href="#accessing-elements">Accessing Elements</a></h2>
<p>To access an element of an array we need to use a new syntax, different from when we accessed elements of the tuple via <code>.$N</code>. Now, for arrays, we need to access it using <code>[N]</code>, where <code>N</code> is the index we want to access. Here is a small example of that:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32[] arr = i32[10](0);
    i32 elem_3 = arr[3];
    print($"elem_3 = {elem_3}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>elem_3 = 0
</code></pre>
</blockquote>
<p>Okay, the array is of size <code>10</code> and we start counting at <code>0</code>, so the last index we are allowed to access is <code>9</code>...what happens if we access index <code>10</code>? In most languages this would yield into a hard crash of the program, but in Flint we have extra safety-guards in place for out-of-bounds checks. But try it for yourself, try to compile and run this program:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32[] arr = i32[10](0);
    i32 elem_10 = arr[10];
    print($"elem_10 = {elem_10}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>Out Of Bounds access occured: Arr Len: 10, Index: 10
elem_10 = 0
</code></pre>
</blockquote>
<p>As you can see, Flint just continues with execution. When you try to access an value thats outside the bounds of the array, Flint will just clamp the index to the last element of the array instead, and printing a message that an Out Of Bounds access has occured. You can actually change Flint's behaviour for OOB-handling with the <strong>Array Options</strong>. Here is a small cutout of the help message of the compiler:</p>
<blockquote>
<pre><code>Array Options:
  --array-print               [Default] Prints a small message to the console whenever accessing an array OOB
  --array-silent              Disables the debug printing when OOB access happens
  --array-crash               Hard crashes when an OOB access happens
  --array-unsafe              Disables all bounds checks for array accesses
</code></pre>
</blockquote>
<p>Try compiling the above code with the different array options set and see for yourself how the Flint program behaves. Flint aims to be as safe and as verbose (in its output) as possible and we try to make safety the default and let you opt-out of safety (for example through the --array-unsafe flag) if you are 100% sure that OOB accesses are impossible for your program.</p>
<h2 id="assigning-values"><a class="header" href="#assigning-values">Assigning Values</a></h2>
<p>To assign new values to elements of the array we use the same accessing-syntax as before:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32[] arr = i32[10](0);
    arr[3] = 8;
    arr[4] = 4;
    print($"arr[3] + arr[4] = {arr[3] + arr[4]}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>arr[3] + arr[4] = 12
</code></pre>
</blockquote>
<h2 id="grouped-access-and-assignment"><a class="header" href="#grouped-access-and-assignment">Grouped Access and Assignment</a></h2>
<div class="warning">
<p>This feature is not yet implemented in the compiler</p>
<p>Currently, this feature does not yet work in the current version of the compiler, but it is <strong>definitely</strong> planned to be implemented in a later version.</p>
</div>
<p>Just like with tuples, mutli-types, data or basically any type in Flint, arrays have some form of interoperability with groups too. The syntax looks a bit different, though. Here is the same example as above, but using a grouped assignment:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32[] arr = i32[10](0);
    arr.[3, 4] = (8, 4);
    print($"arr[3] + arr[4] = {arr[3] + arr[4]}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>arr[3] + arr[4] = 12
</code></pre>
</blockquote>
<p>As you can see, instead of doing <code>.(x, y)</code> (for example for <code>i32x2</code>) we write <code>.[idx1, idx2]</code>. We definitely need the <code>.</code> in front of the <code>[</code> symbol to differentiate a grouped array access from a multi-dimensional array access, but you will learn about multi-dimensional arrays soon.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="iterating-over-arrays"><a class="header" href="#iterating-over-arrays">Iterating Over Arrays</a></h1>
<p>Often, you will want to process each element of an array inside of a loop. For this, you can easily use a <code>for</code> loop, like so:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32[] arr = i32[5](4);
    // Set each element to the double of the index
    for i := 0; i &lt; 5; i++:
        arr[i] = i * 2;
        print($"Index: {i}, Value: {arr[i]}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>Index: 0, Value: 0
Index: 1, Value: 2
Index: 2, Value: 4
Index: 3, Value: 6
Index: 4, Value: 8
</code></pre>
</blockquote>
<p>With loops, we can better demonstrate the OOB-behaviour mentioned in the last chapter. Here is an example to better demonstrate this behaviour:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32[] arr = i32[5](4);
    for i := 0; i &lt; 10; i++:
        arr[i] = i * 2;
        print($"Index: {i}, Value: {arr[i]}\n");

    print("\n");
    for i := 0; i &lt; 5; i++:
        print($"Index: {i}, Value: {arr[i]}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>Index: 0, Value: 0
Index: 1, Value: 2
Index: 2, Value: 4
Index: 3, Value: 6
Index: 4, Value: 8
Out Of Bounds access occured: Arr Len: 5, Index: 5
Out Of Bounds access occured: Arr Len: 5, Index: 5
Index: 5, Value: 10
Out Of Bounds access occured: Arr Len: 5, Index: 6
Out Of Bounds access occured: Arr Len: 5, Index: 6
Index: 6, Value: 12
Out Of Bounds access occured: Arr Len: 5, Index: 7
Out Of Bounds access occured: Arr Len: 5, Index: 7
Index: 7, Value: 14
Out Of Bounds access occured: Arr Len: 5, Index: 8
Out Of Bounds access occured: Arr Len: 5, Index: 8
Index: 8, Value: 16
Out Of Bounds access occured: Arr Len: 5, Index: 9
Out Of Bounds access occured: Arr Len: 5, Index: 9
Index: 9, Value: 18

Index: 0, Value: 0
Index: 1, Value: 2
Index: 2, Value: 4
Index: 3, Value: 6
Index: 4, Value: 18
</code></pre>
</blockquote>
<p>You can spot two out of bounds accesses here. The first one happens when we want to assign <code>i * 2</code> to the array at <code>i</code> and the second one is in the printing when trying to print <code>arr[i]</code> in the string interpolation. And then, at the end we print the current values of the array and you can clearly see that the last element at index 4 holds the value 18, which is double the last index of the last loop. As you can see, OOB accesses are considered "safe" in Flint, because it is well-defined what will happen when an OOB access occurs.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="strings-1"><a class="header" href="#strings-1">Strings</a></h1>
<p>As stated earlier, strings and arrays have very much in common, actually. If we would make a deep-dive into how Flint works internally we would see that arrays and strings actually are the same data structure, but thats too low level for now. But, the important thing to note here is the similarity of strings with arrays, as a string is essentially just an array of characters, but what <em>is</em> a character in string really?</p>
<p>In Flint, a character has the type <code>u8</code>, a type we have not discussed until now. So, if you save the sting <code>hello</code> on a variable its essentially the same as if you would store a <code>u8[]</code> array of length <code>5</code>. There exists a separate <code>str</code> type, however, to make our life with strings a lot easier than it would if we would need to think of strings as arrays of bytes.</p>
<p>But what does all of this mean? Well, first we can access a given character of a string exactly as we would access any element of an array, here is an example:</p>
<pre><code class="language-rs">use Core.print

def main():
    str name = "Marc";
    u8 third = name[2];
    print($"third = '{third}'\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>third = 'r'
</code></pre>
</blockquote>
<p>Now you might say...wait a minute, why is the character printed as <code>r</code> and not as a number, it's an <code>u8</code> type nonetheless, right? Yes, it is. Flint currently only supports characters from the ASCII set. In computers, characters as text is represented as numbers in the ASCII set. You can look at the whole ASCII table <a href="https://www.ascii-code.com/en">here</a>. According to the table, the character <code>r</code> should be the ASCII value of <code>114</code>, lets check that:</p>
<pre><code class="language-rs">use Core.print

def main():
    str name = "Marc";
    u8 third = name[2];
    print($"third = '{third}' at idx {i32(third)}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>third = 'r' at idx 114
</code></pre>
</blockquote>
<p>As you can see, <code>r</code> really is just the number <code>114</code> inside the computer. But what does this mean for arithmetic, comparisons etc? Because <code>u8</code> is "just a normal integer type" we can add, multiply, substract, divide, compare etc, everything like with <code>i32</code> values. But, we can not directly just store numbers on it without explicit typecasting. Here is an example of this:</p>
<pre><code class="language-rs">use Core.print

def main():
    u8 character = 'C';
    print($"character '{character}' is {i32(character)}\n");

    character++;
    print($"character '{character}' is {i32(character)}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>character 'C' is 67
character 'D' is 68
</code></pre>
</blockquote>
<h2 id="getting-a-strings-length"><a class="header" href="#getting-a-strings-length">Getting a strings length</a></h2>
<p>It is not uncommon to have a string as a paramter of a function, for example, and then we often want to get the length of the string somehow, maybe we dont know the length of a string beforehand, for example when parsing user input (will be talked about in a later chapter). But, very often we don't know the size of a string when writing the program, so we need a way to get a strings length at runtime. Here is a small program demonstrating how to get and use the length of a string:</p>
<pre><code class="language-rs">use Core.print

def main():
    str some_string = "some neat string";
    len := some_string.length;
    print($"string '{some_string}' is {len} characters long\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>string 'some neat string' is 16 characters long
</code></pre>
</blockquote>
<p>The variable <code>len</code> is of type <code>u64</code> here. The <code>length</code> field of a string is <strong>always</strong> a <code>u64</code>. One-dimensional arrays have also the result type of <code>u64</code> for their <code>.length</code> field. Here is a small example how you can print an unknown string line by line:</p>
<pre><code class="language-rs">use Core.print

def print_str(str input):
    for i := 0; i &lt; input.length; i++:
        print($"{i}: '{input[i]}'\n");

def main():
    print_str("Hello");
    print_str(", ");
    print_str("World!\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>0: 'H'
1: 'e'
2: 'l'
3: 'l'
4: 'o'
0: ','
1: ' '
0: 'W'
1: 'o'
2: 'r'
3: 'l'
4: 'd'
5: '!'
6: '
'
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="multidimensional-arrays"><a class="header" href="#multidimensional-arrays">Multidimensional Arrays</a></h1>
<p>Flint supports <strong>multidimensional arrays</strong>. In Flint, these arrays are <strong>always rectangular</strong>, meaning that the length of each dimension is locked, unlike <em>jagged arrays</em>, which behave more like "array of arrays". Multidimensional Arrays are particularly useful for storing grid-like data, such as images or matrices.</p>
<h2 id="declaring-multidimensional-arrays"><a class="header" href="#declaring-multidimensional-arrays">Declaring Multidimensional Arrays</a></h2>
<p>The number of commas between the brackets of the array type directly indicates the dimensionality of an array. So, the array <code>i32[]</code> is a one-dimensional array (we have one "line" of values), then <code>i32[,]</code> is a two-dimensional array (we have a "plane" of values), <code>i32[,,]</code> is a three-dimensional array (we have a "cube" of values) and so on. There is no limit to how high the dimensionality of an array can be, really. We start with dimensionality of <code>1</code> because a dimensionality of <code>0</code> is already defined: its a single value, so <code>i32</code> is "an array of 0 dimensionality" if you want to see it like this.</p>
<p>When declaring a multi-dimensional array we use the same syntax as for "normal" arrays, with the same default-value that gets put into all elements of the array as usual:</p>
<pre><code class="language-rs">def main():
    // 2D array
    i32[,] plane = i32[10, 10](0);
    // 3D array
    i32[,,] cube = i32[10, 10, 10](0);
</code></pre>
<p>Here, we defined the <code>plane</code> array to be of size <code>10 × 10</code>, which means there can be stored <code>100</code> elements in this two-dimensional array. We also defined the <code>cube</code> array to be of size <code>10 × 10 × 10</code>, which means there can be stored <code>1000</code> elements in this three-dimensional array.</p>
<h2 id="accessing-multidimensional-arrays"><a class="header" href="#accessing-multidimensional-arrays">Accessing Multidimensional Arrays</a></h2>
<p>To access and assign elements at a given index we need to specify the index of each dimensionality explicitely. For our plane, this would mean that we need to specify the "row" and the "column" of the plane, or the "x" and the "y" coordinates (if the plane is seen as a coordinate plane).</p>
<pre><code class="language-rs">use Core.print

def main():
    i32[,] plane = i32[10, 10](0);
    // Set the element at row 1, column 2
    plane[1, 2] = 10;
    print($"plane[1, 2] = {plane[1, 2]}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>plane[1, 2] = 10
</code></pre>
</blockquote>
<h2 id="getting-the-lengths-of-multi-dimensional-arrays"><a class="header" href="#getting-the-lengths-of-multi-dimensional-arrays">Getting the lengths of multi-dimensional arrays</a></h2>
<p>In the last chapter we talked about how we can access the length of strings and arrays by the <code>.length</code> field on them. This also is true for multi-dimensional arrays. But we have more than one dimension, so how is it possible to get the lengths in one <code>u64</code> variable? Thats a good question, and the answer is very simple: we don't.</p>
<p>Instead, when accessing the <code>.length</code> field of an array we <em>actually</em> get a group of size <code>N</code>, where <code>N</code> is the dimensionality of the array. So, if we access the <code>.length</code> field of an one-dimensional array we get a group of size 1, so we get one <code>u64</code> value. If we access the <code>.length</code> field on the <code>plane</code> array we will get a <code>(u64, u64)</code> group as a return, and if we access the length of a 3D array like our <code>cube</code> we will get a <code>(u64, u64, u64)</code> group as the lengths value, one value for each dimension:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32[,] plane = i32[10, 20](0);
    (x, y) := plane.length;
    print($"plane.length = ({x}, {y})\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>plane.length = (10, 20)
</code></pre>
</blockquote>
<h2 id="iterating-over-multidimensional-arrays"><a class="header" href="#iterating-over-multidimensional-arrays">Iterating over Multidimensional Arrays</a></h2>
<p>Now that we know how to access the lengths of a multi-dimensional array we also can iterate through the array. And for this very reason we need to discuss <strong>row-major</strong> vs <strong>column-major</strong> formats. In Flint, arrays are <strong>always</strong> stored in row-major format, but what does this mean and why is it important?</p>
<p>The array format describes how elements are layed out in memory. Multi-dimensional arrays are essentially "fake"... and in this small section you will also learn why the distinction between the <code>str</code> type and the <code>u8[]</code> type is important. Lets get started then...</p>
<p>Multi-dimensional arrays are "fake" because the values are <em>still</em> stored in <strong>one</strong> contiguous line in memory. Lets look at this easy example here to understand it better: a <code>i32[,]</code> array where each dimensionality has the size of <code>3</code>. Below is a small table in which we give every element a unique ID, from top left to bottom right. We actually start counting at the top left at 0:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th><th style="text-align: center"><code>X0</code></th><th style="text-align: center"><code>X1</code></th><th style="text-align: center"><code>X2</code></th></tr></thead><tbody>
<tr><td style="text-align: center"><code>Y0</code></td><td style="text-align: center">0</td><td style="text-align: center">1</td><td style="text-align: center">2</td></tr>
<tr><td style="text-align: center"><code>Y1</code></td><td style="text-align: center">3</td><td style="text-align: center">4</td><td style="text-align: center">5</td></tr>
<tr><td style="text-align: center"><code>Y2</code></td><td style="text-align: center">6</td><td style="text-align: center">7</td><td style="text-align: center">8</td></tr>
</tbody></table>
</div>
<p>What this table tells us is that <code>arr[0, 2]</code> would be the value of <code>6</code> (x = 0, y = 2). Okay, so the difference between row-major and column-major is this one:</p>
<p>In <strong>Row-Major</strong> format, the array is stored in memory like this:</p>
<pre><code>0 1 2 3 4 5 6 7 8
</code></pre>
<p>In <strong>Column-Major</strong> format, the array is stored in memory like this:</p>
<pre><code>0 3 6 1 4 7 2 5 8
</code></pre>
<p>Note that the numbers that have been chosen do not matter at all, they are just to showcase how it works under the hood. For you, it actually doesn't really matter if it would be saved in row-major or column-major format, if you access arr[0, 2] you would get the same value (<code>X0</code>, <code>Y2</code>) for both formats, its just a matter of how it's saved to memory. But this very reason, how it is saved to memory, is really important for one and only one reason: <strong><em>performance</em></strong>.</p>
<p>You see, when we iterate over an array we can choose between those two methods:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32[,] mat = i32[3, 3](0);
    i32 n = 0;
    // Row-major looping + fills the array
    for i32 y = 0; y &lt; 3; y++:
        for i32 x = 0; x &lt; 3; x++:
            mat[x, y] = n;
            print($"mat[{x}, {y}] = {mat[x, y]}\n");
            n++;

    // Print one empty line in between
    print("\n");

    // Column-major looping
    for i32 x = 0; x &lt; 3; x++:
        for i32 y = 0; y &lt; 3; y++:
            print($"mat[{x}, {y}] = {mat[x, y]}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>mat[0, 0] = 0
mat[1, 0] = 1
mat[2, 0] = 2
mat[0, 1] = 3
mat[1, 1] = 4
mat[2, 1] = 5
mat[0, 2] = 6
mat[1, 2] = 7
mat[2, 2] = 8

mat[0, 0] = 0
mat[0, 1] = 3
mat[0, 2] = 6
mat[1, 0] = 1
mat[1, 1] = 4
mat[1, 2] = 7
mat[2, 0] = 2
mat[2, 1] = 5
mat[2, 2] = 8
</code></pre>
</blockquote>
<p>As you can see, the two looping techniques directly correlate to the order the elements are stored in memory for the examples i have provided you with above. But what is more performant now? If you access the element at <code>mat[1, 2]</code> you are actually accessing the <code>8th</code> element of the array (when starting to count at <code>1</code> here). Because in row-major format, when accessing the element at the third row (y is the row, x is the column) we first need to go through all elements of the two rows that came before it, which is <code>6</code> elements.</p>
<p>So, you may be able to see now that the index at which we would read memory from would constantly jump between positions when iterating through an array using column-major looping whereas when we loop through the array using row-major looping we go through all indices of the two-dimensional array one by one. This is called a <strong>sequentail operation</strong> and the other one is called a <strong>random operation</strong> in computer science. The CPU is <strong>much</strong> more performant with sequential operations than it is with random operations, as it is not as prone to <strong>cache-misses</strong> with sequential loads. If you want to read more about this topic, look <a href="https://www.hostinger.com/uk/tutorials/cache-miss">here</a>.</p>
<p>TLDR: The row-major loop properly utilizes the CPU cache and reduces cache-misses, making the operations <em>much</em> faster in return.</p>
<p>Before you wonder why i told you all of this, everything i talked about becomes important in the next chapter!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="enhanced-for-loops"><a class="header" href="#enhanced-for-loops">Enhanced for Loops</a></h1>
<p>Enhanced for loops are for loops without explicitely declaring a range, but instead they directly operate on a so-called <strong>iterable</strong>. They are extremely useful for iterating through arrays, as enhanced for loops will <strong>always</strong> iterate through a multidimensional array <em>sequentially</em>.</p>
<p>Here is a small example:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32[] arr = i32[5](0);
    // First, fill the array with meaningful values
    for i := 0; i &lt; arr.length; i++:
        arr[i] = i * 2;

    // Iterate through the array element by element
    for (idx, elem) in arr:
        print($"Index {idx}, Value {elem}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>Index 0, Value 0
Index 1, Value 2
Index 2, Value 4
Index 3, Value 6
Index 4, Value 8
</code></pre>
</blockquote>
<p>Okay, lets go through everything about the enhanced for loops one by one. You surely wonder what this <code>(idx, elem)</code> is, and why it looks like a group, right? Well, because it is! When iterating through an iterable we <em>always</em> get the index as the first value of the iteration context (the group) and the element at that index as the second value of the iteration context.</p>
<p>Note that <code>elem</code> is a <strong>mutable reference</strong> to the array element. So, writing <code>elem = ...</code> is the same as if you would write <code>arr[..] = </code>. Here is an example:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32[] arr = i32[5](0);
    // First, fill the array with meaningful values
    for (idx, elem) in arr:
        elem = idx * 2;

    // Iterate through the array element by element
    for (idx, elem) in arr:
        print($"Index {idx}, Value {elem}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>Index 0, Value 0
Index 1, Value 2
Index 2, Value 4
Index 3, Value 6
Index 4, Value 8
</code></pre>
</blockquote>
<p>As you can see, modifying <code>elem</code> directly modifies the array at the current index inplace. This is <em>extremely</em> powerful for mutli-dimensional arrays, because yes, multidimensional arrays are considered iterables too!</p>
<h2 id="not-using-index-or-elem"><a class="header" href="#not-using-index-or-elem">Not using index or elem</a></h2>
<p>We can opt out of using the <code>index</code> or <code>elem</code> variables for enhanced for loops entirely through the <code>_</code> operator. Again, it is used in the context of <code>unused</code> here. Here is a small example:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32[] arr = i32[5](0);
    // Just fill the array with stuff
    for (idx, elem) in arr:
        elem = idx * 2;

    // Ignoring the index value in the enhanced for loop
    for (_, elem) in arr:
        print($"elem is {elem}\n");

    // Ignoring the elem in the enhanced for loop
    for (idx, _) in arr:
        print($"Iteration {idx}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>elem is 0
elem is 2
elem is 4
elem is 6
elem is 8
Iteration 0
Iteration 1
Iteration 2
Iteration 3
Iteration 4
</code></pre>
</blockquote>
<h2 id="iterating-through-mutlidimensional-arrays"><a class="header" href="#iterating-through-mutlidimensional-arrays">Iterating through Mutlidimensional Arrays</a></h2>
<p>As multidimensional arrays are also considered <strong>iterables</strong> we can use the enhanced for loop on multi-dimensional arrays just like we did with the nested for loops:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32[,] plane = i32[3, 3](0);

    for (index, elem) in plane:
        elem = i32(index);

    for y := 0; y &lt; 3; y++:
        for x := 0; x &lt; 3; x++:
            print($"plane[{x}, {y}] = {plane[x, y]}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>plane[0, 0] = 0
plane[1, 0] = 1
plane[2, 0] = 2
plane[0, 1] = 3
plane[1, 1] = 4
plane[2, 1] = 5
plane[0, 2] = 6
plane[1, 2] = 7
plane[2, 2] = 8
</code></pre>
</blockquote>
<p>As you can see, using the enhanced for loop for multi-dimensional arrays yields both the best performance, as we iterate sequentially through the whole array, we have an easy counter to see in which iteration we are and we can modify each element of the multi-dimensional array one by one. If you ever need to modify each element of the array without necessarily needing the positional information (<code>x</code> and <code>y</code> in our case) enhanced for loops are your friend!</p>
<h2 id="iteration-context"><a class="header" href="#iteration-context">Iteration Context</a></h2>
<p>It was said earlier that the group with the index and the element is called the <strong>iteration context</strong> but what does this mean and why does it have a name? Its actually pretty simple: Because this context can be a tuple variable as well!</p>
<p>The <code>index</code> of the iteration context is always a <code>const</code> variable, while the <code>elem</code> of it is always a <code>mut</code> "variable" (its a reference). The iteration context as a tuple itself is <code>const</code>, and the <code>elem</code> field of it (the second field of the tuple) is not a mutable reference anymore, but its an immutable copy (for primitives) or an immutable reference (for complex data types) instead. This means that when using a tuple as the iteration context, we can no longer change the iterable directly through the <code>elem</code> reference. Here is an example:</p>
<pre><code class="language-rs">use Core.print

def main():
    i32[] arr = i32[5](0);
    // First, initialize the array, as always
    for (idx, elem) in arr:
        elem = idx * 2;

    for ctx in arr:
        print($"{ctx.$0}: {ctx.$1}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>0: 0
1: 2
2: 4
3: 6
4: 8
</code></pre>
</blockquote>
<h2 id="enhanced-for-loop-for-strings"><a class="header" href="#enhanced-for-loop-for-strings">Enhanced for loop for strings</a></h2>
<p>You can also iterate over a string using the enhanced for loop, just like you can for arrays. Here is an example of this in action:</p>
<pre><code class="language-rs">use Core.print

def main():
    str my_string = "something useful";
    for (idx, elem) in my_string:
        if idx == 2 or idx == 4:
            // The difference between upcase and lowercase is 32
            u8 tmp_elem = elem;
            elem = tmp_elem - u8(32);

    print($"my_string = '{my_string}'\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>my_string = 'soMeThing useful'
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="cli-arguments"><a class="header" href="#cli-arguments">CLI Arguments</a></h1>
<p>CLI Arguments stands for <strong>C</strong>ommand <strong>L</strong>ine <strong>I</strong>nterface Arguments. CLI arguments describe the act of passing in arguments to a program when executing said program, just like executing a function and passing in the arguments to the function. In fact, many programs can be thought of as "functions" in the Linux world, where you pass in data to a function and get something from it in return.</p>
<p>Here is an example of CLI arguments in action:</p>
<pre><code class="language-rs">use Core.print

def main(str[] args):
    for (idx, elem) in args:
        print($"args[{idx}] = {elem}\n");
</code></pre>
<p>Note how the <strong>signature</strong> of the main function has changed. The main function is allowed to have a parameter of type <code>str[]</code> or to have no parameter. All other cases will lead to an compile error.</p>
<p>This program will print different lines to the console, depending on how we execute it. If we execute the built program (for example the <code>main</code> binary) with this command:</p>
<pre><code class="language-sh">./main
</code></pre>
<p>we will see this line being printed to the console:</p>
<blockquote>
<pre><code>args[0] = ./main
</code></pre>
</blockquote>
<p>If we execute the program like so:</p>
<pre><code class="language-sh">./main someargument somethingelse third-thing
</code></pre>
<p>we will se theese lines being printed to the console instead:</p>
<blockquote>
<pre><code>args[0] = ./main
args[1] = someargument
args[2] = somethingelse
args[3] = third-thing
</code></pre>
</blockquote>
<p>As you can see, the first argument is always the command with which the program was executed with. If the built binary is in a subdirectory, for example, and you execute it with this command:</p>
<pre><code class="language-sh">./somedirectory/main
</code></pre>
<p>you will see this line being printed to the console in this case:</p>
<blockquote>
<pre><code>args[0] = ./somedirectory/main
</code></pre>
</blockquote>
<p>So, if you execute a program with the absolute path to said program, the first CLI argument will contain the command used to execute the program.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="imports"><a class="header" href="#imports">Imports</a></h1>
<p>Up until now, we have always worked with one single file, and with a small file too. But a project that only contains a sinlge file is extremely limiting in what you can do with it and it quickly becomes very messy and confusing if you only have one very large file in which everything is defined in.</p>
<p>For this very reason, Flint supports multi-file projects. Unlike languages like C or C++, where you manually need to collect all your translation units when compiling, Flint provides a much clearer experience: You only specify the file which contains your <code>main</code> function and <code>flintc</code> will dynamically discover all included files, build its internal dependency tree and compile your project from this one and single entry point. So, you can compile your programs with the Flint compiler the same way you did until now, support for multi-file projects does not make compilation any harder for you.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="the-use-clausel"><a class="header" href="#the-use-clausel">The <code>use</code> clausel</a></h1>
<p>The <code>use</code> clausel is a top-level definition, like a function definition for example, which provides a way to "import" code from other files (or modules). You have seen it quite a lot until now:</p>
<pre><code class="language-rs">use Core.print
</code></pre>
<p>You have seen this line a lot of times and you have surely wondered what it means. But why do we call it a <em>clausel</em> and not a <em>statement</em>? In many other languages this inclusion of other code is known as the use-statement or include/import-statement, and they end with a semicolon. But, as you can see, the <code>use</code> clausel does not end with a semicolon in Flint, but why is that?</p>
<p>A <em>statement</em> is a line of code thats written within a <em>scope</em>. Many languages see the empty space in which we define our functions as their <em>top-level scope</em> or <em>file-level scope</em>. This means that global variables, imports, function definitions etc are all defined at this global scope. But Flint is a bit different in this regard. We do not call it a <em>use-statement</em> because in Flint <strong>there is no global scope</strong>. You cannot define a variable outside a function and use it inside multiple different functions. <strong>There is no global state in Flint</strong>, and that's a deliberate design choice. This also means that the use-clausel is <em>not</em> a statement, so it cannot be written inside the body of a function itself (unlike C or C++, for example).</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>But before moving on to any more complex topics, here is a small example of creating two files and compining them together:</p>
<p>This is the <code>main.ft</code> file:</p>
<pre><code class="language-rs">use "utils.ft"
use Core.print

def main():
    i32 x = 5;
    i32 y = 6;
    i32 res = add(x, y);
    print($"res = {res}\n");
</code></pre>
<p>This is the <code>utils.ft</code> file:</p>
<pre><code class="language-rs">def add(i32 x, i32 y) -&gt; i32:
    return x + y;
</code></pre>
<p>And you compile the program with the same command as usual:</p>
<pre><code class="language-rs">flintc -f main.ft
</code></pre>
<p>When running the built program, this line will be printed to the console:</p>
<blockquote>
<pre><code>res = 11
</code></pre>
</blockquote>
<p>As you can see, we have successfully called the function <code>add</code> defined in the file <code>utils.ft</code> from the <code>main</code> function inside the <code>main.ft</code> file, and the Flint compiler discovered the used file dynamically during compilation.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="circular-dependencies"><a class="header" href="#circular-dependencies">Circular Dependencies</a></h1>
<p>You may have asked yourself already <em>"What will happen if file <code>A</code> imports file <code>B</code> and file <code>B</code> imports file <code>A</code> again?"</em>. This is called a circular dependency. It's called circular, because the dependency graph forms a circle, where the "line of imports" ends up at its starting point. If you try to write import statements in C where every file imports another file you will get a compilation error, as circular dependencies are not allowed and cannot be resolved.</p>
<p>But Flint's <code>use</code> clausels work quite different from the <code>#import</code> from C-style languages. Whereas these literally just copy and paste the code from the other file, the <code>use</code> clausel in Flint is a lot...smarter. The <code>use</code> clausel only imports files at a depth of <code>1</code>, but what does this mean? Well, here is a small example to showcase what i mean with that:</p>
<p>The <code>helper.ft</code> file:</p>
<pre><code class="language-rs">def substract_and_mult(i32 x, i32 y) -&gt; i32:
    i32 diff = x - y;
    return diff * 2;
</code></pre>
<p>The <code>utils.ft</code> file:</p>
<pre><code class="language-rs">use "helper.ft"

def some_operation(i32 x, i32 y) -&gt; i32:
    i32 res = substract_and_mult(x, y);
    return res - (x + y);
</code></pre>
<p>The <code>main.ft</code> file:</p>
<pre><code class="language-rs">use "utils.ft"
use Core.print

def main():
    i32 res = some_operation(44, 33);
    print($"res = {res}\n");
</code></pre>
<p>When compiling this program, you will see this line printed to the console:</p>
<blockquote>
<pre><code>res = -55
</code></pre>
</blockquote>
<p>In this example you can see how Flint has an importing depth of <code>1</code>, unlike many other languages. So, when you include <code>utils.ft</code> in the <code>main.ft</code> file you <em>only</em> gain access to the <code>some_operation</code> function, but <em>not</em> to the <code>substract_and_mult</code> function from the <code>helper.ft</code> file. There is no recursive resolution of imports happening, meaning that <strong>every</strong> import in Flint is "shallow". If you would need the <code>substract_and_mult</code> function within your <code>main.ft</code> file you would need to write an explicit <code>use "helper.ft"</code> clausel. This is absolutely intentional, because having <em>only</em> shallow inclusions we get something even better: <em><strong>circular inclusion support</strong></em>.</p>
<p>Circular dependencies are <strong>not</strong> considered a fault in Flint, at all. Often times you want to separate code on meaning, but the single files still need access to one another. In C-style languages you would solve this with forward-declarations, header files etc. But in Flint you just include any file you like, and it simply does not matter if a circle emerges or not, the Flint compiler will handle it all! Here is an example showcasing circular dependencies with a recursive function:</p>
<p>The <code>utils.ft</code> file:</p>
<pre><code class="language-rs">use "main.ft"
use Core.print

def recursive_count_utils(i32 x):
    if x &gt; 5:
        print("utils end\n");
        return;
    print($"utils: {x}\n");
    recursive_count_main(x + 1);
</code></pre>
<p>The <code>main.ft</code> file:</p>
<pre><code class="language-rs">use "utils.ft"
use Core.print

def recursive_count_main(i32 x):
    if x &gt; 5:
        print("main end\n");
        return;
    print($"main:  {x}\n");
    recursive_count_utils(x + 1);

def main():
    recursive_count_main(0);
    print("\n");
    recursive_count_utils(0);
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>main:  0
utils: 1
main:  2
utils: 3
main:  4
utils: 5
main end

utils: 0
main:  1
utils: 2
main:  3
utils: 4
main:  5
utils end
</code></pre>
</blockquote>
<p>As you can see, circular dependencies are absolutely no problem in Flint, and the only reason they are no problem is the dynamic exploratory nature of the compiler (you only specify one file and the compiler will find all included functions on its own) and the fact that the inclusion depth is only 1, so every use clausel is a shallow include.</p>
<h2 id="side-note"><a class="header" href="#side-note">Side note</a></h2>
<p>Because the files <code>main.ft</code> and <code>utils.ft</code> form a circle in the last example, you actually also could compile the program with the command <code>flintc -f utils.ft</code> and it would still work, as it would explore all files until it finds the main function. You can always think of file dependencies as a "tree". If, for example, file <code>main.ft</code> includes file <code>A</code>, which includes file <code>B</code> and you specify file <code>A</code> when compiling, you will get an error that no main function is defined, as the <code>main.ft</code> function was no longer part of the tree. If, however, file <code>A</code> or file <code>B</code> include <code>main.ft</code>, the compiler will be able to find the main file and main function again. Try it out and test a few file dependency trees and see for yourself how the compiler will react to it.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="import-aliasing"><a class="header" href="#import-aliasing">Import Aliasing</a></h1>
<div class="warning">
<p>Import aliasing works, but is messed up.</p>
<p>Use Import aliasing with caution, its pretty messed up at the moment, so it would be best to avoid it for the current version of Flint.</p>
</div>
<p>Import aliasing is pretty useful if you have a lot of files in your project and if you have colliding definition names between your files, or imported libraries. For this very reason you can use import-aliasing, to make definitions from different files unambigue. Here is a small example of this:</p>
<p>The <code>utils.ft</code> file:</p>
<pre><code class="language-rs">use Core.print as p

def print(str msg):
    p.print(msg + "\n");
</code></pre>
<p>The <code>main.ft</code> file:</p>
<pre><code class="language-rs">use "utils.ft"

def main():
    print("Hello, World!");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>Hello, Word!
</code></pre>
</blockquote>
<p>As you can see, <strong>any</strong> <code>use</code> clausel can be aliased. The identifier after the <code>as</code> keyword is the aliasing name, which you need to specify when you call the function. If you would remove the <code>p.</code> in the <code>utils.ft</code> file you would get a compile error.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="core-modules"><a class="header" href="#core-modules">Core Modules</a></h1>
<p>Core Modules are essential to Flint, as Flint does not ship with a standard library. Core Modules provide core functionality which just <strong>cannot</strong> be implemented in pure Flint code, as Flint is a high level language. The general rule of thumb is that <strong>everything that can be implemented in pure Flint code will not be part of Core Modules</strong>. In Flint, we aim to provide libraries over on FlintHub and aim to make it as easy as possible to include FlintHub libraries. These libraries are the place where "standard" libraries can be found.</p>
<p>You have actually seen the core modules in action quite a lot until now: The <code>use Core.print</code> line is a special use clausel which tells the compiler to include the <code>print</code> Core module. There are several more core modules than just the <code>print</code> module, though. In this chapter, you will learn which Core modules there exist, which functions they provide and how to use them.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="print"><a class="header" href="#print">print</a></h1>
<pre><code class="language-rs">use Core.print
</code></pre>
<p>The <code>print</code> core module provides several print functions. Here are all the print functions this module provides. There exist <em>a lot</em> of builtin print overloads for the print function.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Parameter Types</th><th style="text-align: center">Return Types</th><th style="text-align: center">Can Throw?</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>str</code></td><td style="text-align: center"><code>void</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>i32</code></td><td style="text-align: center"><code>void</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>i64</code></td><td style="text-align: center"><code>void</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>u32</code></td><td style="text-align: center"><code>void</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>u64</code></td><td style="text-align: center"><code>void</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>f32</code></td><td style="text-align: center"><code>void</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>f64</code></td><td style="text-align: center"><code>void</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>u8</code></td><td style="text-align: center"><code>void</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center"><code>bool</code></td><td style="text-align: center"><code>void</code></td><td style="text-align: center">No</td></tr>
</tbody></table>
</div>
<p>Note that none of the print functions prints a new line after the print. This could be important when printing values in a loop, for example, because calling a "native" print function like <code>print(i32)</code> is generally speaking faster than calling the <code>print(str)</code> function with an interpolated string as argument, as string casting + concatenation takes more time than just calling the specialized print functions one after another. So, while string interpolation is <strong>much</strong> more ergonomic for the programmer, its is also a bit slower generally speaking.</p>
<p>The <code>print(str)</code> function was used throughout this wiki until now. Every string interpolation evaluates to a string value, so this is the function we have called <em>exclusively</em> thus far, to make printing not as overwhelming.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="read"><a class="header" href="#read">read</a></h1>
<pre><code class="language-rs">use Core.read
</code></pre>
<p>The <code>read</code> module provides several functions to read input from the command line and to read input from the user, like numbers or text edited by the user.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">Function Name</th><th style="text-align: left">Parameter Types</th><th style="text-align: center">Return Types</th><th style="text-align: center">Can Throw?</th></tr></thead><tbody>
<tr><td style="text-align: right"><code>read_str</code></td><td style="text-align: left">No</td><td style="text-align: center"><code>str</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: right"><code>read_i32</code></td><td style="text-align: left">No</td><td style="text-align: center"><code>i32</code></td><td style="text-align: center">Yes</td></tr>
<tr><td style="text-align: right"><code>read_i64</code></td><td style="text-align: left">No</td><td style="text-align: center"><code>i64</code></td><td style="text-align: center">Yes</td></tr>
<tr><td style="text-align: right"><code>read_u32</code></td><td style="text-align: left">No</td><td style="text-align: center"><code>u32</code></td><td style="text-align: center">Yes</td></tr>
<tr><td style="text-align: right"><code>read_u64</code></td><td style="text-align: left">No</td><td style="text-align: center"><code>u64</code></td><td style="text-align: center">Yes</td></tr>
<tr><td style="text-align: right"><code>read_f32</code></td><td style="text-align: left">No</td><td style="text-align: center"><code>f32</code></td><td style="text-align: center">Yes</td></tr>
<tr><td style="text-align: right"><code>read_f64</code></td><td style="text-align: left">No</td><td style="text-align: center"><code>f64</code></td><td style="text-align: center">Yes</td></tr>
</tbody></table>
</div>
<h2 id="read_str"><a class="header" href="#read_str">read_str</a></h2>
<p>The <code>read_str</code> function has no parameters and returns a <code>str</code> value. It is used to read a whole line from the console. Note that tis function <em>cannot</em> return an error, as there is no input parsing or input validation taking place.</p>
<pre><code class="language-rs">use Core.print
use Core.read

def main():
    str text = read_str();
    print($"entered text: \"{text}\"\n");
</code></pre>
<h2 id="read_i32"><a class="header" href="#read_i32">read_i32</a></h2>
<p>The <code>read_i32</code> function has no parameters and returns a <code>i32</code> value. It is used to read <code>i32</code> values from the console. It can throw an error if the entered text is not parsable to an signed integer value.</p>
<pre><code class="language-rs">use Core.print
use Core.read

def main():
    i32 num = read_i32();
    print($"entered i32: {num}\n");
</code></pre>
<h2 id="read_i64"><a class="header" href="#read_i64">read_i64</a></h2>
<p>The <code>read_i64</code> function has no parameters and returns a <code>i64</code> value. It is used to read <code>i64</code> values from the console. It can throw an error if the entered text is not parsable to an signed integer value.</p>
<pre><code class="language-rs">use Core.print
use Core.read

def main():
    i64 num = read_i64();
    print($"entered i64: {num}\n");
</code></pre>
<h2 id="read_u32"><a class="header" href="#read_u32">read_u32</a></h2>
<p>The <code>read_u32</code> function has no parameters and returns a <code>u32</code> value. It is used to read <code>u32</code> values from the console. It can throw an error if the entered text is not parsable to an unsigned integer value.</p>
<pre><code class="language-rs">use Core.print
use Core.read

def main():
    u32 num = read_u32();
    print($"entered u32: {num}\n");
</code></pre>
<h2 id="read_u64"><a class="header" href="#read_u64">read_u64</a></h2>
<p>The <code>read_u64</code> function has no parameters and returns a <code>u64</code> value. It is used to read <code>u64</code> values from the console. It can throw an error if the entered text is not parsable to an unsigned integer value.</p>
<pre><code class="language-rs">use Core.print
use Core.read

def main():
    u64 num = read_u64();
    print($"entered u64: {num}\n");
</code></pre>
<h2 id="read_f32"><a class="header" href="#read_f32">read_f32</a></h2>
<p>The <code>read_f32</code> function has no parameters and returns a <code>f32</code> value. It is used to read <code>f32</code> values from the console. It can throw an error if the entered text is not parsable to an floating point value.</p>
<pre><code class="language-rs">use Core.print
use Core.read

def main():
    f32 num = read_f32();
    print($"entered f32: {num}\n");
</code></pre>
<h2 id="read_f64"><a class="header" href="#read_f64">read_f64</a></h2>
<p>The <code>read_f64</code> function has no parameters and returns a <code>f64</code> value. It is used to read <code>f64</code> values from the console. It can throw an error if the entered text is not parsable to an floating point value.</p>
<pre><code class="language-rs">use Core.print
use Core.read

def main():
    f64 num = read_f64();
    print($"entered f64: {num}\n");
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="assert"><a class="header" href="#assert">assert</a></h1>
<pre><code class="language-rs">use Core.assert
</code></pre>
<p>The <code>assert</code> module provides a single <code>assert</code> function, which returns an error if the given condition evaluates to false. It is used for code-assertions and to fail loud and clear.</p>
<pre><code class="language-rs">use Core.assert

def main():
    i32 x = 5;
    assert(x &gt; 6);
</code></pre>
<p>When executing this program you will see this error message printed to the console:</p>
<blockquote>
<pre><code>ERROR: Program exited with exit code '10'
</code></pre>
</blockquote>
<div class="warning">
<p>This error message is not final.</p>
<p>The whole error system of Flint is not yet finished, as the errors are all <code>i32</code> values at the moment still, and <code>error sets</code> are not supported yet. You will see an error message like</p>
<blockquote>
<pre><code>ERROR: Assertion 'x &gt; 6' failed at main.ft:5:5
</code></pre>
</blockquote>
<p>but this needs a lot more work still to be finished.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="filesystem"><a class="header" href="#filesystem">filesystem</a></h1>
<pre><code class="language-rs">use Core.filesystem
</code></pre>
<p>The <code>filesystem</code> module provides several functions to read data from and write data to files.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">Function Name</th><th style="text-align: left">Parameter Types</th><th style="text-align: center">Return Types</th><th style="text-align: center">Can Throw?</th></tr></thead><tbody>
<tr><td style="text-align: right"><code>read_file</code></td><td style="text-align: left"><code>str</code></td><td style="text-align: center"><code>str</code></td><td style="text-align: center">Yes</td></tr>
<tr><td style="text-align: right"><code>read_lines</code></td><td style="text-align: left"><code>str</code></td><td style="text-align: center"><code>str[]</code></td><td style="text-align: center">Yes</td></tr>
<tr><td style="text-align: right"><code>file_exists</code></td><td style="text-align: left"><code>str</code></td><td style="text-align: center"><code>bool</code></td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: right"><code>write_file</code></td><td style="text-align: left"><code>str</code>, <code>str</code></td><td style="text-align: center">No</td><td style="text-align: center">Yes</td></tr>
<tr><td style="text-align: right"><code>append_file</code></td><td style="text-align: left"><code>str</code>, <code>str</code></td><td style="text-align: center">No</td><td style="text-align: center">Yes</td></tr>
<tr><td style="text-align: right"><code>is_file</code></td><td style="text-align: left"><code>str</code></td><td style="text-align: center"><code>bool</code></td><td style="text-align: center">No</td></tr>
</tbody></table>
</div>
<h2 id="read_file"><a class="header" href="#read_file">read_file</a></h2>
<p>The <code>read_file</code> function takes a <code>str</code> parameter, which is the path to the file that wants to be read and returns a <code>str</code> value, containing the content of the given file. This function throws an error if the file does not exist or is not readable.</p>
<pre><code class="language-rs">use Core.print
use Core.filesystem

def main(str[] args):
    if args.length &lt; 2:
        print("No path provided as a cli argument! Exiting...\n");
        return;

    str file_content = read_file(args[1]);
    print($"Read file '{args[1]}':\n");
    print(file_content);
    print("\n");
</code></pre>
<p>When executing this program with the command <code>./main main.ft</code> we get this output:</p>
<blockquote>
<pre><code>Read file 'main.ft':
use Core.print
use Core.filesystem

def main(str[] args):
    if args.length &lt; 2:
        print("No path provided as a cli argument! Exiting...\n");
        return;

    str file_content = read_file(args[1]);
    print($"Read file '{args[1]}':\n");
    print(file_content);
    print("\n");
</code></pre>
</blockquote>
<h2 id="read_lines"><a class="header" href="#read_lines">read_lines</a></h2>
<p>The <code>read_lines</code> function reads a given file (the <code>str</code> path to the file) and returns an array of all read lines (<code>str[]</code>). This function is really useful for reading a file and iterating through each line after reading the file. This function throws an error if the file does not exist or is not readable.</p>
<pre><code class="language-rs">use Core.print
use Core.filesystem

def main(str[] args):
    if args.length &lt; 2:
        print("No path provided as a cli argument! Exiting...\n");
        return;

    str[] lines = read_lines(args[1]);
    print($"Read file '{args[1]}':\n");
    for (idx, line) in lines:
        print($"{idx}:\t| {line}\n");
</code></pre>
<p>When executing this program with the command <code>./main main.ft</code> we get this output:</p>
<blockquote>
<pre><code>Read file 'main.ft':
0:	| use Core.print
1:	| use Core.filesystem
2:	|
3:	| def main(str[] args):
4:	|     if args.length &lt; 2:
5:	|         print("No path provided as a cli argument! Exiting...\n");
6:	|         return;
7:	|
8:	|     str[] lines = read_lines(args[1]);
9:	|     print($"Read file '{args[1]}':\n");
10:	|     for (idx, line) in lines:
11:	|         print($"{idx}:\t| {line}\n");
</code></pre>
</blockquote>
<h2 id="file_exists"><a class="header" href="#file_exists">file_exists</a></h2>
<p>The <code>file_exists</code> function checks whether the given file (<code>str</code> path to the file) exists. This function cannot crash, as it checks for a file's existence, so when it does not exist or is not readable, it just returns <code>false</code>.</p>
<pre><code class="language-rs">use Core.print
use Core.filesystem

def main(str[] args):
    if args.length &lt; 2:
        print("No path provided as a cli argument! Exiting...\n");
        return;

    bool exists = file_exists(args[1]);
    print($"Does file '{args[1]}' exist? {exists}\n");
</code></pre>
<p>When executing this program with the command <code>./main main.ft</code> we get this output:</p>
<blockquote>
<pre><code>Does file 'main.ft' exist? true
</code></pre>
</blockquote>
<h2 id="write_file"><a class="header" href="#write_file">write_file</a></h2>
<p>The <code>write_file</code> function takes two arguments. The first argument is the path to the file to write to (or create) as a <code>str</code> path. The second parameter is the content of the to-be-written file (<code>str</code>). This function will create a file at the given path if the file does not exist yet. If the file exists, this function just overwrites it. This function will throw an error if the given file coould not be opened or could not be written to (for example a permission error).</p>
<pre><code class="language-rs">use Core.print
use Core.filesystem

def main():
    write_file("test_file", "Test File content\nThis is going to be great!");
    str file = read_file("test_file");
    print($"test_file content:\n{file}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>test_file content:
Test File content
This is going to be great!
</code></pre>
</blockquote>
<h2 id="append_file"><a class="header" href="#append_file">append_file</a></h2>
<p>The <code>append_file</code> function will try to append text to an already existent file. The first parameter of the function is the path to the file the new content is appended (<code>str</code> path). The second parameter is the content which will be appended to the file (<code>str</code>). This function will throw an error if the given file does not exist or could not be opened with write access.</p>
<pre><code class="language-rs">use Core.print
use Core.filesystem

def main():
    write_file("test_file", "Test File content\nThis is going to be great!");
    append_file("test_file", "\n\nThis is written with one space in between!");

    str file = read_file("test_file");
    print($"test_file content:\n{file}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>test_file content:
Test File content
This is going to be great!

This is written with one space in between!
</code></pre>
</blockquote>
<h2 id="is_file"><a class="header" href="#is_file">is_file</a></h2>
<p>The <code>is_file</code> function checks whether the file at the given path (<code>str</code>) even is a file. It will return <code>false</code> in the case that the file / directory does not exist. It will also return false if the given "file" is actually a directory. This function cannot throw any errors.</p>
<pre><code class="language-rs">use Core.print
use Core.filesystem

def main():
    print($"is 'test_file' a file? {is_file("test_file")}\n");
    print($"is 'somegarbage' a file? {is_file("somegarbage")}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>is 'test_file' a file? true
is 'somegarbage' a file? false
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="env"><a class="header" href="#env">env</a></h1>
<pre><code class="language-rs">use Core.env
</code></pre>
<p>The <code>env</code> module provides several functions to read from and write to environment variables.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">Function Name</th><th style="text-align: left">Parameter Types</th><th style="text-align: center">Return Types</th><th style="text-align: center">Can Throw?</th></tr></thead><tbody>
<tr><td style="text-align: right"><code>get_env</code></td><td style="text-align: left"><code>str</code></td><td style="text-align: center"><code>str</code></td><td style="text-align: center">Yes</td></tr>
<tr><td style="text-align: right"><code>set_env</code></td><td style="text-align: left"><code>str</code>, <code>str</code>, <code>bool</code></td><td style="text-align: center"><code>bool</code></td><td style="text-align: center">No</td></tr>
</tbody></table>
</div>
<h2 id="get_env"><a class="header" href="#get_env">get_env</a></h2>
<p>The <code>get_env</code> function recieves the currently stored value of a given environment variable (<code>str</code>). The content of the environment variable is returned as a <code>str</code>. This function will throw an error if the requested environment variable does not exist.</p>
<pre><code class="language-rs">use Core.print
use Core.env

def main():
    print($"HOME = {get_env("HOME")}\n");
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>HOME = /home/zweiler1
</code></pre>
</blockquote>
<h2 id="set_env"><a class="header" href="#set_env">set_env</a></h2>
<p>The <code>set_env</code> function sets a given environment variable (<code>str</code>) to a newly specified value (<code>str</code>). The third parameter (<code>bool</code>) controls whether the given environment variable should be overwritten if it already exists. If the third parameter is <code>false</code> an already existent environment variable wont be overwritten. This function cannot throw any errors.</p>
<pre><code class="language-rs">use Core.print
use Core.env

def main():
    bool overwrite_home = set_env("HOME", "something new", false);
    print($"HOME overwritten? {overwrite_home}\n");
    print($"HOME value: {get_env("HOME")}\n");

    bool create_new = set_env("NEW_ENV_VARIABLE", "some nice value", false);
    print($"NEW_ENV_VARIABLE craeted? {create_new}\n");
    print($"NEW_ENV_VARIABLE content: {get_env("NEW_ENV_VARIABLE")}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>HOME overwritten? true
HOME value: /home/zweiler1
NEW_ENV_VARIABLE craeted? true
NEW_ENV_VARIABLE content: some nice value
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="system"><a class="header" href="#system">system</a></h1>
<pre><code class="language-rs">use Core.system
</code></pre>
<p>The <code>system</code> module provides functions to interact with the system, for example to execute system commands.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">Function Name</th><th style="text-align: left">Parameter Types</th><th style="text-align: center">Return Types</th><th style="text-align: center">Can Throw?</th></tr></thead><tbody>
<tr><td style="text-align: right"><code>system_command</code></td><td style="text-align: left"><code>str</code></td><td style="text-align: center"><code>i32</code>, <code>str</code></td><td style="text-align: center">Yes</td></tr>
</tbody></table>
</div>
<h2 id="system_command"><a class="header" href="#system_command">system_command</a></h2>
<p>The <code>system_command</code> function executes a given command, for example <code>ls -lah</code> and returns the exit code of the given command together with the output of the command, stored in a string. The function can throw an error if the process (the command) cannot be created.</p>
<pre><code class="language-rs">use Core.print
use Core.system

def main():
    (exit_code, output) = system_command("ls");
    print($"exit_code = {exit_code}\n");
    print($"output = '{output}'\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>exit_code = 0
output = 'build
build.zig
build.zig.zon
cmake
CMakeLists.txt
compile_flags.txt
documents
examples
fetch_crt.sh
include
LICENSE
logfile
lsp
main
main.o
main.obj
output.ll
README.md
resources
scripts
src
test
test_files
test.o
tests
vendor
'
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="error-sets"><a class="header" href="#error-sets">Error Sets</a></h1>
<div class="warning">
<p>Everything regarding error handling <strong>will</strong> definitely change for later releases.</p>
<p>The current implementation of everything error-handling related is not final for Flint, and it will change quite a lot. This segment of the guide will be updated when the new system works and is in place. For the time being, the description of how it <em>currently</em> works in FLint is written here. So, expect substantial re-writes of this chapter for future releases.</p>
</div>
<p>Flint's error system is quite unique. <strong>Every</strong> function can fail. Absolutely every single function a user defines in his code <em>can</em> fail. Because <em>every</em> function can fail, Flint can deeply integrate error handling into the language. A function returning a <code>str</code> value, for example, actually returns a <code>(i32, str)</code> value. The first <em>implicit</em> return type of <strong>any</strong> Flint function is the error value of said function. This error value, however, is completely hidden from the user outside of Flint's error handling syntax.</p>
<p>Flint has two keywords for error handling: <code>throw</code> and <code>catch</code>. But, unlike Java or C++, where the error handling happens outside the normal execution path ("happy path" / "unhappy path") which completely breaks execution consistency and results in lots of context switching for the CPU, Flint has it's error handling system built directly into the calling / returning code of every function, which makes it much faster than traditional exception-based error handling.</p>
<h2 id="throwing-an-error"><a class="header" href="#throwing-an-error">Throwing an error</a></h2>
<p>Throwing an error is actually really simple. Here is a small examlpe:</p>
<pre><code class="language-rs">use Core.print

def throw_if_bigger_than(i32 x, i32 y):
    if x &gt; y:
        // We can only throw i32 values at the moment
        throw 69;

def main():
    throw_if_bigger_than(10, 5);
</code></pre>
<p>This program will print this line to the console:</p>
<blockquote>
<pre><code>ERROR: Program exited with exit code '69'
</code></pre>
</blockquote>
<p>You have already seen this <code>ERROR: </code> message before, actually, at the <code>assert</code> core module. Even the <code>main</code> function returns an implicit <code>i32</code> error value. And if the main function returns an error value, the error value gets printed to the console like seen above. Because <em>every</em> function can throw an error, <em>every</em> function automatically propagates its returned error up the stack, if we dont handle the error. This is the reason why the call <code>throw_if_bigger_than</code> let the error bubble up to the main function.</p>
<h2 id="catching-an-error"><a class="header" href="#catching-an-error">Catching an error</a></h2>
<p>Catching an error is a bit more complicated.</p>
<pre><code class="language-rs">use Core.print

def err_div(i32 x, i32 y) -&gt; i32:
    if y == 0:
        throw 69;
    return x / y;

def main():
    i32 result = err_div(10, 0) catch err:
        print($"err = {err}\n");
    print($"result = {result}\n");
</code></pre>
<p>This program will print these linese to the console:</p>
<blockquote>
<pre><code>err = 69
result = 0
</code></pre>
</blockquote>
<p>As you can see, if we <code>catch</code> an error explicitely, the first implicit return value of the function is stored inside the <code>err</code> variable. It is now up to us to handle the error. Because the error is just an <code>i32</code> value, the <code>err</code> variable is also of type <code>i32</code> here. We can just compare it to values, and for some values we can set the <code>result</code> value, or for another value we could manually re-throw the error with a <code>throw</code> statement.</p>
<p>Because there does not exist such thing as "uninitialized state" in Flint, the <code>result</code> variable is set to its default value in the case of an error. For the type <code>i32</code> this default value is <code>0</code>. For the <code>str</code> type the default value would be an empty string, a string of size 0, <code>""</code>.</p>
<p>We can also change the <code>result</code> variable within the catch block:</p>
<pre><code class="language-rs">use Core.print

def err_div(i32 x, i32 y) -&gt; i32:
    if y == 0:
        throw 69;
    return x / y;

def main():
    i32 result = err_div(10, 0) catch err:
        print($"err = {err}\n");
        result = 3;
    print($"result = {result}\n");
</code></pre>
<p>This program will print these lines to the console:</p>
<blockquote>
<pre><code>err = 69
result = 3
</code></pre>
</blockquote>
<p>But that's basically it. That's all you need to know about Flint's current error handling features!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="version_select.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
