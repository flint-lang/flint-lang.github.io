# Introduction

This is the Flint Wiki. You will be able to find anything regarding Flint in this Wiki. It's primary focus is to teach Flint, how it works and how to use the language effectively. All features of Flint and how to use them are explained in this Wiki. All chapters are structured in a way where later chapters build on the lessions of earlier chapters, so you will naturally have the best experience with Flint if you follow the guides closely from front to end.

Flint is a high‚Äêlevel, statically typed language designed to deliver maximum power in the most approachable way. Its core philosophy is the Data-Object Convergence Paradigm - an ECS-inspired model where data is separated from behavior and then composed deterministically into class-like entities. Every function in Flint is pure (no side effects), and functions themselves are data that can be passed around. Thanks to the Thread Stack, a very essential part of Flint, we are able to make race conditions impossible just through design, not through endless runtime-checks.

Flint, as you will be able to see, is quite different from most languages. It tries to be easily understandable and familiar and has a C-like syntax because of that. The special thing about Flint is that it is, in my view, the very first true "middle-level" language. It's still a high level language when writing it but _everything_ you write in Flint compiles to a very simple and very shallow runtime. This means that you can always have equivalent C-code in mind while writing Flint code, e.g. once you understand Flint you will be able to easily tell exactly what each line does at a very low level and even be able to map out the assembly code which will likely be generated. This also has the benefit of being pretty fast. The performance target of Flint is to be at most 20% slower than C, or even beating it in some scenarios (MT, SIMD-based workloads).

This means that Flint is both high level and ergonomic but also very shallow in it's abstractions. It starts with the memory management system of Flint, DOCP, which is ARC-based. Flint is _not_ a garbage-collected language since I think these languages tend to be less transparent, and transparency is a very important topic to Flint. Because of Flint's own new paradigm (DOCP) it might not be for everyone, and this is okay.

The goal of Flint is to write fast, predictable code without hidden complexity.
